{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Inicio","text":""},{"location":"#_1","title":"Inicio","text":""},{"location":"tags/","title":"Tags","text":"<p>A continuaci\u00f3n una lista de tags relevantes en el sitio:</p> <p>[TAGS]</p>"},{"location":"77_useful_code/grid_test/","title":"Grid test","text":""},{"location":"77_useful_code/grid_test/#grid-test","title":"Grid test","text":"TP 1 TP 2 TP 3 TP 4 TP 5 TP 6 TP 7 TP 8"},{"location":"info/acerca/","title":"Acerca de la Materia","text":"","tags":["requisitos","costos","inscripci\u00f3n","horarios","programa"]},{"location":"info/acerca/#correlativas-para-alumnos-de-grado-unsam","title":"Correlativas para alumnos de grado UNSAM","text":"<ul> <li>CB14 Estadistica Aplicada</li> <li>CB07 Biolog\u00eda II</li> </ul>","tags":["requisitos","costos","inscripci\u00f3n","horarios","programa"]},{"location":"info/acerca/#requisitos","title":"Requisitos","text":"<ul> <li>Conocimientos de biolog\u00eda molecular: Dogma de la biolog\u00eda molecular, codificaci\u00f3n de informaci\u00f3n en forma de ADN, ARN, proteinas, transcripci\u00f3n, traducci\u00f3n, organizaci\u00f3n celular en procariotas, eucariotas.</li> <li>Conocimientos b\u00e1sicos de estad\u00edstica: distribuciones, probabilidades.</li> <li>Manejo b\u00e1sico de computadoras. </li> </ul>","tags":["requisitos","costos","inscripci\u00f3n","horarios","programa"]},{"location":"info/acerca/#horarios-2do-cuatrimestre-2025-presencial","title":"Horarios 2do Cuatrimestre 2025 (Presencial)","text":"<ul> <li>Presencial: Martes y Jueves 9 a 13hs.</li> </ul>","tags":["requisitos","costos","inscripci\u00f3n","horarios","programa"]},{"location":"info/acerca/#asistencia","title":"Asistencia","text":"<ul> <li>Te\u00f3ricas: Asistencia opcional (Recomendable asistir)</li> <li>Pr\u00e1cticas: Asistencia obligatoria al 80% de los TPs (Hasta 3 ausentes)</li> </ul>","tags":["requisitos","costos","inscripci\u00f3n","horarios","programa"]},{"location":"info/acerca/#evaluacion","title":"Evaluaci\u00f3n","text":"<ul> <li> <p>Evaluaci\u00f3n te\u00f3rica: Un examen hacia el final de la cursada, con recuperatorio. El examen se divide en bloques tem\u00e1ticos que deben ser aprobados por separado. Cada bloque se aprueba con 5.</p> </li> <li> <p>Evaluaci\u00f3n pr\u00e1ctica: Informes de trabajos pr\u00e1cticos y parcialitos. Se aprueban con 5.</p> </li> <li> <p>Promoci\u00f3n:  Tener aprobadas todas las instancias evaluatorios y un promedio de todas las instancias evaluatorias (te\u00f3rico + pr\u00e1ctico) con puntaje de 7 o m\u00e1s (ya sea en primera instancia o recuperatorio).</p> </li> <li> <p>Examen Final: Instancias evaluatorias aprobadas (Puntaje 5 o mayor) y promedio de las instancias evaluatorias menor a 7.</p> </li> <li> <p>Recursa: En caso de no cumplir con requisito de asistencia o instancias evaluatorias no aprobadas.</p> </li> </ul>","tags":["requisitos","costos","inscripci\u00f3n","horarios","programa"]},{"location":"info/acerca/#inscripcion","title":"Inscripci\u00f3n","text":"<p>Para inscribirte vas a necesitar:</p> <ul> <li>Si sos alumno UNSAM:<ul> <li> Hay que inscribirse por el SIU.</li> </ul> </li> </ul>","tags":["requisitos","costos","inscripci\u00f3n","horarios","programa"]},{"location":"info/comollegar/","title":"Como llegar","text":"<ul> <li>Visiten el siguiente enlace para saber como llegar: UNSAM: Como llegar</li> </ul>"},{"location":"info/comollegar/#lugar","title":"Lugar","text":"<ul> <li>La materia se dicta de manera presencial en el Laboratorio 2 de Inform\u00e1tica del Aula TAREA - IIPC.</li> </ul>"},{"location":"info/comollegar/#como-ingresar","title":"Como ingresar","text":"<p>El ingreso es por donde se marca, al final del camino interno del campus, frente del complejo de aulas (Aulario). </p> <p> </p>"},{"location":"info/contenidos/","title":"Programa","text":""},{"location":"info/contenidos/#contenidos-teoricos","title":"Contenidos Te\u00f3ricos","text":"<ul> <li>Experimentos Bioinform\u00e1ticos</li> <li>Conceptos b\u00e1sicos de computaci\u00f3n, algoritmos</li> <li>Bases de datos</li> <li>Ontolog\u00edas</li> <li>Alineamientos de a pares, similitud de secuencias</li> <li>Alineamientos m\u00faltiples</li> <li>Sequence profiles, Hidden Markov Models (I y II)</li> <li>Informaci\u00f3n contenida en alineamientos m\u00faltiples</li> </ul> <ul> <li>Bioinform\u00e1tica estructural</li> <li>Data clustering</li> <li>Secuenciaci\u00f3n y ensamblado de genomas</li> <li>Quimioinform\u00e1tica</li> </ul>"},{"location":"info/contenidos/#contenidos-practicos","title":"Contenidos Pr\u00e1cticos","text":"<ul> <li>Introducci\u00f3n a UNIX</li> <li>EMBOSS Suite</li> <li>Alineamientos de a pares</li> <li>B\u00fasquedas de secuencias por similitud y alineamientos m\u00faltiples</li> <li>Perfiles de secuencia, HMM y PSI-BLAST</li> </ul> <ul> <li>Programando en Biolog\u00eda</li> <li>Bioinform\u00e1tica estructural: Predicci\u00f3n de desorden</li> <li>Bioinform\u00e1tica estructural: Motivos funcionales en prote\u00ednas</li> <li>Bioinform\u00e1tica estructural: Dominios 3D y Modelado por Homolog\u00eda</li> <li>Data mining</li> <li>Visualizaci\u00f3n de genomas</li> <li>Gen\u00f3mica comparativa</li> <li>Short Read Mapping</li> <li>Quimioinform\u00e1tica</li> </ul> <p>  Descargar Programa Oficial </p>"},{"location":"info/cronograma/","title":"Cronograma","text":"<p> Puede estar sujeto a modificaciones.</p> Fecha Hora Donde Clase Tipo Docente Mar, 5 Ago 9 hs  Presencial T1. Presentaci\u00f3n, Conceptos Computaci\u00f3n, Bases de Datos  Te\u00f3rica F. Ag\u00fcero Jue, 7 Ago 9 hs  Presencial T2. Alineamientos, Matrices, Busquedas (1)  Te\u00f3rica F. Ag\u00fcero Mar, 12 Ago 9 hs  Presencial T3. B\u00fasqueda de secuencias por Similitud (2)  Te\u00f3rica F. Ag\u00fcero Jue, 14 Ago 9 hs  Presencial T4. Alineamientos m\u00faltiples  Te\u00f3rica F. Ag\u00fcero Mar, 19 Ago 9 hs  Presencial P1. Introducci\u00f3n a UNIX  Pr\u00e1ctica M. Didier Garnham Jue, 21 Ago 9 hs  Presencial P2. EMBOSS Suite  Pr\u00e1ctica M. Didier Garnham Mar, 26 Ago 9 hs  Presencial P3. Alineamientos de secuencias de a pares  Pr\u00e1ctica G. Romer Jue, 28 Ago 9 hs  Presencial P4. B\u00fasqueda de secuencias por similitud y Alineamientos M\u00faltiples  Pr\u00e1ctica G. Romer Mar, 2 Sep 9 hs  Presencial PP. Programando en Biolog\u00eda  Pr\u00e1ctica R. Quinteros Jue, 4 Sep 9 hs  Presencial PP. Programando en Biolog\u00eda  Pr\u00e1ctica R. Quinteros Mar, 9 Sep 9 hs  Presencial T5. Quimioinform\u00e1tica  Te\u00f3rica F. Ag\u00fcero Jue, 11 Sep 9 hs  Presencial P5. Quimioinform\u00e1tica  Pr\u00e1ctica M. Didier Garnham Mar, 16 Sep 9 hs  Presencial T6. Data clustering  Te\u00f3rica F. Ag\u00fcero Jue, 18 Sep 9 hs  Presencial P6. Data Clustering y Data Mining  Pr\u00e1ctica G. Romer Mar, 23 Sep 9 hs  Presencial T7. Secuenciaci\u00f3n y ensamblado de genomas  Te\u00f3rica F. Ag\u00fcero Jue, 25 Sep 9 hs  Presencial P7. Mapeo de secuencias  Pr\u00e1ctica G. Romer Mar, 30 Sep 9 hs  Presencial T8. Bioinform\u00e1tica Estructural: Desorden  Te\u00f3rica L. Chemes Jue, 2 Oct 9 hs  Presencial P8. Predicci\u00f3n de Desorden  Pr\u00e1ctica J. Glavina Mar, 7 Oct 9 hs  Presencial T9. ANN  Te\u00f3rica L. Chemes Jue, 9 Oct 9 hs  Presencial P9. Perfiles de secuencia y PSI-BLAST  Pr\u00e1ctica H. Garc\u00eda Mar, 14 Oct 9 hs  Presencial T10. Bioinform\u00e1tica Estructural: Motivos lineales  Te\u00f3rica L. Chemes Jue, 16 Oct 9 hs  Presencial P10. Motivos Lineales en prote\u00ednas  Pr\u00e1ctica J. Glavina Mar, 21 Oct 9 hs  Presencial T11. HMM  Te\u00f3rica L. Chemes Jue, 23 Oct 9 hs  Presencial P11. HMM  Pr\u00e1ctica H. Garc\u00eda Mar, 28 Oct 9 hs  Presencial T12. Bioinform\u00e1tica Estructural: Dominios  Te\u00f3rica L. Chemes Jue, 30 Oct 9 hs  Presencial P12. Dominios Proteicos  Pr\u00e1ctica J. Glavina Mar, 4 Nov 9 hs LIBRE Jue, 6 Nov 9 hs LIBRE Mar, 11 Nov 9 hs  Presencial Repaso F. Ag\u00fceroL. Chemes Jue, 13 Nov 9 hs  Presencial Examen F. Ag\u00fceroL. Chemes Mar, 18 Nov 9 hs LIBRE Jue, 20 Nov 9 hs  Presencial Revision parciales F. Ag\u00fceroL. Chemes Mar, 25 Nov 9 hs LIBRE Jue, 27 Nov 9 hs Recuperatorio Jue, 4 Dic 9 hs  Presencial Revisi\u00f3n recuperatorios F. Ag\u00fceroL. Chemes","tags":["cronograma","fechas","feriados"]},{"location":"info/docentes/","title":"Docentes","text":"","tags":["Docentes","Instructores"]},{"location":"info/docentes/#profesores-titulares","title":"Profesores Titulares","text":"<ul> <li>Dr. Fern\u00e1n Ag\u00fcero</li> <li>Dra. Luc\u00eda B. Chemes</li> </ul>","tags":["Docentes","Instructores"]},{"location":"info/docentes/#jefa-de-trabajos-practicos","title":"Jefa de Trabajos Pr\u00e1cticos","text":"<ul> <li>Dra. Juliana Glavina</li> </ul>","tags":["Docentes","Instructores"]},{"location":"info/docentes/#ayudantes-de-1ra","title":"Ayudantes de 1ra","text":"<ul> <li>Lic. Mercedes Didier Garnham</li> <li>Lic. Guadalupe Romer</li> <li>Lic. Ramiro Quinteros</li> </ul>","tags":["Docentes","Instructores"]},{"location":"info/docentes/#ayudantes-de-1ra-ad-honorem","title":"Ayudantes de 1ra Ad-honorem","text":"<ul> <li>Lic. Heli Garc\u00eda Alvarez</li> <li>Lic. Paula Nu\u00f1ez</li> </ul>","tags":["Docentes","Instructores"]},{"location":"info/docentes/#ayudantes-adscriptos","title":"Ayudantes Adscriptos","text":"<ul> <li>Luz Sommariva</li> <li>Santiago Sneidermanis</li> </ul>","tags":["Docentes","Instructores"]},{"location":"info/evaluacion/","title":"Evaluaci\u00f3n","text":"<p>La materia es Promocional. Se aprueba con nota mayor o igual a 5 (cinco), y se promociona con nota mayor o igual a 7 (siete).</p> <p>La nota final se obtiene de promediar la nota de Trabajos Pr\u00e1cticos y las notas del Examen Escrito (cada M\u00f3dulo tiene su examen con su nota).</p>","tags":["examen","informes"]},{"location":"info/evaluacion/#regularidad","title":"Regularidad","text":"<p>Para poder aprobar la cursada (Trabajos Pr\u00e1cticos) se requiere una presencialidad de al menos 80% a las clases Pr\u00e1cticas.</p>","tags":["examen","informes"]},{"location":"info/evaluacion/#informes-de-trabajos-practicos","title":"Informes de Trabajos Pr\u00e1cticos","text":"<p>Algunos Trabajos Pr\u00e1cticos requieren la presentaci\u00f3n de un informe. Los informes ser\u00e1n evaluados y tendr\u00e1n nota. Los TPs que piden la presentaci\u00f3n de un informe est\u00e1n bien marcados en las gu\u00edas:</p> <p>Atenci\u00f3n: Este TP tiene informe.</p>","tags":["examen","informes"]},{"location":"info/evaluacion/#examen-escrito","title":"Examen Escrito","text":"<p>La materia adem\u00e1s se evalua mediante un \u00fanico examen escrito, dividido en M\u00f3dulos Tem\u00e1ticos. </p> <ul> <li>M\u00f3dulo 1 - Secuencias y Alineamientos</li> <li>M\u00f3dulo 2 - B\u00fasquedas por similidud</li> <li>M\u00f3dulo 3 - Gen\u00f3mica </li> <li>M\u00f3dulo 4 - Agrupamiento de Datos </li> <li>M\u00f3dulo 5 - Motivos, Dominios, Perfiles</li> <li>M\u00f3dulo 6 - Bioinform\u00e1tica Estructural</li> </ul> <p>Cada M\u00f3dulo se aprueba (nota mayor o igual a 5), o se reprueba por separado. </p>","tags":["examen","informes"]},{"location":"info/evaluacion/#recuperatorio","title":"Recuperatorio","text":"<p>Habr\u00e1 una instancia de recuperatorio, en la que se deber\u00e1n rendir los M\u00f3dulos no aprobados. </p>","tags":["examen","informes"]},{"location":"info/evaluacion/#condiciones-para-promocion","title":"Condiciones para promoci\u00f3n","text":"<p>Para poder promocionar la materia, se requiere haber aprobado los Trabajos Practicos (nota de informes mayor o igual a 5, y presencialidad de al menos 80%), y haber aprobado todos los m\u00f3dulos con nota mayor o igual a 5, y que el promedio de todas las notas sea mayor o igual a 7. </p>","tags":["examen","informes"]},{"location":"info/evaluacion/#condiciones-para-recursar","title":"Condiciones para recursar","text":"<p>En caso de que el promedio de nota global sea menor a 5, o cuando el n\u00famero de m\u00f3dulos rendidos y aprobados sea </p>","tags":["examen","informes"]},{"location":"info/evaluacion/#examen-final","title":"Examen Final","text":"<p>En caso de haber aprobado la materia (implica haber aprobado los Trabajos Practicos -- nota de informes mayor o igual a 5, y presencialidad de al menos 80%), pero no haber alcanzado la posibilidad de promoci\u00f3n </p>","tags":["examen","informes"]},{"location":"instructivos/inicio/","title":"Inicio","text":"<p>En esta p\u00e1gina encontrar\u00e1n los instructivos que le permitir\u00e1n ir resolviendo algunas cosas t\u00e9cnicas, como por ejemplo: el uso de Replit!</p>","tags":["instructivos"]},{"location":"instructivos/inicio/#consultas-y-canales-de-comunicacion","title":"Consultas y Canales de Comunicaci\u00f3n","text":"<ul> <li> Discord en el canal dedicado a consultas.</li> </ul>","tags":["instructivos"]},{"location":"instructivos/R/","title":"R y Rstudio","text":""},{"location":"instructivos/R/#instalacion-de-r-y-rstudio","title":"Instalaci\u00f3n de R y Rstudio","text":"<p>En esta secci\u00f3n encontrar\u00e1s los pasos a seguir para instalar R y Rstudio en Windows, Mac y Ubuntu</p> <ul> <li> Gu\u00eda de instalaci\u00f3n</li> </ul>"},{"location":"instructivos/maquina_virtual/","title":"Index","text":"","tags":["instructivos","maquina virtual"]},{"location":"instructivos/maquina_virtual/#que-es-una-maquina-virtual","title":"\u00bfQu\u00e9 es una m\u00e1quina virtual?","text":"<p>Las m\u00e1quinas virtuales no son m\u00e1s que computadoras virtuales (denominadas invitadas o guests), emuladas dentro de una computadora real (denominada hospedadora o host).</p> <p>Algunos de sus principales usos son compartir una misma computadora entre muchas personas, tener una computadora que se puede mover completa en un pendrive o similar, o instalar multiples sistemas operativos en una misma computadora de una forma mucho m\u00e1s simple.</p> <p>La virtualizaci\u00f3n es un proceso costoso, ya que si bien nos permite crear nuevas compus, al momento de correrlas estaremos repartiendo los recursos reales (espacio en disco, memoria RAM y velocidad de procesamiento CPU) del host (es decir, de nuestra computadora) entre todas las m\u00e1quinas virtuales guest que est\u00e9n activas.</p> <p>Es por esto que debemos ser cuidadosos al momento de generarlas, d\u00e1ndoles suficientes recursos para funcionar, pero no todos los recursos del host (es decir, de nuestra computadora).</p>","tags":["instructivos","maquina virtual"]},{"location":"instructivos/maquina_virtual/#el-disco-de-maquina-virtual","title":"El disco de m\u00e1quina virtual","text":"<p>El disco de una m\u00e1quina virtual es una \u201cfoto\u201d de un disco de almacenamiento.</p> <p>Todo lo que un disco duro tiene guardado, incluyendo el sistema operativo y los programas instalados, quedar\u00e1n guardados en un archivo cuando la creemos con las herramientas adecuadas. Como no existe un disco duro f\u00edsico se lo considera disco virtual.</p> <p>Este archivo permite regenerar el estado de la computadora desde la que se cre\u00f3 dicho disco al momento de sacar la foto.</p> <p>Los docentes ya hemos ensamblado, para la materia, un disco de m\u00e1quina virtual con Lubuntu 18 (una distribuci\u00f3n versi\u00f3n ultra liviana de Ubuntu 18) en la que hemos instalado todos los programas y herramientas que usaremos en la asignatura. En adelante, nos referiremos a \u00e9ste como IBioinfo.</p>","tags":["instructivos","maquina virtual"]},{"location":"instructivos/maquina_virtual/#puesta-en-funcionamiento-de-maquina-virtual","title":"Puesta en funcionamiento de m\u00e1quina virtual","text":"<p>Este es un instructivo corto sobre c\u00f3mo hacer para correr la m\u00e1quina virtual de la materia en sus computadoras.</p> <p>Vamos a necesitar:</p>","tags":["instructivos","maquina virtual"]},{"location":"instructivos/maquina_virtual/#software-y-archivos-a-usar","title":"Software y archivos a usar","text":"<ul> <li>Oracle VM VirtualBox instalado en nuestras compus.</li> <li>Forma de descomprimir un archivo comprimido ZIP (por ejemplo WinZip para Windows o GUnzip para Linux)</li> <li>El disco de la m\u00e1quina virtual (VMDK)</li> </ul>","tags":["instructivos","maquina virtual"]},{"location":"instructivos/maquina_virtual/#requerimientos-de-hardware-minimos","title":"Requerimientos de Hardware m\u00ednimos","text":"<ul> <li>20 GB de espacio libre en disco duro (para VMDK)</li> <li>2 GB de RAM. </li> </ul>","tags":["instructivos","maquina virtual"]},{"location":"instructivos/maquina_virtual/#paso-1-descargar-la-maquina-virtual","title":"Paso 1. Descargar la M\u00e1quina Virtual","text":"<ul> <li>Pueden usar este link, que tiene la m\u00e1quina que usamos en los TPs (es un link a Dropbox).</li> </ul> <p> M\u00e1quina Virtual</p> Descargar desde Dropbox usando wget <p>En vez de usar una descarga directa para bajar el archivo desde Dropbox, se puede bajar mediante el comando <code>wget</code>. La ventaja de usar <code>wget</code> es que si la descarga est\u00e1 incompleta o les dice que est\u00e1 da\u00f1ado el archivo, pueden volver a correr <code>wget</code> con la opci\u00f3n <code>-c</code> (continuar descarga) para completarla, y volver a probar si pueden validar los checksums o descomprimirlo.</p> <p>En Ubuntu:</p> <ul> <li> <p>Abran la terminal en la ubicaci\u00f3n donde quieren descargar la VM (despu\u00e9s la pueden mover antes de descomprimir)</p> </li> <li> <p>Corran el siguiente comando:</p> <pre><code>wget https://www.dropbox.com/s/2187nlnjc03g8ki/IBioinfo-Lubuntu-32%20v1.3.zip\n</code></pre> </li> </ul> <p>En Windows:</p> <ul> <li>Descarguen la version portable (ZIP) de la \u00faltima versi\u00f3n de <code>wget</code> desde esta p\u00e1gina</li> <li>Descompriman el ZIP en la ubicaci\u00f3n donde quieren descargar la VM (despu\u00e9s la pueden mover antes de descomprimir)</li> <li>Abran la terminal o consola en esa carpeta</li> <li> <p>Corran el siguiente comando:</p> <pre><code>./wget.exe https://www.dropbox.com/s/2187nlnjc03g8ki/IBioinfo-Lubuntu-32%20v1.3.zip\n</code></pre> </li> </ul> <p>Reanudar descarga:</p> <p>Como mencionamos antes, si tienen alg\u00fan problema con la descarga pueden usar la opci\u00f3n <code>-c</code> para completarla. En Ubuntu, un segundo intento ser\u00eda:</p> <pre><code>wget -c https://www.dropbox.com/s/2187nlnjc03g8ki/IBioinfo-Lubuntu-32%20v1.3.zip\n</code></pre> <ul> <li>O bien, si eso falla, pueden probar este link, que es un link a Drive.</li> </ul> <p> M\u00e1quina Virtual desde Drive</p> <p>Atenci\u00f3n</p> <p>Son archivos pesados (~ 9GB). Desc\u00e1rguenlos con tiempo y con conexi\u00f3n estable.</p> <p>Si no cuentan con una conexi\u00f3n estable, pueden escribirnos para buscar alguna soluci\u00f3n alternativa.</p> <ul> <li>O bien, si los dos anteriores fallan pueden probar descargar el archivo zip de la m\u00e1quina virtual partido.</li> </ul> <p> Download zip</p> <p> Download z01</p> <p> Download z02</p> <p> Download z03</p> <p> Download z04</p> <p> Download z05</p> <p> Download z06</p> <p> Download z07</p> <p> Download z08</p> <p> Download MD5 y SHA256</p> <p>Atenci\u00f3n</p> <p>Una vez finalizada la descarga de TODOS los archivos que van a estar guardados en una misma carpeta tienen que descomprimir el archivo <code>.zip</code> como siempre.</p>","tags":["instructivos","maquina virtual"]},{"location":"instructivos/maquina_virtual/#paso-2-validar-la-descarga","title":"Paso 2. Validar la descarga","text":"<p>Una vez descargado el archivo hay que validar la descarga usando checksums. Pueden usar cualquiera de estos checksums (MD5, SHA256), y como respuesta tienen que obtener estos valores. Si los valores no coinciden, la descarga no fue exitosa (el archivo est\u00e1 corrupto y no va a funcionar!). Los valores de los checksums son hexadecimales, da igual si las letras est\u00e1n en mayuscula o minuscula, mientras coincidan est\u00e1 OK. </p> <p>Info</p> <p>IBioinfo-Lubuntu-32 v1.3.zip, MD5 checksum: 8266E14E765D03920E743AA1B09EA56B</p> <p>IBioinfo-Lubuntu-32 v1.3.zip, SHA256 checksum: 7F23F297BDD497704E2DAF712C2E96673600C63978E983D222819F0EE34518FE</p> <p>Pueden estar en may\u00fasculas o min\u00fasculas.</p> <p>Como validar los checksums. Dependiendo de si est\u00e1n usando Windows (Powershell), OSX (Mac, Terminal), o Linux (Terminal), estos son los comandos que tienen que usar: </p> <pre><code># Windows Poweshell \n# asumimos que descargaron el archivo en C:\\Downloads, si no es as\u00ed, cambien el Path!\nGet-FileHash -Algorithm MD5 -Path 'C:\\Downloads\\IBioinfo-Lubuntu-32 v1.3.zip'\nGet-FileHash -Algorithm SHA256 -Path 'C:\\Downloads\\IBioinfo-Lubuntu-32 v1.3.zip'\n</code></pre> <pre><code># OS X (Terminal App) \n# tienen que cambiarse primero al directorio donde hicieron la descarga, por ej Downloads\ncd Downloads\nmd5 IBioinfo-Lubuntu-32 v1.3.zip\nshasum -a 256 IBioinfo-Lubuntu-32 v1.3.zip\n</code></pre> <pre><code># Linux (Terminal) \n# tienen que cambiarse primero al directorio donde hicieron la descarga, por ej Downloads\ncd Downloads\nmd5sum IBioinfo-Lubuntu-32 v1.3.zip\nsha256sum IBioinfo-Lubuntu-32 v1.3.zip\n</code></pre> <p>Luego, solamente si los checksums coinciden (la descarga fue exitosa), descomprimir para obtener el <code>vmdk</code> (pesa alrededor de 15GB, pero puede llegar a crecer un poco durante la cursada).</p> <p>Elegir la ubicaci\u00f3n</p> <p>Elijan la ubicaci\u00f3n final del archivo <code>vmdk</code> ya que una vez creada la Virtual Machine NO se puede mover el archivo <code>.vmdk</code> de lugar.</p>","tags":["instructivos","maquina virtual"]},{"location":"instructivos/maquina_virtual/#paso-3-instalar-virtual-box","title":"Paso 3. Instalar Virtual Box","text":"<ul> <li> <p>Mientras descarga la imagen, aprovechen el tiempo muerto para descargar Oracle VM VirtualBox.</p> </li> <li> <p>El programa es gratuito y pueden descargarlo desde la p\u00e1gina oficial.</p> </li> <li> <p>Descarguen la \u00faltima versi\u00f3n (v6.1) apropiada para su sistema operativo (Windows, OSX o Linux) y sigan las instrucciones del instalador hasta que hayan terminado.</p> </li> </ul>","tags":["instructivos","maquina virtual"]},{"location":"instructivos/maquina_virtual/#paso-4-crear-una-maquina-virtual","title":"Paso 4. Crear una m\u00e1quina virtual","text":"<p>Virtual Box es un virtualizador de entornos. Nos permite generar m\u00e1quinas virtuales. Vamos a crear nuestra m\u00e1quina virtual con el archivo de disco virtual IBioinfo-Lubuntu-32.vmdk que acabamos de descargar. Para eso:</p> <ol> <li> <p>Abrimos Virtual Box:</p> <p></p> </li> <li> <p>Hacemos click en <code>New</code> o <code>Nueva</code></p> </li> <li> <p>Aparecer\u00e1 una caja de di\u00e1logo, en donde deberemos indicar:</p> <ul> <li>Name o Nombre: Es el nombre que queremos darle a la m\u00e1quina virtual. Elijan el que quieran.</li> <li>Machine Folder o Carpeta de M\u00e1quina: Es la ubicaci\u00f3n de la configuraci\u00f3n de la m\u00e1quina virtual. Elijan la que quieran.</li> <li>Type o Tipo: Es el tipo de virtualizaci\u00f3n. Elijan Linux.</li> <li>Version o Versi\u00f3n: Es la versi\u00f3n del sistema operativo. Ubuntu 32 bits.</li> </ul> <p></p> </li> <li> <p>En el mismo panel deberemos indicar la cantidad de memoria RAM que vamos a prestarle a la m\u00e1quina virtual.</p> <p>Pongan la m\u00e1xima que puedan dentro de la regi\u00f3n verde (recuerden que al momento de usar la m\u00e1quina virtual, \u00e9sta sustraer\u00e1 autom\u00e1ticamente recursos de nuestra compu). </p> <p>Estos valores depender\u00e1n de la cantidad de RAM f\u00edsica que tenga nuestro host. Cuanto m\u00e1s RAM le demos a la m\u00e1quina virtual, m\u00e1s r\u00e1pido va a andar. Para las tareas que realizaremos, darle entre 2 y 4 GB de ram (2048-4096 MB) estar\u00e1 bien.</p> <p></p> </li> <li> <p>Y finalmente el disco duro. Aqu\u00ed es donde entra nuestro archivo IBioinfo-Lubuntu.vmdk:</p> <p></p> <p>Haciendo click en el icono de la carpeta a la derecha, agregaremos nuestro disco virtual:</p> <p>A\u00f1adir \u2192 elegimos nuestro VMDK</p> <p></p> </li> <li> <p>Con esto habremos finalizado la creaci\u00f3n y podremos comenzar. Si todo sali\u00f3 bien, deber\u00e1n ver una entrada con su m\u00e1quina virtual recientemente creada en el Inicio del Virtual Box.</p> </li> <li> <p>Intenten correr la m\u00e1quina virtual haciendo click en \u201cIniciar\u201d. En breve deber\u00edan ver el logo de Lubuntu y pronto el escritorio del sistema operativo. </p> </li> </ol> <p>Contrase\u00f1a</p> <p>Si les pide alguna contrase\u00f1a, la misma es unsam.</p> <p>No cambiar ubicaci\u00f3n</p> <p>Una vez creada la Virtual Machine NO muevan el archivo .vmdk de lugar. Si lo hicieron, f\u00edjense en la secci\u00f3n de problemas que est\u00e1 la soluci\u00f3n.</p>","tags":["instructivos","maquina virtual"]},{"location":"instructivos/problemasVM/","title":"Problemas y posibles soluciones","text":""},{"location":"instructivos/problemasVM/#problemas-y-posibles-soluciones","title":"Problemas y posibles soluciones","text":""},{"location":"instructivos/problemasVM/#no-funciona-y-eligieron-la-virtualizacion-de-32-bits-es-la-unica-que-se-esta-ofreciendo","title":"No funciona y eligieron la virtualizaci\u00f3n de 32 bits (es la \u00fanica que se est\u00e1 ofreciendo)","text":"<p>Soluci\u00f3n:</p> <ul> <li> <p>Habilitar una opci\u00f3n de virtualizaci\u00f3n especial (<code>PAN/NX</code>), sobre todo en sistemas nuevos.</p> </li> <li> <p>Para hacerlo: </p> <p>Click derecho en la m\u00e1quina virtual \u2192 Configuraci\u00f3n \u2192 Sistema \u2192 Procesador \u2192 Habilitar PAE/NX</p> </li> <li> <p>Habilitar PAE/NX tiene que estar con el tick</p> </li> </ul>"},{"location":"instructivos/problemasVM/#sigue-sin-funcionar","title":"Sigue sin funcionar","text":"<ul> <li>Habilitar PAE/NX est\u00e1 tildado y la m\u00e1quina virtual se queda congelada en una pantalla similar a la siguiente:</li> </ul> <p>Soluci\u00f3n:</p> <ul> <li> <p>Click derecho en la m\u00e1quina virtual \u2192 Configuraci\u00f3n \u2192 Sistema \u2192 Procesador</p> </li> <li> <p>Prueben con 2 o 4 procesadores en la barra que dice Procesador(es), siempre manej\u00e1ndose dentro del rango verde.</p> </li> </ul>"},{"location":"instructivos/problemasVM/#mensaje-de-error-this-computer-does-not-have-hardware-assisted-virtualization","title":"Mensaje de Error: \"This computer does not have hardware-assisted virtualization\"","text":"<ul> <li>La computadora, por defecto, no permite la virtualizaci\u00f3n.</li> </ul> <p>Soluci\u00f3n:</p> <ul> <li>Sigan los pasos descritos en este post.</li> </ul>"},{"location":"instructivos/problemasVM/#en-sistema-aparece-cartel-que-dice-el-hardware-de-virtualizacion-esta-habilitado-en-la-seccion-de-aceleracion-de-la-pagina-de-sistema","title":"En sistema aparece cartel que dice: el hardware de virtualizaci\u00f3n est\u00e1 habilitado en la secci\u00f3n de aceleraci\u00f3n de la p\u00e1gina de Sistema...","text":"<p>Soluci\u00f3n:</p> <ul> <li>Accedan a la pesta\u00f1a de <code>Aceleraci\u00f3n</code> y aseg\u00farense de que no haya ninguna interfaz de paravirtualizaci\u00f3n seleccionada.</li> </ul> <p></p>"},{"location":"instructivos/problemasVM/#error-could-not-open-medium","title":"Error: \"Could not open medium\"","text":"<ul> <li>Es posible que hayan movido el archivo vmdk.</li> </ul> <p>Soluci\u00f3n:</p> <ul> <li> <p>Vayan a:</p> <p>Archivo \u2192 Biblioteca de Medios (Virtual media manager) y remuevan el disco problem\u00e1tico.</p> </li> <li> <p>Si la opci\u00f3n de remover les aparece deshabilitada, deber\u00e1n \u201cLiberarlo\u201d primero. Luego, borren la m\u00e1quina virtual y vu\u00e9lvanla a crear usando la nueva (y definitiva) ubicaci\u00f3n del archivo vmdk.</p> </li> </ul>"},{"location":"instructivos/problemasVM/#error-kernel-driver-not-installed-rc-1908","title":"Error: Kernel driver not installed (rc=-1908)","text":"<p>Soluci\u00f3n para m\u00e1quina f\u00edsica/host con sistema operativo Ubuntu:</p> <ul> <li> <p>Abrir la terminal y correr los siguientes comandos:</p> <pre><code>sudo dpkg-reconfigure virtualbox-dkms\nsudo /sbin/vboxconfig\n</code></pre> </li> <li> <p>Luego de esto, abrir nuevamente VirtualBox e iniciar la maquina virtual. El error se deber\u00eda haber solucionado.</p> </li> </ul>"},{"location":"instructivos/replit/","title":"Replit","text":""},{"location":"instructivos/replit/#uso-de-replit","title":"Uso de Replit","text":"<ul> <li> <p>Video Explicativo de Sebasti\u00e1n Jinich sobre como usar Replit (consola online)</p> </li> <li> <p> Video Explicativo</p> </li> </ul> <p>En la p\u00e1gina de cada TP van a encontrar el link al replit correspondiente.</p>"},{"location":"instructivos/tipsVM/","title":"Index","text":""},{"location":"instructivos/tipsVM/#maximizar-la-ventana","title":"Maximizar la ventana","text":"<p>Si maximizamos la ventana a pantalla completa, ser\u00e1 como estar usando la m\u00e1quina virtual solamente. Esto para algunos puede resultar m\u00e1s c\u00f3modo. Pueden probarlo presionando las teclas Ctrl derecho + F juntas. Con volver a presionar esas teclas salen de la pantalla completa.</p> <p></p>"},{"location":"instructivos/tipsVM/#acceso-a-la-linea-de-comandos","title":"Acceso a la l\u00ednea de comandos","text":"<p>Para acceder a la l\u00ednea de comandos hay varias formas:</p> <ul> <li>Forma 1: Inicio Herramientas del sistema LXTerminal</li> <li>Forma 2: Presionar las teclas Ctrl + Alt + T, las tres juntas. Ctrl y Alt tienen que ser los de la izquierda.</li> <li>Forma 3: Presionando la tecla F4 en la carpeta donde nos encontremos.</li> </ul>"},{"location":"instructivos/tipsVM/#cambiar-el-layout-del-teclado","title":"Cambiar el layout del teclado","text":"<p>Para cambiar el layout del teclado (en que tecla est\u00e1 el @, el |, los par\u00e9ntesis, etc):</p> <ol> <li> <p>Click derecho en el panel:</p> <p></p> </li> <li> <p>Seleccionar A\u00f1adir/quitar elementos del panel</p> <p></p> </li> <li> <p>Seleccionar A\u00f1adir Agente de distribuci\u00f3n del teclado</p> <p></p> </li> <li> <p>Hacer click en A\u00f1adir y cerrar la ventana.</p> <p>En el panel aparecer\u00e1 al lado del bot\u00f3n de apagado la bandera espa\u00f1ola, click derecho sobre la bandera y seleccionar la primera opci\u00f3n: Configuraci\u00f3n de Agente de distribuci\u00f3n de teclado</p> <p></p> </li> <li> <p>Se abrir\u00e1 una ventana. Destildar la opci\u00f3n: Mantener las distribuciones del sistema y se habilitar\u00e1n las opciones:</p> <p></p> </li> <li> <p>En Distribuciones del teclado elegir A\u00f1adir y busca en la lista el teclado correspondiente.</p> <p>Los m\u00e1s comunes son:</p> <ul> <li>Espa\u00f1ol (es)</li> <li>Espa\u00f1ol latinoamericano (latam)</li> <li>Ingl\u00e9s (EE.UU.) (us)</li> </ul> <p>Si no sab\u00e9s cual es: pod\u00e9s chequear algunos teclados en Wiki en la secci\u00f3n QUERTY.</p> </li> <li> <p>Selecciona el que corresponda y haz click en Aceptar. Volver\u00e1 a la ventana anterior donde puedes subir la configuraci\u00f3n que desees usar (o quitar la que no quieres usar).</p> <p></p> </li> </ol> <p>8. Si dejaste m\u00e1s de una configuraci\u00f3n, haciendo click sobre la banderita en el panel pod\u00e9s cambiar a las distintas configuraciones (va cambiando la etiqueta).</p>"},{"location":"instructivos/tipsVM/#copiar-y-pegar-de-maquina-host-a-maquina-virtual-y-viceversa","title":"Copiar y pegar de m\u00e1quina host a m\u00e1quina virtual y viceversa","text":"<p>Para copiar y pegar de la m\u00e1quina host (es decir, sus compus f\u00edsicas) a la m\u00e1quina virtual (la de la materia) tienen que:</p> <ol> <li>Con la m\u00e1quina virtual abierta</li> <li> <p>Van a Devices/Dispositivos Shared Clipboard/Portapapeles Compartido y seleccionan Bidirectional/Bidireccional</p> <p></p> </li> </ol>"},{"location":"instructivos/tipsVM/#compartir-una-carpeta-con-la-maquina-host","title":"Compartir una carpeta con la m\u00e1quina host","text":"<p>Una manera simple de compartir archivos entre la m\u00e1quina host (es decir, sus compus f\u00edsicas) y la m\u00e1quina virtual o viceversa es crear una carpeta compartida, para esto:</p> <ol> <li>Con la m\u00e1quina virtual abierta</li> <li> <p>Van a Devices/Dispositivos Shared Folder/Carpetas Compartidas y seleccionan Shared Folders Settings/Preferencias de carpetas compartidas.</p> <p>Se les abrir\u00e1 una ventana, donde deben elegir la carpetita con el s\u00edmbolo m\u00e1s que est\u00e1 a la derecha para agregar una carpeta compartida y se les abrir\u00e1 una nueva ventana.</p> <p></p> <ul> <li>Folder Path: Indican la ruta a la carpeta que van a compartir en la m\u00e1quina host (SU computadora).</li> <li>Folder Name: El nombre con el que aparecer\u00e1 la carpeta en la m\u00e1quina virtual</li> <li>Auto-mount: Tiene que estar tickeado.</li> <li>Make Permanent: Tiene que estar tickeado.</li> </ul> </li> <li> <p>Click en Ok.</p> </li> <li> <p>Deber\u00edan ver algo similar a lo siguiente:</p> <p></p> </li> <li> <p>Click en Ok.</p> </li> <li> <p>Se les debe haber creado un \u00edcono en el escritorio de la m\u00e1quina virtual con el nombre que eligieron en Folder Name</p> </li> <li> <p>Si hacen click, deber\u00edan poder acceder a la carpeta. Si aparece un cartel donde dice que no tienen los permisos necesarios, entonces hacen lo siguiente.</p> <ol> <li>Abren una terminal utilizando las teclas: Ctrl + Alt + T</li> <li> <p>Escriben lo siguiente en la terminal:</p> <pre><code>sudo usermod -a -G vboxsf $(whoami)\n</code></pre> <p>Si les pide una clave es unsam</p> </li> </ol> </li> </ol>"},{"location":"instructivos/tipsVM/#acceso-a-internet","title":"Acceso a Internet","text":"<p>Es necesario que la m\u00e1quina virtual tenga acceso a internet. Puede ser que esto funcione automaticamente, pero de no ser as\u00ed pueden hacer:</p> <ol> <li> <p>Van a Settings/Configuraci\u00f3n Network/Red </p> </li> <li> <p>Habilitan en la pesta\u00f1a Adapter 1 la opci\u00f3n Enable Network Adapter</p> <p></p> </li> </ol> <p>Enable Network Adapter tiene que estar tildado.</p>"},{"location":"instructivos/tipsVM/#resolucion-de-pantalla","title":"Resoluci\u00f3n de Pantalla","text":"<p>Por defecto, la pantalla de la m\u00e1quina virtual deber\u00eda agrandarse seg\u00fan el tama\u00f1o de su monitor. Si esto no sucede pueden agrandar la pantalla a mano haciendo:</p> <ol> <li> <p>Click en el Bot\u00f3n inicio de Lubuntu  (esquina inferior izquierda)</p> </li> <li> <p>Click en Preferencias</p> </li> <li> <p>Click en Ajustes del monitor</p> <p></p> </li> <li> <p>Pasar la resoluci\u00f3n a la mayor posible (podemos usar la misma que usamos en el sistema operativo del host)</p> <p></p> </li> <li> <p>Click en Aplicar y, si estamos conformes, en Guardar.</p> </li> <li> <p>Para que la resoluci\u00f3n de pantalla elegida sea permanente:</p> <p>Esta versi\u00f3n de lubuntu presenta un bug donde la resoluci\u00f3n cambia cada vez que se suspende la VM. Por lo tanto la forma m\u00e1s sencilla de solucionarlo es configurando la VM para no suspenderse m\u00e1s:</p> <ol> <li>Click en el Bot\u00f3n inicio de Lubuntu  (esquina inferior izquierda)</li> <li>Click en Preferencias</li> <li>Click en Administrador de energ\u00eda</li> <li> <p>Click en la pesta\u00f1a Pantalla y luego mover las tres barras hasta la izquierda como se muestra en la siguiente imagen:</p> <p></p> </li> <li> <p>Click en la pesta\u00f1a Seguridad y luego seleccionar \"Nunca\" en la lista desplegable que aparece al lado de Bloquear sesi\u00f3n autom\u00e1ticamente y luego destildar donde dice \"Bloquear la pantalla cuando el sistema vaya a suspensi\u00f3n\". Tiene que quedar como se ve en la siguiente imagen:</p> <p></p> </li> </ol> </li> </ol>"},{"location":"practicos/inicio/","title":"Inicio","text":"<p>Esta es la p\u00e1gina de inicio de los pr\u00e1cticos de este curso. A continuaci\u00f3n una lista de datos \u00fatiles.</p>","tags":["practicos"]},{"location":"practicos/inicio/#consultas-y-canales-de-comunicacion","title":"Consultas y Canales de Comunicaci\u00f3n","text":"<ul> <li> Por email a la direcci\u00f3n de la JTP.</li> <li> en Discord pueden mandar mensajes a todo el grupo en los distintos canales.</li> </ul>","tags":["practicos"]},{"location":"practicos/inicio/#informes","title":"Informes","text":"<p>Alguno de los trabajos pr\u00e1cticos de la cursada requieren una resoluci\u00f3n de un problema a informar. Al final de la gu\u00eda de trabajos pr\u00e1cticos se indicar\u00e1 el problema a resolver.</p> <p>La funci\u00f3n de los informes es:</p> <ul> <li>Que ustedes puedan aplicar los conocimientos y herramientas adquiridas durante la cursada a un problema puntual</li> <li>Evaluar la capacidad t\u00e9cnica para producir resultados, as\u00ed como tambi\u00e9n el criterio a la hora de evaluar el significado biol\u00f3gico de los mismos y la comprensi\u00f3n de las potencialidades y limitaciones de los algoritmos o herramientas empleadas.</li> <li>Evaluar la capacidad de elaborar informes</li> </ul> <p>Cada informe de cada trabajo pr\u00e1ctico puede (o no) estar relacionado con alguno anterior. Por lo tanto: Guarden los archivos y sean prolijos.</p> <p>El trabajo deber\u00e1 ser realizado con las mismas personas con la que realizan los trabajos pr\u00e1cticos normalmente. </p> <p>Es UNA entrega por grupo. Esta entrega deber\u00e1 ser realizada en tiempo y forma, por correo electr\u00f3nico a la persona encargada del trabajo pr\u00e1ctico.</p> <p>Formato Correo Electr\u00f3nico de Entrega de TP</p> <p>Cuando env\u00edan el correo. El asunto del correo debe ser: Entrega Informe TP01 - Grupo 01</p> <p>Durante la cursada deber\u00e1n ir entregando de forma individual los ejercicios correspondientes a cada trabajo pr\u00e1ctico, los cuales ser\u00e1n aprobados o desaprobados. En caso de estar desaprobado tendr\u00e1n una semana despu\u00e9s de la devoluci\u00f3n para re-entregarlo.</p>","tags":["practicos"]},{"location":"practicos/inicio/#formato-a-respetar-para-los-informes","title":"Formato a respetar para los informes","text":"<p>Los informes deben constar de:</p> <ol> <li>Car\u00e1tula: 1 hoja En esta hoja se incluir\u00e1:<ol> <li>N\u00famero y t\u00edtulo del trabajo pr\u00e1ctico (respetar el n\u00famero que figura en la gu\u00eda)</li> <li>N\u00famero de grupo</li> <li>Nombre y Apellido y direcci\u00f3n de correo electr\u00f3nico de cada uno de los integrantes del grupo</li> <li>Fecha de entrega</li> </ol> </li> <li>Informe: 5 hojas m\u00e1ximo. En estas 5 hojas se debe incluir:<ol> <li>Introducci\u00f3n: 1 hoja m\u00e1ximo y NO debe ser la que se utiliza en el trabajo pr\u00e1ctico que entregan los docentes.</li> <li>Objetivo general y objetivos espec\u00edficos</li> <li>M\u00e9todos y resultados</li> <li>Discusi\u00f3n</li> <li>Bibliograf\u00eda (10 referencias m\u00e1ximo)</li> </ol> </li> <li>Anexo. No hay l\u00edmite de hojas pero se tendr\u00e1 en cuenta si es referenciado o no en el cuerpo del informe (es decir, no pongan cosas innecesarias)</li> </ol> <p>Respecto del formato:</p> <ul> <li>Se deber\u00e1n entregar en archivos PDFs nombrados de la siguiente manera: <code>TPXX_GRUPO_XX.pdf</code> (por ejemplo, <code>TP08_GRUPO_01.pdf</code>)</li> <li>Tama\u00f1o de hoja: A4</li> <li>Interlineado: 1.15</li> <li>Letra y tama\u00f1o de letra: Arial 11pts</li> <li>Margen: 2 cm</li> </ul> <p>Aviso</p> <p>El formato ser\u00e1 considerado en la puntuaci\u00f3n final del trabajo pr\u00e1ctico</p> <p>La presentacion con recomendaciones de para la elaboracion de informes est\u00e1 en este link</p> <ul> <li>Consulten siempre que tengan dudas !!</li> </ul>","tags":["practicos"]},{"location":"practicos/resumen/","title":"Resumen","text":"","tags":["practicos","fin","resumen"]},{"location":"practicos/resumen/#this-is-the-end","title":"This is the end ...","text":"<p>Bueno, hemos llegado al final de la parte pr\u00e1ctica del curso. Felicitaciones!  quer\u00e9s seguir explorando t\u00f3picos y ganando experiencia, te dejamos a continuaci\u00f3n algunos links a distintos materiales y recursos:</p> <ul> <li> Libros<ul> <li>Libro 1 </li> <li>Libro 2</li> </ul> </li> <li> Online<ul> <li>Material 1</li> <li>Material 2</li> </ul> </li> <li> Presencial<ul> <li>Presencial 1</li> <li>Presencial 2</li> </ul> </li> <li> Grupos<ul> <li>Asociaci\u00f3n Argentina de Bioinform\u00e1tica y Biolog\u00eda Computacional (A<sup>2</sup>B<sup>2</sup>C)</li> <li>RSG-Argentina</li> </ul> </li> </ul>","tags":["practicos","fin","resumen"]},{"location":"practicos/tpsGrid/","title":"tpsGrid","text":"TP 1  hola"},{"location":"practicos/TP01_Linux/","title":"Practico Uno","text":"","tags":["practicos"]},{"location":"practicos/TP01_Linux/#tp-1-introduccion-a-ubuntu-bash-y-programacion","title":"TP 1. Introducci\u00f3n a Ubuntu, Bash y Programaci\u00f3n","text":"<p> Materiales</p> <p> Slides (Parte 1)  Slides (Parte 2)  Resoluci\u00f3n Ejercicio 3</p>","tags":["practicos"]},{"location":"practicos/TP01_Linux/#terminal-online","title":"Terminal online","text":"<ul> <li>Replit</li> </ul>","tags":["practicos"]},{"location":"practicos/TP01_Linux/#recursos-online","title":"Recursos Online","text":"<ul> <li>Programando en Bash</li> <li>Comando AWK</li> <li>Consola de Linux online (y otra)</li> <li>Compilador de Bash online (y otro)</li> </ul>","tags":["practicos"]},{"location":"practicos/TP01_Linux/#objetivos","title":"Objetivos","text":"<ul> <li>Familiarizarse un poco con Ubuntu y su estructura de directorios</li> <li>Familiarizarse con el uso b\u00e1sico de los comandos de Bash</li> <li>Familiarizarse con los bloques l\u00f3gicos b\u00e1sicos de la programaci\u00f3n</li> </ul>","tags":["practicos"]},{"location":"practicos/TP01_Linux/#introduccion-al-tema","title":"Introducci\u00f3n al Tema","text":"<p>En este trabajo pr\u00e1ctico vamos a aprender a usar la l\u00ednea de comando de Ubuntu (tambi\u00e9n referida como terminal, consola o shell). Para muchos de nosotros, que estamos acostumbrados a la interfaz gr\u00e1fica de sistemas operativos como los de Windows o GUI (por las siglas en ingles: Graphic User Interface), la l\u00ednea de comando puede parecer un desaf\u00edo, pero con pr\u00e1ctica y algo de paciencia descubrir\u00e1n que puede resultar amena. Su uso tiene dos ventajas destacables para nuestro campo:</p> <ul> <li>Nos permitir\u00e1 trabajar en entornos o programas sin interfaz gr\u00e1fica (GUI)</li> <li>Mediante el uso de programas o scripts, nos permitir\u00e1 automatizar procesos, acelerando el trabajo y minimizando la cantidad de errores que podemos cometer con tareas repetitivas</li> </ul>","tags":["practicos"]},{"location":"practicos/TP01_Linux/#unix-linux-ubuntu","title":"\u00bfUnix? \u00bfLinux? \u00bfUbuntu?","text":"<p>Dependiendo que tan familiares est\u00e9n con Linux, todos estos nombres pueden resultar un poco confusos. Vamos por partes:</p> <ul> <li> <p>Unix es un sistema operativo creado en 1969 por dos programadores estadounidenses que trabajaban para Bell Labs, una compan\u00eda de investigaci\u00f3n y desarrollo cient\u00edfico que en su momento era propiedad de AT&amp;T (compa\u00f1ia estadounidense de tel\u00e9fonos). Al ser un sistema operativo portable, multitarea y multiusuario se hizo r\u00e1pidamente popular y se difundi\u00f3 por instituciones acad\u00e9micas y empresas</p> </li> <li> <p>Debido a su popularidad, otros programadores quisieron hacer sus propias versiones de sistemas operativos basados en Unix, pero como sus sistemas operativos ten\u00edan c\u00f3digo original de Unix, AT&amp;T los demand\u00f3, paralizando esta tendenc\u00eda</p> </li> <li> <p>En 1983 se crea el proyecto GNU con el objetivo de crear un sistema operativo similar a Unix, pero gratis y de c\u00f3digo abierto. GNU significa \"GNU's Not Unix\" (es un anagrama recursivo, los programadores se divierten barato). Hacia el fin de los 80s el proyecto ya ten\u00eda casi todos los programas que necesitaba, pero les faltaba conseguir un buen kernel (principal responsable de facilitar a los distintos programas acceso seguro al hardware de la computadora)</p> </li> <li> <p>En 1991, Linus Torvalds empieza a crear lo que terminar\u00eda siendo Linux, un sistema operativo con su propio kernel que usaba muchas de los programas del proyecto GNU. Esta versi\u00f3n se volvi\u00f3 r\u00e1pidamente la m\u00e1s popular de todas las versiones de GNU, llevando a que en 1993 se creara el Debian Project, un proyecto comunal con el objetivo de mejorar una distrubuci\u00f3n de Linux que denominaron Debian GNU/Linux (tambi\u00e9n llamada simplemente Debian).</p> </li> <li> <p>Ubuntu es una distribuci\u00f3n de Linux creada en 2004 basada en Debian. Al d\u00eda de la fecha es la distrubuci\u00f3n m\u00e1s popular de Linux con m\u00e1s del 50% de los usuarios.</p> </li> <li> <p>Lubuntu, que es el sistema operativo que us\u00e1bamos en la m\u00e1quina virtual, es una distribuci\u00f3n de Linux creada en 2009 basada en Ubuntu. Es bastante similar a Ubuntu en todo lo que es consola, pero tiene una interfaz gr\u00e1fica que consume menos recursos, haci\u00e9ndolo ideal para m\u00e1quinas m\u00e1s viejas (o en nuestro caso, m\u00e1quinas virtuales que pesen lo menos posible).</p> </li> </ul>","tags":["practicos"]},{"location":"practicos/TP01_Linux/#estructura-de-directorios-de-ubuntu","title":"Estructura de directorios de Ubuntu","text":"<p>La organizaci\u00f3n de archivos en Ubuntu y Lubuntu es bastante diferente a la de Windows. Si bien no vamos a detallar completamente toda la estructura y que es cada carpeta (porque el 95% no lo van a usar en esta materia), es importante tener una idea de lo b\u00e1sico:</p> <ul> <li>/  Carpeta raiz, o root. Contiene al resto de las carpetas<ul> <li>/etc  Configuraciones del sistema para todos los usuarios (mucho cuidado al tocar)</li> <li>/home  Ubicaci\u00f3n de los directorios de los diferentes usuarios (o en este caso el \u00fanico usuario)<ul> <li>/home/ibioinfo  Directorio del usuario ibioinfo. Es el lugar donde van a trabajar la mayor\u00eda del tiempo (incluye tanto el Escritorio como Documentos) y donde se abre por defecto la terminal (m\u00e1s sobre esto en un ratito). Com\u00fanmente referida como home directory o home del usuario ibioinfo</li> </ul> </li> <li>/media  Si fuera una computadora normal (no VM) aca aparecer\u00edan los pendrives. En nuestro caso aca aparecen por defecto las carpetas compartidas con la PC host</li> <li>/tmp  Ubicaci\u00f3n de los archivos temporales de los programas</li> <li>/var  Ubicaci\u00f3n de los archivos variables de los programas, como logs, bases de datos, paginas webs, etc<ul> <li>/var/log  Probablemente la subcarpeta m\u00e1s usada de /var. Contiene los logs de los programas (que a veces es la \u00fanica forma de saber porque algo no anduvo)</li> </ul> </li> </ul> </li> </ul> <p>Esto es simplemente un vistazo r\u00e1pido. Si quieren la lista completa de subdirectorios de Ubuntu la pueden encontrar en esta p\u00e1gina, pero tengan en cuenta que tocar cualquier cosa fuera de /home conlleva la posibilidad de arruinar la computadora. En esta materia vamos a usar principalmente /home y /media.</p>","tags":["practicos"]},{"location":"practicos/TP01_Linux/#linea-de-comando","title":"L\u00ednea de comando","text":"<p>Como ya dijimos en la introducci\u00f3n la l\u00ednea de comando tiene varios nombres, y en esta guia nos vamos a referir a ella como terminal o consola. Hay varias formas de abrir la terminal:</p> <ul> <li>Desde cualquier lado: Ctrl+Alt+T</li> <li>Desde cualquier lado: Inicio (menu de abajo a la izquierda) Herramientas del sistema Terminal</li> <li>Desde afuera de una carpeta: Boton derecho en la carpeta Abrir en el terminal</li> <li>Desde adentro de una carpeta: Herramientas Abrir la carpeta actual en un terminal (o apretar F4)</li> </ul> <p>La terminal funciona como un explorador de archivos que se mueve entre las carpetas. Los primeros dos m\u00e9todos van a abrir la terminal en /home/ibioinfo, mientras que los \u00faltimos dos m\u00e9todos van a abrir la terminal en la carpeta elegida. Si en algun momento les decimos que abran la terminal y no aclaramos otra cosa nos referimos a abrirla en /home/ibioinfo.</p> <p>Abran la terminal en /home/ibioinfo y deberian ver algo as\u00ed:</p> <pre><code>ibioinfo@ibioinfo-VirtualBox:~$\n</code></pre> <p>Donde ibioinfo es el nombre del usuario actual e ibioinfo-VirtualBox el nombre de la computadora (que justo en este caso son similares, pero no es necesario). El ~ despu\u00e9s de los dos puntos (conocido como \"virgulilla\", \"tilde\" o \"cosito de la \u00f1\") parece ser parte de la terminal, pero en realidad est\u00e1 indicando la carpeta en la que se encuentra en este momento. Como cada usuario trabaja mas que nada en su carpeta, Ubuntu le asigna el s\u00edmbolo ~ a esa carpeta para simplificar los directorios que aparecen en la terminal. En nuestro caso ~ equivale a /home/ibioinfo y puede ser que nos refiramos a esa carpeta como su home directory o simplemente su home.</p> <p>Info</p> <p>Aclaraciones por si son fan\u00e1ticos de los atajos de teclado:</p> <ul> <li>Para copiar texto en la terminal hay que usar Ctrl+Shift+C. En en resto de Ubuntu es normal (Ctrl+C).</li> <li>Para pegar texto en la terminal hay que usar Ctrl+Shift+V. En en resto de Ubuntu es normal (Ctrl+V).</li> <li>Al apretar Ctrl+C en la terminal le estan diciendo que corte forzosamente el programa que est\u00e1 corriendo. Si bien hay que tener cuidado con no cortar un proceso importante a la mitad, este atajo del teclado es \u00fatil si un programa se te qued\u00f3 colgado o similar.</li> </ul>","tags":["practicos"]},{"location":"practicos/TP01_Linux/#bash-ubicarse-en-la-terminal","title":"Bash: Ubicarse en la terminal","text":"<p>La terminal acepta una variedad de comandos en lenguaje Bash, que es el lenguaje de la terminal de GNU. El formato general de los comandos es:</p> <pre><code>comando -opciones parametro1 parametro2 etc\n</code></pre> <p>Donde comando es el nombre del programa a correr, opciones son com\u00fanmente una o m\u00e1s letras luego de un gui\u00f3n que indican alguna modificaci\u00f3n a las opciones por defecto del programa, y los diferentes par\u00e1metros son cosas que necesita el programa para correr, como puede ser un archivo que esta leyendo. Todo esto va a ir quedando m\u00e1s claro con los diferentes ejemplos.</p>","tags":["practicos"]},{"location":"practicos/TP01_Linux/#usted-esta-aqui","title":"Usted est\u00e1 aqu\u00ed","text":"<p>Al ser la terminal b\u00e1sicamente un explorador de archivos, es necesario saber en que carpeta estoy y que hay adentro de dicha carpeta. <code>pwd</code> es un comando que imprime el directorio actual en la terminal (P**rint **W**orking **D**irectory). Pruebenlo a ver si **~ era realmente /home/ibioinfo:</p> <p></p><pre><code>pwd\n</code></pre> Bien, ahora que ganamos su confianza, vean que hay adentro de esa carpeta usando <code>ls</code>: <p></p><pre><code>ls\n</code></pre> Si bien por ahora todo lo que ven son carpetas azules, tengan en cuenta que <code>ls</code> va a colorear diferentes tipos de archivos (y de carpetas) de diferentes colores. <p>Este comando es una buena oportunidad de entender un poco mas sobre opciones y par\u00e1metros. Por defecto <code>ls</code> lista los archivos de la carpeta actual, pero de darle un par\u00e1metro muestra los de dicha carpeta. Prueben correr lo siguiente: </p><pre><code>ls /etc/perl/Net\n</code></pre> En este caso est\u00e1n viendo los contenidos de una carpeta diferente a donde estamos parados en la terminal. Si yo quisiera mas informaci\u00f3n sobre los archivos que se encuentran dentro de esta carpeta puedo hacer:  <p>Tip</p> <p>El pr\u00f3ximo comando es muy parecido al anterior. Pueden usar Up y Down en su terminal para navegar por los ultimos comandos utilizados y modificar lo necesario.</p> <pre><code>ls -l /etc/perl/Net\n</code></pre> <p>Donde la opci\u00f3n <code>-l</code> agrega informaci\u00f3n sobre los permisos del archivo (qui\u00e9n puede leerlo o modificarlo). Con un poco de suerte esta es la primera y \u00faltima vez en toda la materia que vamos a hablar de los permisos de Ubuntu (y de como a veces dan dolores de cabeza).</p> <p>Info</p> <p>La lista completa de las opciones para cada comando se puede ver con el comando <code>man</code> (de manual). En este caso ser\u00eda <code>man ls</code>.</p>","tags":["practicos"]},{"location":"practicos/TP01_Linux/#moverse-entre-las-carpetas","title":"Moverse entre las carpetas","text":"<p>Ahora que ya saben d\u00f3nde est\u00e1n y qu\u00e9 carpetas hay adentro es importante saber como moverse entre ellas. Esto se hace principalmente con el comando <code>cd</code>.</p> <p>Aseg\u00farense que la terminal est\u00e1 en su home y usen <code>ls</code> para ver nuevamente la lista de carpetas dentro. Primero vamos a la carpeta Escritorio y vemos que archivos hay adentro, para eso hacer:</p> <p>Tip</p> <p>Tab funciona como autocompletar en la consola. Al escribir el pr\u00f3ximo comando prueben escribir solo cd Es y apretar Tab</p> <pre><code>cd Escritorio\n</code></pre> <p>Ahora ver\u00e1n que la parte de la izquierda de la terminal cambio a:</p> <pre><code>ibioinfo@ibioinfo-VirtualBox:~/Escritorio$\n</code></pre> <p>Indicando que est\u00e1n en /home/ibioinfo/Escritorio. Usen el comando adecuado para ver qu\u00e9 archivos hay adentro de esta carpeta.</p> <p>Si quieren volver a su home y deben escribir:</p> <pre><code>cd ..\n</code></pre> <ul> <li>\u00bfEn qu\u00e9 carpeta est\u00e1n?</li> </ul> <p>En todo lo que es Ubuntu <code>..</code> significa \"una carpeta para arriba\".</p> <p>\u00bfQu\u00e9 pasa entonces si estan en /home/ibioinfo/Escritorio/TP01/Version3/Intento2/Edicion1 y quieren volver a su home? \u00bfTienen que escribir <code>cd ..</code> 5 veces?</p> <p>T\u00e9cnicamente funciona, pero por defecto el comando <code>cd</code> te lleva a tu home si no le das ningun par\u00e1metro.</p> <pre><code>cd\n</code></pre>","tags":["practicos"]},{"location":"practicos/TP01_Linux/#paths-relativos-y-absolutos","title":"Paths relativos y absolutos","text":"<p>Cuando corrimos <code>ls /etc/perl/Net</code> estaban ubicados en su home (/home/ibioinfo) y si vemos las carpetas dentro de home resulta que no existe ninguna llamada /etc.</p> <ul> <li>\u00bfD\u00f3nde est\u00e1 la carpeta /etc en relaci\u00f3n a /home/ibioinfo? (ver Estructura de directorio de Ubuntu arriba si no se acuerdan)</li> <li>\u00bfC\u00f3mo pudimos acceder a /etc/perl/Net si la terminal estaba ubicada en una carpeta sin ninguna relaci\u00f3n?</li> </ul> <p>La respuesta a todo esto son los paths relativos y absolutos:</p>","tags":["practicos"]},{"location":"practicos/TP01_Linux/#paths-absolutos","title":"Paths absolutos","text":"<p>El path /etc/perl/Net es lo que se llama un path absoluto; no importa donde est\u00e9n en la terminal en ese momento, /etc/perl/Net va a siempre apuntar al mismo lugar y el comando <code>ls /etc/perl/Net</code> va a siempre andar bien.</p> <p>Una forma f\u00e1cil de identificar paths absolutos es que siempre empiezan en el root o /.</p> <p>Recuerden que ~ apunta a /home/ibioinfo, y por lo tanto el comando <code>cd ~/Escritorio</code> est\u00e1 usando un path absoluto, ya que sin importar de donde se use va a funcionar y va a ir a /home/ibioinfo/Escritorio.</p>","tags":["practicos"]},{"location":"practicos/TP01_Linux/#paths-relativos","title":"Paths relativos","text":"<p>Ahora bien, cuando nosotros estabamos ubicados en home y corrimos <code>cd Escritorio</code> pudimos entrar a /home/ibioinfo/Escritorio, pero si volvi\u00e9ramos a correr <code>cd Escritorio</code> el comando no funcionar\u00eda, ya que no existe la carpeta /home/ibioinfo/Escritorio/Escritorio.</p> <p>Esto se debe a que en este caso Escritorio es un path relativo a la ubicaci\u00f3n actual de la terminal.</p> <p>Otra forma de escribir paths relativos en Ubuntu es empezar con <code>.</code>, simbolo que indica \"la carpeta actual\". Volviendo al ejemplo anterior, es equivalente escribir <code>cd Escritorio</code> o <code>cd ./Escritorio</code>.</p> <p>Otro caso de path relativo que ya vimos es <code>cd ..</code>, donde apunta a la \"carpeta de arriba\" de la posici\u00f3n actual de la terminal.</p> <p></p> <p>Ambos tipos de paths tienen sus ventajas y desventajas.</p> <p>Los paths absolutos tienen la ventaja de funcionar siempre, pero al usar toda la estructura toman m\u00e1s tiempo de escribir y son m\u00e1s suceptibles a cambios de directorios (si muevo un archivo de lugar tengo que reescribir el comando).</p> <p>Por otro lado, los paths relativos son mucho m\u00e1s r\u00e1pidos de escribir y en muchos casos funcionan en diferentes ubicaciones (o computadoras), pero al depender de la ubicaci\u00f3n de la terminal esto puede causar problemas si pienso que estoy en una carpeta pero estoy realmente en otra. En esta cursada vamos a usar ambos para diferentes casos.</p>","tags":["practicos"]},{"location":"practicos/TP01_Linux/#ejercicio-1-ubicarse-en-la-terminal","title":"Ejercicio 1. Ubicarse en la terminal","text":"<ol> <li> <p>Identifique cu\u00e1l o cu\u00e1les de los siguientes comandos te llevar\u00edan desde cualquier carpeta al home del usuario ibioinfo.</p> <ol> <li><code>cd ~</code></li> <li><code>cd home/ibioinfo</code></li> <li><code>cd home / ibioinfo</code></li> <li><code>cd / home / ibioinfo</code></li> <li><code>cd /home/ibioinfo</code></li> <li><code>cd /ibioinfo/home</code></li> <li><code>cd ././ibioinfo</code></li> <li><code>cd ./home/ibioinfo</code></li> </ol> </li> <li> <p>\u00bfCambiar\u00edan la respuesta en algunos de los puntos anteriores si el usuario logueado actualmente en la computadora no es ibioinfo? \u00bfPor qu\u00e9?</p> </li> <li> <p>Identifique en la siguiente lista cuales paths son paths relativos:</p> <ol> <li><code>/var/temp/tom_jerry</code></li> <li><code>var/temp/tom_jerry</code></li> <li><code>/home/tom/Documentos/catfood.png</code></li> <li><code>../../jerry/Documentos/cheese.png</code></li> <li><code>./Videos/Capitulos/</code></li> <li><code>~/Videos/Capitulos/</code></li> <li><code>./Descargas/tom_jerry_cap1.torrent</code></li> <li><code>/home/tom/Descargas/tom_jerry_cap1.torrent</code></li> </ol> </li> </ol>","tags":["practicos"]},{"location":"practicos/TP01_Linux/#bash-crear-y-eliminar","title":"Bash: Crear y eliminar","text":"<p>Todo lo que es crear, copiar, mover y eliminar archivos y directorios se puede hacer usando la interfaz gr\u00e1fica como lo har\u00edan en cualquier otro sistema operativo, sin embargo hay situaciones (por ejemplo dentro de un script) donde es necesario hacerlo mediante la consola. Si bien por ahora les vamos a pedir que usen los siguientes comandos para practicarlos, en el d\u00eda a d\u00eda hagan lo que les sea m\u00e1s c\u00f3modo.</p>","tags":["practicos"]},{"location":"practicos/TP01_Linux/#crear-y-eliminar-directorios","title":"Crear y eliminar directorios","text":"<p>Los directorios se pueden crear con:</p> <pre><code>mkdir FOLDER\n</code></pre> <p>Info</p> <p>En el resto de la gu\u00eda van a aparecer ciertas palabras en may\u00fascula en los c\u00f3digos, como por ejemplo FOLDER. Estas palabras son variables o placeholders que tienen que ser reemplazadas por lo que corresponda.</p> <p>Donde FOLDER es un path absoluto o relativo con el nombre de la carpeta. Prueben ir en su terminal a /home/ibioinfo/Documentos y usar el comando: </p><pre><code>mkdir testfolder\n</code></pre> <p>Y vean si efectivamente apareci\u00f3 una carpeta nueva. Luego usen el comando de nuevo a ver que pasa.</p> <p>Para eliminar directorios se puede usar:</p> <pre><code>rmdir FOLDER\n</code></pre> <p>Por defecto este comando s\u00f3lo puede eliminar directorios vac\u00edos (lo cual puede no ser muy \u00fatil, pero a la vez es seguro).</p> <p>Usen el comando anterior y borren la carpeta que acaban de crear (reemplacen FOLDER por lo que corresponda). Prueben correr el comando una vez m\u00e1s a ver que pasa.</p> <p>Tip muy importante</p> <p>Este es un buen momento para hablar de que nombres ponerles a las cosas que uno crea un Ubuntu. Si bien cualquier nombre funciona en un principio, por un tema de compatibilidad entre los diferentes programas que pueden llegar a usar se recomienda:</p> <ul> <li>Muy recomendado: No usar comillas dobles, simples o ap\u00f3strofes</li> <li>Recomendado: No usar espacios, par\u00e9ntesis, \u00d1, acentos, di\u00e9resis u otros diacr\u00edticos (el espacio com\u00fanmente se remplaza por un gui\u00f3n o gui\u00f3n bajo)</li> </ul>","tags":["practicos"]},{"location":"practicos/TP01_Linux/#crear-y-eliminar-archivos","title":"Crear y eliminar archivos","text":"<p>Hay varias formas de crear archivos en Ubuntu y la mas simple es <code>touch ARCHIVO</code>, que crea un archivo de texto vacio donde ARCHIVO es el nombre del archivo (que puede incluir un path antes).</p> <ul> <li>Para entender lo que quiero decir vayan a su home y corran:</li> </ul> <p></p><pre><code>touch Documentos/testfile\n</code></pre> En este caso, est\u00e1n usando un path relativo para crear el archivo.  <p>Noten que el archivo que crearon no tiene extensi\u00f3n (por ejemplo .txt). En Ubuntu van a ver muchos archivos de texto sin extensi\u00f3n, pero se la pueden agregar sin problema si quieren. Entren a Documentos y vean si el archivo realmente existe.</p> <p>Lo que le vamos a ense\u00f1ar a continuaci\u00f3n es probablemente uno de los comandos m\u00e1s peligrosos de Bash si se usa incorrectamente.</p> <p><code>rm</code> es el comando usado para eliminar archivos (o carpetas, o discos enteros) y es la base de cientos de historias en internet de como alguien se qued\u00f3 sin trabajo. El comando se usa:</p> <pre><code>rm ARCHIVO\n</code></pre> <p>Donde ARCHIVO es el archivo a eliminar. <code>rm</code> no les va a pedir confirmaci\u00f3n y el archivo va a ser borrado permanentemente (si borran archivos desde la interfaz gr\u00e1fica s\u00ed hay confirmaci\u00f3n y s\u00ed van a la papelera). </p> <ul> <li>Con cuidado, aseg\u00farense que est\u00e1n en Documentos y borren el archivo testfile.</li> </ul> <p>Danger</p> <p>\u00bfSe entendi\u00f3 que hay que tener cuidado con <code>rm</code>? \u00bfSi? Buen\u00edsimo!</p>","tags":["practicos"]},{"location":"practicos/TP01_Linux/#mover-y-copiar-archivos-y-carpetas","title":"Mover y copiar archivos y carpetas","text":"<p>Adentro de Documentos creen una carpeta llamada testfolder2 y dos archivos de texto vac\u00edo, uno llamado testfile_mv y otro testfile_cp.</p> <p>Nuestro objetivo va a ser mover testfile_mv a la carpeta testfolder2 y copiar testfile_cp a la misma carpeta.</p> <p>Los archivos se mueven con <code>mv</code> y se copian con <code>cp</code> y ambos tienen un formato similar que es</p> <pre><code>mv ARCHIVO_ORIGEN FOLDER_DESTINO\n</code></pre> <p>Donde en este caso ARCHIVO_ORIGEN es el archivo a mover y FOLDER_DESTINO el path a donde moverlo.</p> <ul> <li>Prueben mover testfile_mv y copiar testfile_cp adentro de la carpeta testfolder2.</li> </ul> <p>Tip</p> <p>Usando la opci\u00f3n <code>-i</code> al comando, les va a pedir confirmaci\u00f3n si el archivo de destino ya existe. Recuerden que pueden usar <code>man mv</code> (<code>mv --help</code>) o <code>man cp</code> (<code>cp --help</code>) para ver m\u00e1s opciones.</p> <p>Estos dos comandos tambi\u00e9n pueden ser usados como:</p> <pre><code>mv ARCHIVO_ORIGEN ARCHIVO_DESTINO\n</code></pre> <p>En este caso ARCHIVO_DESTINO no es una carpeta, sino un archivo adentro del FOLDER_DESTINO, lo que permite renombrar el ARCHIVO_ORIGEN al copiarlo / moverlo.</p> <ul> <li>Para que se entienda mejor este uso, ub\u00edquense en Documentos y corran:</li> </ul> <pre><code>cp testfile_cp testfolder2/testfile_cp_nuevo\n</code></pre> <p>Con este comando copiaron testfile_cp de nuevo a la carpeta testfolder2, pero ahora con otro nombre. Interesantemente, usar <code>mv</code> de esta manera es la forma de Ubuntu de renombrar archivos desde la terminal.</p> <ul> <li>Prueben entrar a testfolder2 y corran:</li> </ul> <pre><code>mv testfile_cp_nuevo testfile_cp_otroNombre\n</code></pre> <ul> <li> <p>\u00bfQu\u00e9 pas\u00f3?</p> </li> <li> <p>Si todo sali\u00f3 bien, usen <code>rm</code> para eliminar todos los testfile uno a uno y luego usen <code>rmdir</code> para eliminar testfolder2.</p> </li> </ul> <p>Ambos comandos funcionan tambi\u00e9n para copiar, mover y renombrar carpetas, en cuyo caso el formato es:</p> <pre><code>mv FOLDER_ORIGEN FOLDER_DESTINO\n</code></pre> <p>Danger</p> <p>Hay que ser cuidadosos al usar <code>mv</code> y <code>cp</code> ya que si el archivo de destino ya existe lo van a sobreescribir sin preguntar antes.</p> <p>A ambos comandos se le puede agregar la opci\u00f3n <code>-i</code> para que pida confirmaci\u00f3n antes de sobreescribir si ya existiera el archivo de destino.</p>","tags":["practicos"]},{"location":"practicos/TP01_Linux/#bash-archivos-de-texto","title":"Bash: Archivos de texto","text":"","tags":["practicos"]},{"location":"practicos/TP01_Linux/#escribir-archivos-de-texto","title":"Escribir archivos de texto","text":"<p>En Ubuntu hay varias formas de escribir en archivos de texto, pero una de las m\u00e1s \u00fatiles para nosotros va a ser el <code>&gt;</code> que redirige la salida de informaci\u00f3n de la consola. Se usa:</p> <pre><code>comando -opciones parametro1 parametro2 &gt; ARCHIVO_DESTINO\n</code></pre> <p>Donde lo de la izquierda de <code>&gt;</code> es el comando como lo correr\u00edas normalmente y ARCHIVO_DESTINO es un archivo donde va a ser guardada la salida de ese comando (lo que normalmente ver\u00edan en la consola).</p> <ul> <li>Para entender un poco m\u00e1s, vayan a su home y corran:</li> </ul> <pre><code>ls -l &gt; Documentos/output_de_ls\n</code></pre> <p>Ver\u00e1n que en un principio parece que no paso nada.</p> <ul> <li>Entren ahora a Documentos y van a ver que hay un nuevo archivo con el nombre output_de_ls.</li> </ul> <p>Vamos a abir el archivo usando el Text Editor, el editor de texto de la interfaz \u01f5r\u00e1fica de Ubuntu.</p> <ul> <li>Asegur\u00e1ndose que est\u00e1n en Documentos, y si est\u00e1n en la terminal local en la consola escriban:</li> </ul> <pre><code>gedit output_de_ls\n</code></pre> <p>Van a ver que se abre el editor de texto de igual forma que si ubieran hecho doble click en el \u00edcono en el explorador de archivos de la GUI. Puede ser que aparezca un warning o advertencia en la consola, pero la podemos ignorar.</p> <ul> <li>Si est\u00e1n trabajando en replit abran el archivo haciendo click en el nombre del archivo en la barra lateral izquierda.</li> </ul> <p>Tanto en gedit como en el replit, agreguen una nueva l\u00ednea abajo de todo (con cualquier texto) y guarden el archivo (en el caso de replit se guarda autom\u00e1ticamente).</p> <p>Ya sabemos como guardar en un archivo de texto cualquier salida de un comando de Ubuntu! pero... \u00bfc\u00f3mo hacemos para poner lo que nosotros queremos en un archivo de texto? Simple, \u00a1con otro comando de Ubuntu!</p> <p>El comando <code>echo</code> hace lo que su nombre indica y devuelve por la terminal el texto que le pases.</p> <ul> <li>Prueben escribir <code>echo TEXTO</code>, donde TEXTO es cualquier oraci\u00f3n, por ejemplo:</li> </ul> <pre><code>echo Probando, uno, dos, tres\n</code></pre> <p>Tal vez ya se dieron cuenta, pero combinando <code>echo</code> con <code>&gt;</code> podemos escribir nuestros propios archivos de texto desde la terminal. </p> <ul> <li>Asegur\u00e1ndose que est\u00e1n adentro de Documentos, corran:</li> </ul> <pre><code>echo Esta es la primera l\u00ednea del documento &gt; mi_documento\n</code></pre> <ul> <li> <p>Confirmen que se escribi\u00f3 el archivo y que tiene el texto adentro.</p> </li> <li> <p>\u00bfQu\u00e9 piensan que pasa si ahora corro el siguiente comando? </p> </li> </ul> <pre><code>echo Quiero agregar otra linea al documento &gt; mi_documento\n</code></pre> <ul> <li>Abran el documento <code>mi_documento</code>.</li> </ul> <p>La primera l\u00ednea que agregamos desapareci\u00f3. Esto es porque cada uso de <code>&gt;</code> sobreescribe el archivo. Si queremos agregar otra l\u00ednea a un documento que ya tiene informaci\u00f3n tenemos que usar el comando <code>&gt;&gt;</code> que agrega el texto al archivo en una nueva l\u00ednea al final sin modificar el contenido anterior. </p> <ul> <li>As\u00ed que ahora que sabemos esto podemos correr estos dos comandos:</li> </ul> <pre><code>echo Esta es la primera linea del documento &gt; mi_documento\necho Esta es la segunda linea del documento &gt;&gt; mi_documento\n</code></pre> <ul> <li>Abran el archivo y vean si funcion\u00f3 como quer\u00edamos.</li> </ul> <p>Danger</p> <p>Hay que ser cuidadosos al usar <code>&gt;</code> ya que si el archivo de destino ya existe lo va a sobreescribir sin preguntar antes.</p>","tags":["practicos"]},{"location":"practicos/TP01_Linux/#leer-archivos-de-texto","title":"Leer archivos de texto","text":"<p>Qu\u00e9 comando usar al leer archivos de texto en la consola depende mucho de que tan largo es el archivo y que me interesa de \u00e9l:</p> <ul> <li> <p>\u00bfTiene solo pocas lineas de texto?</p> <p><code>cat</code> va a abrir el archivo e imprimirlo en la terminal.</p> </li> <li> <p>\u00bfTiene muchas l\u00edneas de texto y quiero ver las primeras p\u00e1ginas a ver de que se trata?</p> <p><code>less</code> va a abrir el archivo y mostrar solo el texto que entra en la terminal. Aprentando Space pasa a la pr\u00f3xima p\u00e1gina y apretando Q deja de leerlo.</p> </li> <li> <p>\u00bfTiene muchas l\u00edneas de texto y quiero ver solo las primeras l\u00edneas?</p> <p><code>head</code> te muestra las primeras 10 l\u00edneas del archivo. Se puede especificar la cantidad de l\u00edneas agregando una opci\u00f3n, por ejemplo, <code>head -3</code> muestra solo las primeras 3 l\u00edneas.</p> </li> <li> <p>\u00bfTiene muchas l\u00edneas de texto y quiero ver solo las \u00faltimas l\u00edneas?</p> <p><code>tail</code> te muestra las \u00faltimas 10 l\u00edneas del archivo. Este n\u00famero se puede cambiar de la misma forma que para <code>head</code>.</p> </li> <li> <p>\u00bfNo saben qu\u00e9 tan largo es un archivo dado?</p> <p>Pueden averiguarlo con el comando <code>wc</code>, que devuelve el n\u00famero de l\u00edneas, palabras y letras (en ese orden) en el archivo. De pasarle la opci\u00f3n <code>-l</code>, el comando devuelve solo el n\u00famero de l\u00edneas.</p> </li> </ul> <p>Todos estos funcionan de la forma:</p> <pre><code>comando ARCHIVO\n</code></pre> <p>Usando el archivo martin_fierro que se encuentra en los materiales del TP (bot\u00f3n al principio de todo), prueben los 5 comandos anteriores.</p>","tags":["practicos"]},{"location":"practicos/TP01_Linux/#buscar-palabras-en-archivos-de-texto","title":"Buscar palabras en archivos de texto","text":"<p>Va a ser com\u00fan cuando trabajemos con tablas que nos interese encontrar filas con cierto valor y una forma r\u00e1pida de hacer eso es usar <code>grep</code>, comando al que le pasas una palabra o patr\u00f3n y busca filas dentro de un archivo que contengan dicha palabra o patr\u00f3n. </p> <p>En formato general el comando es:</p> <pre><code>grep PALABRA ARCHIVO\n</code></pre> <p>Usando el archivo martin_fierro con el que trabajamos en la secci\u00f3n anterior podemos correr:</p> <pre><code>grep cantar martin_fierro\n</code></pre> <p>Y vamos a ver todas las l\u00edneas del documento donde aparece la palabra \"cantar\". Hay mucho para hablar sobre <code>grep</code>, pero por ahora lo que nos va a importar es:</p> <ul> <li>La opci\u00f3n <code>-v</code> devuelve las l\u00edneas que no contienen PALABRA</li> <li>La opci\u00f3n <code>-c</code> devuelve el n\u00famero de l\u00edneas que contienen PALABRA</li> <li>Es posible pasarle varias opciones a un programa. De hacer <code>grep -v -c</code> voy a estar contando el n\u00famero de l\u00edneas que no contengan PALABRA (el orden de las opciones no afecta el comportamiento)</li> </ul> <p>Info</p> <p><code>grep</code> tambi\u00e9n funciona con patrones, quienes son conocidos como Expresiones Regulares, o RegEx. Este tema es complejo y ya tenemos bastante que procesar, por lo tanto, no vamos a profundizar m\u00e1s sobre ellos en este momento. Pero... explicaremos cualquier patr\u00f3n o expresi\u00f3n regular que usemos en la materia cuando aparezca.</p>","tags":["practicos"]},{"location":"practicos/TP01_Linux/#combinar-comandos","title":"Combinar comandos","text":"<p>En Bash es posible combinar comandos, lo que quiere decir pasarle la salida de un comando directamente como entrada a otro comando. Esto se hace dividiendo los diferentes comandos con | (o pipe).</p> <p>Para entender un poco mejor veamos un ejemplo.</p> <p>Digamos que quiero ver cu\u00e1les de las primeras 10 l\u00edneas del archivo martin_fierro contienen la palabra cantar. Para esto tengo que hacer:</p> <pre><code>head -20 martin_fierro | grep cantar\n</code></pre> <p>Fijense que en este caso parecer\u00eda que a <code>grep</code> no le estoy pasando ningun ARCHIVO. <code>grep</code> usa como entrada la salida de <code>head</code>. De esta forma se puede concatenar cualquier n\u00famero de comandos que ser\u00e1n ejecutados de izquierda a derecha.</p>","tags":["practicos"]},{"location":"practicos/TP01_Linux/#ejercicio-2-archivos-de-texto","title":"Ejercicio 2. Archivos de texto","text":"<p>Para este ejercicio vamos a seguir usando el archivo martin_fierro. </p> <ol> <li> <p>\u00bfCu\u00e1ntas l\u00edneas tiene el archivo?</p> </li> <li> <p>\u00bfCu\u00e1ntas l\u00edneas contienen la palabra \"cantar\"?</p> </li> <li> <p>\u00bfCu\u00e1ntas l\u00edneas no contienen la palabra \"guitarra\"?</p> </li> <li> <p>Cree otro archivo de texto llamado martin_fierro_sinA con las l\u00edneas del archivo martin_fierro que no tengan la letra \"a\".</p> </li> <li> <p>Sin borrar el contenido y usando la consola, agregue una l\u00ednea al final de martin_fierro_sinA que indique el autor del Martin Fierro (Jos\u00e9 Hern\u00e1ndez).</p> </li> <li> <p>Volviendo al archivo original, \u00bfcu\u00e1ntas l\u00edneas no contienen la letra \"o\" y s\u00ed contienen la letra \"i\"? (Tip: use <code>|</code> para encadenar comandos)</p> </li> </ol>","tags":["practicos"]},{"location":"practicos/TP01_Linux/#bash-programacion-y-scripts","title":"Bash: Programaci\u00f3n y Scripts","text":"<p>Info</p> <p>A continuaci\u00f3n vamos a ver una peque\u00f1a introducci\u00f3n a la programaci\u00f3n usando Bash como lenguaje. El objetivo de lo que sigue no es aprenderse de memoria las estructuras y si hay que poner una llave aca o dejar un espacio all\u00e1, sino entender la l\u00f3gica detr\u00e1s de la programaci\u00f3n y como se pueden usar variables, condicionales y ciclos para obtener el resultado deseado.</p>","tags":["practicos"]},{"location":"practicos/TP01_Linux/#scripts","title":"Scripts","text":"<p>Los scripts de Bash son b\u00e1sicamente una lista de muchos de los comandos que nosotros corrimos en la terminal, pero escritos dentro de un archivo. Al ejecutar ese archivo todos los comandos escritos en \u00e9l ser\u00e1n corridos uno a uno de arriba a abajo.</p> <p>Para simplificar un poco la tarea y enfocarnos en lo que importa en esta secci\u00f3n, vamos a utilizar la interfaz gr\u00e1fica de Ubuntu. </p> <ul> <li> <p>Vayan a Documentos y creen un archivo llamado primer_programa.sh</p> <ul> <li>En la computadora local: Bot\u00f3n derecho  Crear nuevo...  Archivo vac\u00edo.</li> <li>En replit: Bot\u00f3n derecho en la barra lateral izquierda  New File  Escribir el nombre del archivo.</li> </ul> </li> </ul> <p>Luego, abran el archivo en el Text Editor (doble click) y escriban lo siguiente:</p> <pre><code>echo \"----------------\"\necho \"| Hello world! |\"\necho \"----------------\"\n</code></pre> <ul> <li>Guarden el archivo, muevanse en la terminal/consola a la carpeta donde est\u00e1 el script y lo ejecutan con:</li> </ul> <pre><code>bash primer_programa.sh\n</code></pre> <p>\u00a1Felicidades, ya pueden decir que son programadores!</p> <p>Como pudieron observar, los scripts de Bash se corren con el comando <code>bash SCRIPT</code> y al hacerlo se ejecutaron los 3 comandos <code>echo</code> en el orden que estaban dentro del script. Este tipo de scripts son \u00fatiles si quiero dejar evidencia de los comandos que corr\u00ed en Bash, ya sea para volver a hacerlo otro d\u00eda o para pasarselos a alguien m\u00e1s y que los corra en su propia computadora; sin embargo, para realmente programar necesitamos m\u00e1s herramientas.</p>","tags":["practicos"]},{"location":"practicos/TP01_Linux/#variables","title":"Variables","text":"<p>Las variables son palabras que guardan dentro de ellas un n\u00famero o un string (texto), entre otro tipo de valores posibles que veremos m\u00e1s adelante. Veamos un ejemplo de como usar variables (vean ambas pesta\u00f1as):</p> C\u00f3digoC\u00f3digo con comentarios <pre><code>nombre=\"Unsamer\" \n\necho \"Hola $nombre, \u00bftodo bien?\"\n</code></pre> <pre><code># Las lineas que empiezan con # son comentarios, no afectan el c\u00f3digo y sirven para aclarar que estas \n# haciendo en tu programa o script\n\n# Al declarar una variable en Bash no se puede poner espacio entre la variable, el = y el valor\n# Las comillas se usan para indicar que lo de adentro es una cadena de caracteres, o *string*\nnombre=\"Unsamer\" \n\n# Cuando se usa la variable, se le agrega el prefijo $\necho \"Hola $nombre, \u00bftodo bien?\"\n</code></pre> <ul> <li>\u00bfQu\u00e9 piensan que va a pasar de correr este c\u00f3digo en un script? Pruebenlo.</li> </ul> <p>Info</p> <p>Desgraciadamente Bash es muy estricto al momento de programar y perdona bastante poco (como por ejemplo el tema de tener un espacio m\u00e1s o menos). M\u00e1s adelante vamos a usar el lenguaje R que va a ser una de nuestras principales herramientas al momento de analizar y graficar datos y es mucho m\u00e1s amigable.</p> <p>En este momento pueden estar pensando que hubiera sido mucho m\u00e1s f\u00e1cil poner solo <code>echo \"Hola Unsamer, \u00bftodo bien?\"</code> y ahorrarme el tema de la variable. Tienen raz\u00f3n. Por ahora.</p> <p>\u00bfSe acuerdan de los par\u00e1metros de los comandos de Bash? Al pasarle par\u00e1metros a un script de Bash estos se asignan automaticamente a variables llamadas <code>$1</code>, <code>$2</code>, etc. Editemos ahora nuestro c\u00f3digo anterior:</p> C\u00f3digoC\u00f3digo con comentarios <pre><code>nombre=$1\n\necho \"Hola $nombre, \u00bftodo bien?\"\n</code></pre> <pre><code># $1 es el primer par\u00e1metro que se le pasa al script de Bash\n# Le estoy asignando el valor de una variable a otra variable. $1 sigue existiendo, pero no la uso m\u00e1s\nnombre=$1\n\n# Podr\u00eda usar $1 directamente aca, pero as\u00ed se entiende mucho m\u00e1s lo que hace el c\u00f3digo al leerlo\n# (y para programas muy complicados esto es muy importante)\necho \"Hola $nombre, \u00bftodo bien?\"\n</code></pre> <p>Y ahora corran:</p> <pre><code>bash SCRIPT \"NOMBRE\"\n</code></pre> <p>Por si la versi\u00f3n gen\u00e9rica no queda claro, si el script se llamara saludo.sh y quiero conseguir el mismo resultado que antes habr\u00eda que correr:</p> <pre><code>bash saludo.sh \"Unsamer\"\n</code></pre> <p>Info</p> <p>T\u00e9cnicamente si estoy pasando solo una palabra las comillas no son necesarias, pero si el string que estoy pasando tiene un espacio tengo que ponerlas s\u00ed o s\u00ed.</p> <p>Hay bastante m\u00e1s para hablar de las variables. Existen muchos tipos m\u00e1s de variables, como:</p> <ul> <li>booleanos (variable que es verdadera o falsa),</li> <li>arreglos (o vectores)</li> <li>listas.</li> </ul> <p>Otros lenguajes de programaci\u00f3n hasta tienen variables m\u00e1s complejas que pueden almacenar tablas enteras. Sin embargo, lo que acabamos de aprender es la base y va a ser suficiente por ahora. M\u00e1s informaci\u00f3n sobre las variables en Bash se puede ver en esta p\u00e1gina.</p>","tags":["practicos"]},{"location":"practicos/TP01_Linux/#condicionales","title":"Condicionales","text":"<p>Las variables son importantes, pero gran parte de la programaci\u00f3n es controlar el \"flujo\" del programa, es decir, que un script haga algo m\u00e1s que simplemente ir de arriba a abajo ejecutando comandos. La primera herramienta que vamos a aprender para controlar el flujo del programa son los condicionales que permiten crear secciones de c\u00f3digo que se van a ejecutar solo si se cumple (o no se cumple) una condici\u00f3n. Por ejemplo:</p> C\u00f3digoC\u00f3digo con comentarios <pre><code>numero=$1\n\necho \"$numero es un n\u00famero\"\n\nif (($numero &gt; 10))\nthen\n    echo \"$numero es mayor a 10\"\nfi\n</code></pre> <pre><code># Igual que antes estoy agarrando un par\u00e1metro al correr el script\nnumero=$1\n\necho \"$numero es un n\u00famero\"\n\n# *if* es la estructura m\u00e1s usada para condicionales.\n# Adentro de los dobles par\u00e9ntesis va la condici\u00f3n.\n# &gt; es el comparador, o sea, estamos preguntando si $numero es mayor que 10\nif (($numero &gt; 10))\nthen\n    # El codigo entre *then* y *fi* solo si ejecuta si la condici\u00f3n es verdad, de otra forma se saltea\n    # Este codigo esta m\u00e1s a la derecha, o *indentado*. Esto se hace con tab y en la mayor\u00eda de los lenguajes\n    # es solo para entender m\u00e1s f\u00e1cil el c\u00f3digo\n    echo \"$numero es mayor a 10\"\nfi\n# *fi* indica donde termina el condicional\n</code></pre> <ul> <li>Copien este c\u00f3digo a un script y prueben pasarle n\u00fameros menores y mayores a 10 a ver que pasa.</li> </ul> <p>Info</p> <p>Es importante remarcar que la condici\u00f3n del if (lo que en este caso se encuentra entre los corchetes) es b\u00e1sicamente una pregunta que puede tener s\u00f3lo una de dos respuestas posibles: S\u00ed (llamada en programaci\u00f3n Verdadero o True) \u00f3 No (llamada en programaci\u00f3n Falso o False)</p> <p>Recuerden que a un condicional se le puede poner tambi\u00e9n que pase algo cuando no es verdad, por ejemplo:</p> C\u00f3digoC\u00f3digo con comentarios <pre><code>numero=$1\n\necho \"$numero es un n\u00famero\"\n\nif (($numero &gt; 10))\nthen\n    echo \"$numero es mayor a 10\"\nelse\n    echo \"$numero es menor o igual a 10\"\nfi\n</code></pre> <pre><code>numero=$1\n\necho \"$numero es un n\u00famero\"\n\nif (($numero &gt; 10))\nthen\n    # Ahora si la condici\u00f3n es verdad se va a ejecutar el c\u00f3digo entre *then* y *else* y luego va a \n    # seguir a partir de *fi*\n    echo \"$numero es mayor a 10\"\nelse\n    # El c\u00f3digo entre *else* y *fi* se ejecuta solo cuando la condici\u00f3n no es verdad\n    echo \"$numero es menor o igual a 10\"\nfi\n</code></pre> <p>Hay muchos m\u00e1s comparadores para usar con los condicionales if y son diferentes si estoy comparando n\u00fameros o strings. Se puede poner m\u00e1s de una condici\u00f3n por if y hay otras estructuras, como los case, que cumplen una funci\u00f3n similar. Sin embargo, la base que aprendieron hoy es suficiente por ahora.</p> <p>M\u00e1s informaci\u00f3n sobre los condicionales en Bash, incluyendo una lista m\u00e1s detallada de los comparadores, se puede ver en esta p\u00e1gina y en esta p\u00e1gina (en Bash las condiciones pueden estar rodeadas por par\u00e9ntesis o corchetes y en cada caso los comparadores se comportan diferente, ojo con esto).</p>","tags":["practicos"]},{"location":"practicos/TP01_Linux/#ciclos","title":"Ciclos","text":"<p>Si quieren imprimir los n\u00fameros del 1 al 10 en la consola, tendr\u00edan que hacer <code>echo 1</code>, <code>echo 2</code>, etc, hasta llegar a <code>echo 10</code>. \u00bfQu\u00e9 pasa si ahora les pido del 1 al 100, o al 1000?. Por suerte, existen los ciclos.</p> <p>Los ciclos son estructuras que nos permiten repetir algo varias veces y al usar variables podemos hacer que cada vez sea ligeramente diferente a la anterior.</p> C\u00f3digoC\u00f3digo con comentarios <pre><code>for ((i=1;i&lt;=1000;i++))\ndo\n    echo $i\ndone\n</code></pre> <pre><code># *for* es una de las estructuras m\u00e1s usadas para hacer ciclos\n# *i* es el nombre de la variable que va a cambiar de valor en cada ciclo. Se le podria poner cualquier nombre a \n# \u00e9sta variable, por ejemplo *numero* en nuestro caso, pero es costumbre ponele *i*\n# i=1 indica que el primer valor de $i es 1\n# i&lt;=1000 indica que el ciclo se va a repetir mientras $i sea menor o igual a 1000\n# i++ indica que al final de cada ciclo el valor de $i va a subir en 1\nfor ((i=1;i&lt;=1000;i++))\ndo\n    # El c\u00f3digo entre *do* y *done* se va a ejecutar una vez para cada posible $i en el rango\n    echo $i\ndone    \n</code></pre> <p>Hay otra versi\u00f3n del for que comunmente se denomina for each. En este caso <code>$i</code> no representa n\u00fameros que aumentan, sino diferentes elementos en una lista. Por ejemplo:</p> C\u00f3digoC\u00f3digo con comentarios <pre><code>for color in rojo amarillo verde\ndo\n    echo \"Este es el color $color\"\ndone\n</code></pre> <pre><code># Como ahora la variable son elementos de una lista le pongo el nombre *color* para que se sepa que es, \n# pero podr\u00eda ser *i*\n# Esta es una forma bastante mala de usar listas de elementos, donde la estoy declarando en el mismo *for*;\n# comunmente las listas existen de antes en el programa o las obtengo de un archivo o comando de Ubuntu\nfor color in rojo amarillo verde\ndo\n    echo \"Este es el color $color\"\ndone\n</code></pre> <p>Hay otros dos tipos de ciclos com\u00fanmente denominados while y until (tambi\u00e9n llamado do) y hay formas de forzar salir del ciclo o pasar a la pr\u00f3xima iteraci\u00f3n con break y continue (tambien llamado next).</p> <p>Nuevamente, la base aprendida ser\u00e1 suficiente por ahora. M\u00e1s informaci\u00f3n sobre los ciclos en Bash se puede ver en esta p\u00e1gina.</p>","tags":["practicos"]},{"location":"practicos/TP01_Linux/#ejercicio-3-programacion-en-bash","title":"Ejercicio 3. Programaci\u00f3n en Bash","text":"<p>El objetivo de este ejercicio es hacer un script que:</p> <ul> <li>Use por lo menos un for y un if</li> <li>Recorra los n\u00fameros del 1 al 10</li> <li>Por cada uno de esos n\u00fameros cree un archivo llamado archivo_NUMERO, d\u00f3nde hay que reemplazar NUMERO por el n\u00famero correspondiente (de 1 a 10)</li> <li>En los primeros 5 archivos (archivo_1 a archivo_5) escriba el texto:     <pre><code>Primera parte. Este es el archivo NUMERO.\n</code></pre>     Donde hay que reemplazar NUMERO por el n\u00famero correspondiente (de 1 a 5)</li> <li>En los \u00faltimos 5 archivos (archivo_6 a archivo_10) escriba el texto:     <pre><code>Segunda parte.\nEste es el archivo NUMERO.\n</code></pre>     Donde hay que reemplazar NUMERO por el n\u00famero correspondiente (de 6 a 10). Noten que ambas oraciones est\u00e1n en lineas diferentes</li> </ul> <p>Ahora que sabemos nuestro objetivo vayan a Documentos y creen una nueva carpeta donde vamos a trabajar llamada TP01_EJ3. Dentro de ella creen un archivo vac\u00edo llamado crear_archivos.sh que va a ser nuestro script y ed\u00edtenlo.</p> Gu\u00eda para hacer el script <p>Al momento de hacer programas complejos, especialmente en un lenguaje que reci\u00e9n aprenden, es recomendado ir por partes e ir probando en el medio. Unos posibles pasos a seguir son:</p> <p>Info</p> <p>La idea de hacerlo as\u00ed es ir probando de a poco si aparece algun error. \u00a1Prueben el script entre cada paso!</p> <ol> <li> <p>Modifiquen el script para que cree un archivo llamado archivo_1 que adentro tenga el texto: </p> <pre><code>Primera parte. Este es el archivo 1.\n</code></pre> </li> <li> <p>Agreguen un for que vaya de 1 a 5 y cree los archivos archivo_1 a archivo_5 que adentro tengan el texto:</p> <pre><code>Primera parte. Este es el archivo NUMERO.\n</code></pre> <p>Donde hay que reemplazar NUMERO por el n\u00famero correspondiente (de 1 a 5).</p> </li> <li> <p>Expandan el for para que vaya de 1 a 10. Agreguen un if adentro del for que haga que los archivos se creen solo para los primeros 5 ciclos.</p> <p>Tip</p> <p>Aca les puede venir bien el comparador <code>&lt;=</code>, que significa \"menor o igual\". Un ejemplo de <code>&lt;=</code> seria:</p> <pre><code>if (($1 &lt;= 7))\n</code></pre> <p>Que en este caso es verdadero cuando el par\u00e1metro <code>$1</code> es menor o igual a 7.</p> </li> <li> <p>Agreguen un else al if, recordando que los comandos adentro del else se van a ejecutar cuando la condici\u00f3n no sea verdadera. Asumiendo que usaron <code>&lt;=</code> en la condici\u00f3n del if, modifiquen los comandos adentro del else para que en ese caso se creen los archivos archivo_6 a archivo_10 que adentro tengan el texto:</p> <pre><code>Segunda parte.\nEste es el archivo NUMERO.\n</code></pre> <p>Donde hay que reemplazar NUMERO por el n\u00famero correspondiente (de 6 a 10).</p> </li> </ol> <p>\u00a1Y listo, deber\u00edan tener su programa andando!</p>","tags":["practicos"]},{"location":"practicos/TP01_Linux/#ejercicios-adicionales","title":"Ejercicios Adicionales","text":"<p>Info</p> <p>Algunas gu\u00edas van a tener ejercicios adicionales, que son ejercicios que pueden hacer si quieren practicar m\u00e1s el tema, pero no son obligatorios. Estos ejercicios pueden llegar a ser un poco m\u00e1s complicados que los ejercicios de la gu\u00eda.</p>","tags":["practicos"]},{"location":"practicos/TP01_Linux/#ejercicio-adicional-1-bash-tablas","title":"Ejercicio Adicional 1. Bash: Tablas","text":"<p>Lo \u00faltimo que vamos a aprender hoy es un peque\u00f1o vistazo a como se pueden manipular tablas desde la consola de Ubuntu. Descarguen el archivo mtcars que se encuentra en los materiales del TP (boton al principio de todo) y ponganlo en Documentos. Esta tabla viene por defecto con el lenguaje de programaci\u00f3n R y nos va a servir para aprender como manipular tablas en Bash. </p> <p>Abran el archivo. Podemos ver que es una tabla en formato texto, donde la primera l\u00ednea es el encabezado o header de la tabla y en cada l\u00ed\u0144ea las columnas est\u00e1n separadas entre ellas con un Tab (a estos archivos se los conoce como TSV o \"Tab-Separated Values\"). Es bioinform\u00e1tica es muy com\u00fan querer seleccionar columnas espec\u00edficas en una tabla, o filtrar filas debido al valor de una de sus columnas; esto es lo que vamos a aprender a continuaci\u00f3n.</p> Columnas de mtcars <p>mtcars es una tabla que viene por defecto con el lenguaje de programaci\u00f3n R, sus columnas son:</p> Nombre Descripci\u00f3n car_name Name of the car mpg Miles/(US) gallon cyl Number of cylinders disp Displacement (cu.in.) hp Gross horsepower drat Rear axle ratio wt Weight (1000 lbs) qsec \u00bc mile time vs Engine (0 = V-shaped, 1 = straight) am Transmission (0 = automatic, 1 = manual) gear Number of forward gears carb Number of carburetors","tags":["practicos"]},{"location":"practicos/TP01_Linux/#awk","title":"AWK","text":"<p>El comando <code>awk</code>  (que recibe su nombre de las iniciales de los apellidos de las 3 personas que lo crearon) es uno de los comandos mas usados en Bash para manipular tablas por su gran flexibilidad, hasta el punto que es posible incorporar condicionales y ciclos dentro de \u00e9l. La forma m\u00e1s simple del comando es:</p> <pre><code>awk -opciones 'instrucciones' ARCHIVO_TABLA\n</code></pre> <p>Donde ARCHIVO_TABLA es el archivo que contiene a la tabla e instrucciones es que hacer con ese archivo una vez que se abra (las instrucciones siempre tienen que estar delimitadas por comillas simples, o <code>'</code>). Colocando a nuestra terminal en Documentos podemos correr:</p> <pre><code>awk -F \"\\t\" '{print}' mtcars\n</code></pre> <p>Donde <code>-F</code> es la opci\u00f3n que le dice a <code>awk</code> que caracter separa las diferentes columnas (en este caso es <code>\\t</code>, que es el s\u00edmbolo de Tab) y <code>{print}</code> es la instrucci\u00f3n que simplemente dice que imprima en pantalla la tabla.</p> <p>Lo importante de <code>awk</code> es que nos permite trabajar con columnas individuales. Por ejemplo si ponemos:</p> <pre><code>awk -F \"\\t\" '{print $1}' mtcars\n</code></pre> <p>Vemos que <code>awk</code> imprime solo la primera columna, que en este caso es el nombre de los autos. Podemos asumir entonces que cada columna se puede referir con <code>$1</code>, <code>$2</code>, etc. Probemos imprimir muchas columnas corriendo:</p> <pre><code>awk -F \"\\t\" '{print $1 $3 $5}' mtcars\n</code></pre> <ul> <li>\u00bfQu\u00e9 ven que pasa ac\u00e1?</li> </ul> <p>Debido a como funciona <code>print</code>, las diferentes columnas se imprimeron una pegada a la otra sin dejar espacios. Si quisi\u00e9ramos imprimir las columnas separadas con Tab como la tabla original tenemos que hacer:</p> <pre><code>awk -F \"\\t\" '{print $1 \"\\t\" $3 \"\\t\" $5}' mtcars\n</code></pre> <p>Una tarea com\u00fan cuando se tienen tablas con muchos datos es filtrar los datos por alguna columna, o dicho de otra forma, usar condicionales. Un ejemplo de esto en <code>awk</code> ser\u00eda:</p> <pre><code>awk -F \"\\t\" '{if ($3 == 6) {print}}' mtcars\n</code></pre> <ul> <li>\u00bfQu\u00e9 les parece que hace ese comando? Piensen que estan viendo una estructura de if que no vieron antes, pero a\u00fan as\u00ed probablemente puedan inferir que va a hacer el comando pensando en como funcionaba el if de Bash que aprendimos arriba. Esto es super normal en la programaci\u00f3n, donde la estructura exacta cambia, pero la l\u00f3gica detr\u00e1s se mantiene constante.</li> </ul> <p>Entonces, ac\u00e1 le dicen a <code>awk</code> que imprima en la pantalla todas las filas que tengan un valor de 6 en la columna 3 (que si se fijan es cyl, o el n\u00famero de cilindros).</p> <p><code>awk</code> tiene su propio <code>grep</code> y su propio for, que se pueden declarar variables dentro de \u00e9l y que tiene hasta una lista de comandos propios. Pueden ver mucha m\u00e1s informaci\u00f3n de <code>awk</code> en esta p\u00e1gina.</p>","tags":["practicos"]},{"location":"practicos/TP01_Linux/#ejercicio-adicional-2-programacion-en-bash-v2","title":"Ejercicio Adicional 2. Programaci\u00f3n en Bash v2","text":"<p>El objetivo de este Ejercicio va a ser hacer un script que:</p> <ul> <li>Reciba un n\u00famero por consola (vamos a asumir que dicho n\u00famero va a ser siempre un n\u00famero entero entre 1 y 1000) es decir que el usuario ingrese como par\u00e1metro del script un n\u00famero.</li> <li>Recorra todos los n\u00fameros entre 1 y el n\u00famero que recibi\u00f3 por consola</li> <li>Para cada uno de esos n\u00fameros vea si es par</li> <li>Imprima los n\u00fameros pares por consola</li> </ul> <p>Dos cosas que van a necesitar para hacer esto son:</p> <pre><code># El operador % calcula el resto entre 2 n\u00fameros\n# En este caso $resto va a contener el resto de dividir 5 por 2 (que es 1)\n# Una forma muy usada en programac\u00edon para ver si un n\u00famero es par es ver si su resto al dividirlo por 2 es 0\n# Los par\u00e9ntesis y signo $ bordeando a la operaci\u00f3n son necesarios para que funcione bien en Bash\nresto=$((5 % 2)) \n\n# == es el comparador para igualdad usado en los *ifs*\n# Va a ser verdadero solo si lo de la izquierda es identico a lo de la derecha.\nif (($1 == 2))\n</code></pre> <p>Para hacer este ejercicio pueden usar como base el c\u00f3digo creado en el Ejercicio 3 que ambos tienen una estructura general bastante similar.</p>","tags":["practicos"]},{"location":"practicos/TP01_Linux/#bibliografia","title":"Bibliograf\u00eda","text":"","tags":["practicos"]},{"location":"practicos/TP01_Linux/#consola","title":"Consola","text":"<ul> <li>Comando <code>man</code></li> </ul>","tags":["practicos"]},{"location":"practicos/TP01_Linux/88_BU/","title":"Index","text":""},{"location":"practicos/TP01_Linux/88_BU/#tp1-titulo-del-trabajo-practico","title":"TP1. Titulo del Trabajo Pr\u00e1ctico","text":"<p> Materiales</p> <p></p>"},{"location":"practicos/TP01_Linux/88_BU/#software-a-usar","title":"Software a usar","text":"<ul> <li>Programa 1 www.donde.lo.bajo.com</li> <li>Programa 2 www.donde.lo.bajo2.com</li> </ul>"},{"location":"practicos/TP01_Linux/88_BU/#recursos-online","title":"Recursos Online","text":"<ul> <li>Recurso 1 www.webAusar.com</li> <li>Recurso 2 www.webAusar.com</li> </ul>"},{"location":"practicos/TP01_Linux/88_BU/#objetivos","title":"Objetivos","text":""},{"location":"practicos/TP01_Linux/88_BU/#introduccion-al-tema","title":"Introduccion al Tema","text":"<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non onsequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p></p> <p>Existen distintos de Admonitions</p> <p>Atenci\u00f3n esto es un admonition!!</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Admonition desplegable (Esto est\u00e1 bueno para ver las soluciones a las cosas o tipo los ayuda memoria, c\u00f3digo de amino\u00e1cidos de una letra, etc)</p> Atenci\u00f3n !! Sin desplegar <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Definici\u00f3n de Inline</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Esto en teor\u00eda ser\u00eda para que me entre ac\u00e1 y me quede a la izquierda LO QUE EST\u00c1 PUESTO ARRIBA ladito Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p> </p> <p>Todos los tipos disponibles ac\u00e1</p> <p>Todo lo que sea c\u00f3digo y se muestre la soluci\u00f3n se recomienda usar las tabs</p> C\u00f3digoOuput <p>Esto es una prueba</p> <p>Y esta es la otra prueba</p>"},{"location":"practicos/TP01_Linux/88_BU/#ejercicio-1-titulo-del-ejercicio-a-realizar","title":"Ejercicio 1. Titulo del Ejercicio a realizar","text":"probado el titulo en codigo<pre><code>import tensorflow as tf\ndef bubble_sort(items):\n    for i in range(len(items)):\n        for j in range(len(items) - 1 - i):\n            if items[j] &gt; items[j + 1]:\n                items[j], items[j + 1] = items[j + 1], items[j]\n</code></pre>"},{"location":"practicos/TP01_Linux/88_BU/#ejercicio-2-titulo-del-ejercicio-a-realizar","title":"Ejercicio 2. Titulo del Ejercicio a realizar","text":"<p>The <code>range()</code> function is used to generate a sequence of numbers.</p> <p></p><pre><code>&gt;seq1\nARTPLKMNSDADASDASDASJFGDAKJFGKJDAHGFKJDHALFKDHFLKJHAKF\nDLKFJHALKDFHKLJHDLFKJHDAKFHLKADJHFLKJHALDKFHLAKDHFLKHA\nDSDADSSA\n</code></pre> Ctrl+Alt+Del <p>Ctrl+V</p>"},{"location":"practicos/TP01_Linux/88_BU/#bibliografia","title":"Bibliograf\u00eda","text":""},{"location":"practicos/TP01_Linux/88_BU/#libros","title":"Libros","text":"<ul> <li>Libro 1 </li> <li>Libro 2</li> </ul>"},{"location":"practicos/TP01_Linux/88_BU/#online","title":"Online","text":"<ul> <li>Material 1</li> <li>Material 2</li> </ul>"},{"location":"practicos/TP02_EMBOSS/","title":"Practico Dos","text":"","tags":["practicos"]},{"location":"practicos/TP02_EMBOSS/#tp-2-emboss","title":"TP 2. EMBOSS","text":"<p> Materiales </p> <p> Slides</p>","tags":["practicos"]},{"location":"practicos/TP02_EMBOSS/#software-a-usar","title":"Software a usar","text":"<ul> <li>EMBOSS</li> </ul>","tags":["practicos"]},{"location":"practicos/TP02_EMBOSS/#terminal-online","title":"Terminal online","text":"<ul> <li>Replit</li> </ul>","tags":["practicos"]},{"location":"practicos/TP02_EMBOSS/#objetivos","title":"Objetivos","text":"<ul> <li>Familiarizarse con el uso de herramientas bioinform\u00e1ticas por l\u00ednea de comandos.</li> <li>Familiarizarse con los formatos caracter\u00edsticos de datos biol\u00f3gicos.</li> <li>Practicar conceptos aprendidos en el TP 1.</li> </ul>","tags":["practicos"]},{"location":"practicos/TP02_EMBOSS/#introduccion-al-tema","title":"Introduccion al Tema","text":"<p>EMBOSS es una suite bioinform\u00e1tica creada y mantenida por EMBnet que incluye una multitud de herramientas elementales en biolog\u00eda molecular y gen\u00e9tica. Algunas ventajas de EMBOSS son:</p> <ul> <li>Maneja informaci\u00f3n biol\u00f3gica en varios formatos para realizar distintos tipos de tareas.</li> <li>Es muy r\u00e1pida, lo cual significa que es computacionalmente escalable.</li> <li>Si bien cada uno de sus programas individuales podr\u00edan ser reemplazados por otros softwares o un script propio, EMBOSS agrupa todos estos programas en un s\u00f3lo paquete y le provee al usuario una interfaz unificada para todas las aplicaciones.</li> </ul> <p>A continuaci\u00f3n se encuentra una lista de 256 programas que contiene EMBOSS y un resumen corto de lo que hace cada uno:</p> <p>Como obviamente es imposible acordarse de todos estos programas, EMBOSS tiene un comando llamado <code>wossname</code> que permite listar comandos que tengan cierta palabra en su descripci\u00f3n (en ingl\u00e9s). </p> <ol> <li> <p>Abran la consola y prueben correr:</p> <pre><code>wossname dna\n</code></pre> <p>Por otro lado, una vez que encuentran un programa que les interesa pueden leer detalladamente como funciona usando el comando <code>tfm</code> (The Funny? Full? Manual). </p> </li> <li> <p>Por ejemplo pueden ejecutar:</p> <pre><code>tfm jaspscan\n</code></pre> <p>El texto que aparece funciona similar al comando <code>less</code> que vimos en el TP 1, donde Space pasa a la pr\u00f3xima p\u00e1gina y apretando Q deja de leerlo.</p> <p>Como mencionamos antes es posible hacer bioinform\u00e1tica sin usar EMBOSS, ya sea porque:</p> <ul> <li>queremos controlar hasta el \u00faltimo detalle que hace nuestro programa,</li> <li>queremos agregar alguna opci\u00f3n que EMBOSS no tiene, </li> <li>o simplemente era una tarea simple y no quer\u00edamos aprender a usar un programa de EMBOSS para hacerla.</li> </ul> <p>Son todas razones v\u00e1lidas. Lo que queremos que se lleven hoy es que EMBOSS existe y que puede hacer algunas tareas que les van a resultar \u00fatiles en el d\u00eda a d\u00eda de hacer bioinform\u00e1tica.</p> </li> </ol>","tags":["practicos"]},{"location":"practicos/TP02_EMBOSS/#aplicaciones-en-biotecnologia","title":"Aplicaciones en Biotecnolog\u00eda","text":"<p>En el TP de hoy vamos a familiarizarnos con EMBOSS y algunas herramientas del paquete, aplic\u00e1ndolas al dise\u00f1o de una estrategia de clonado, puntualmente para dise\u00f1ar/optimizar prote\u00ednas para expresi\u00f3n recombinante heter\u00f3loga.</p> <p>En los \u00faltimos a\u00f1os se simplific\u00f3 la ejecuci\u00f3n del proceso de clonado/expresi\u00f3n. Esto se debe a la aparici\u00f3n de m\u00faltiples herramientas de Ingenieria Gen\u00e9tica y a la posibilidad de sintetizar largas secuencias de \u00e1cidos nucleicos in vitro, eliminando el peso de levantar un gen de inter\u00e9s y el riesgo de meter errores durante la PCR que ejecutamos para hacerlo.</p> <p>Una de las industrias biotecnol\u00f3gicas m\u00e1s antigua es la industria alimenticia. Centenares de microorganismos distintos y decenas de enzimas son utilizados en esta industria para distintos procesos. Algunos de estos procesos son muy complejos, como la fermentaci\u00f3n de un vino, mientras que otros son simples y puntuales, como la degradaci\u00f3n de lactosa en productos l\u00e1cteos para personas intolerantes a este az\u00facar. Los procesos enzim\u00e1ticos simples pueden resolverse f\u00e1cilmente mediante la producci\u00f3n de la enzima de inter\u00e9s en forma heter\u00f3loga.</p> <p>Con el fin de dar rienda suelta a nuestro emprendedor interior, montaremos las bases de una empresa biotecnol\u00f3gica: vamos a producir enzimas. La primera enzima que queremos producir es la VpVan, la cual es la encargada de convertir el \u00e1cido fer\u00falico en vanillina. El \u00e1cido fer\u00falico se puede recuperar en grandes cantidades de residuos agroindustriales, como el salvado de trigo y arroz. La vainillina es un compuesto de alto inter\u00e9s econ\u00f3mico debido a su uso como saborizante (a que no adivinan que sabor tiene).</p> <p></p>","tags":["practicos"]},{"location":"practicos/TP02_EMBOSS/#archivos-fasta","title":"Archivos FASTA","text":"<p>Esta enzima ha sido aislada (y secuenciada) a partir de Vanilla planifolia. Encontrar\u00e1n la secuencia correspondiente entre sus materiales de trabajo (VpVAN.fasta) y m\u00e1s informaci\u00f3n sobre el descubrimiento en este paper.</p> <p>Por si no lo saben o no lo recuerdan, el formato FASTA es la forma m\u00e1s usada para trabajar secuencias biol\u00f3gicas (ADN, ARN, amino\u00e1cidos) en forma digital. Son archivos de texto plano, donde se asume un formato muy sencillo de interpretar para el ojo humano:</p> <p></p> <p>Un archivo FASTA tiene dos elementos importantes:</p> <ul> <li>Header: Est\u00e1 indicado con un &gt; . Es la l\u00ednea con el nombre o identificador de la secuencia. Puede contener informaci\u00f3n adicional como alguna descripci\u00f3n extra sobre la secuencia, tal como las condiciones en que fue obtenida u otra descripci\u00f3n opcional.</li> <li>Secuencia: El resto de las l\u00edneas que contin\u00faan contienen la secuencia propiamente dicha. El largo de cada fila de la secuencia no significa nada; una secuencia de 800 amino\u00e1cidos puede ser escrita en una sola l\u00ednea de 800 amino\u00e1cidos o en 10 l\u00edneas de 80 amino\u00e1cidos cada una. La secuencia sigue hasta el pr\u00f3ximo &gt; o hasta el final del archivo, lo que pase primero.</li> </ul> <p>Info</p> <p>Cuando un FASTA tiene m\u00e1s de una secuencia se lo denomina multiFASTA. En los archivos multiFASTA cada secuencia tiene su header y su secuencia propiamente dicha.</p>","tags":["practicos"]},{"location":"practicos/TP02_EMBOSS/#repaso-biologico","title":"Repaso biol\u00f3gico","text":"<p>Nuestro objetivo en esta gu\u00eda va a ser dise\u00f1ar una secuencia de ADN sint\u00e9tico que:</p> <ul> <li>Exprese VpVan</li> <li>Tenga sitios de corte para enzimas de restricci\u00f3n para que pueda ser insertado en un pl\u00e1smido o vector de expresi\u00f3n de un organismo hu\u00e9sped. En este caso, dichos sitios de corte van a pertenecer a diferentes enzimas de restricci\u00f3n para facilitar la inserci\u00f3n del gen en el sentido correcto</li> <li>Marque a VpVan de alguna forma para facilitar su posterior purificaci\u00f3n</li> </ul> <p>A continuaci\u00f3n vamos a dar una versi\u00f3n super resumida de los conceptos anteriores. Si ya saben como funciona todo lo mencionado pueden ir a la pr\u00f3xima secci\u00f3n (Bases del experimento).</p> Repaso biol\u00f3gico - Pl\u00e1smidos Repaso biol\u00f3gico - Enzimas de Restricci\u00f3n Repaso biol\u00f3gico - Purificaci\u00f3n y Tags","tags":["practicos"]},{"location":"practicos/TP02_EMBOSS/#plasmidos","title":"Pl\u00e1smidos","text":"<p>Los pl\u00e1smidos son mol\u00e9culas de ADN de forma circular presentes principalmente en bacterias, arqueas y levaduras. Estas mol\u00e9culas se encuentran fuera de los cromosomas y se replican de manera aut\u00f3noma. </p> <p>Debido a estas caracter\u00edsticas, es posible generar pl\u00e1smidos artificiales con el objetivo de amplificar (vector de clonaci\u00f3n) o de expresar (vector de expresi\u00f3n) un gen de inter\u00e9s. Esto generalmente se realiza cuando la expresi\u00f3n de dicho gen en su organismo original no es factible, ya sea por problemas de volumen, log\u00edstica o \u00e9tica.</p> <p> </p> <p>Los principales componentes de vector de expresi\u00f3n son:</p> <ul> <li>Origen de la replicaci\u00f3n: punto inicial para la replicaci\u00f3n del pl\u00e1smido</li> <li>Gen de resistencia a antibi\u00f3ticos: gen que se expresa y da resistencia al organismo hu\u00e9sped, permite quedarnos solo con los organismos que tienen el pl\u00e1smido dentro de ellos</li> <li>Promotor: controla la transcripci\u00f3n de una determinada secuencia (en este caso el gen insertado)</li> <li>Sitio de restricci\u00f3n: secuencia que es cortada por una enzima de restricci\u00f3n y donde ser\u00e1 insertado el gen de inter\u00e9s (m\u00e1s de esto a continuaci\u00f3n)</li> </ul>","tags":["practicos"]},{"location":"practicos/TP02_EMBOSS/#enzimas-de-restriccion","title":"Enzimas de Restricci\u00f3n","text":"<p>Las enzimas de restricci\u00f3n son prote\u00ednas que reconocen una secuencia espec\u00edfica de nucle\u00f3tidos dentro de una mol\u00e9cula de ADN y cortan el ADN en ese punto en concreto o en un punto cercano. A esas secuencias de ADN se las denomina sitios de restricci\u00f3n y tienen entre cuatro a seis pares de bases.</p> <p>Hay dos grandes grupos de enzimas de restricci\u00f3n, aquellas que dejan extremos cohesivos y aquellas que dejan extremos romos:</p> <p> </p> <p>Al momento de insertar genes en pl\u00e1smidos se usan generalmente enzimas de restricci\u00f3n que dejan extremos cohesivos ya que facilitan la inserci\u00f3n del gen debido a su especificidad y a que pueden volverse a unir espontaneamente.</p> <p>La idea detr\u00e1s de su uso es colocar un sitio de restricci\u00f3n en el pl\u00e1smido y colocar el mismo sitio de restricci\u00f3n a cada lado del gen de inter\u00e9s (en el ADN que uno sintetiza). Luego los pl\u00e1smidos vacios se colocan en una soluci\u00f3n con el ADN sint\u00e9tico y se les agrega la enzima de restricci\u00f3n correspondiente que va a cortar el ADN dejando los extremos cohesivos en cada sitio de restricci\u00f3n. </p> <p> </p> <p>Como el sitio de restricci\u00f3n es el mismo en el pl\u00e1stido y en la secuencia de ADN, es posible entonces que el ADN sint\u00e9tico se insert\u00e9 en el pl\u00e1smido, ya sea espontaneamente o ayudado por una ligasa. Esta p\u00e1gina tiene muy buenos esquemas sobre el proceso.</p> <p>En el experimento anterior, luego de cortar el sitio de restricci\u00f3n con la enzima, pueden pasar tres cosas: </p> <ul> <li>El pl\u00e1smido se vuelve a cerrar sin ningun inserto </li> <li>Se inserta el gen de inter\u00e9s en la direcci\u00f3n correcta (respecto al promotor en el pl\u00e1smido) </li> <li>Se inserta el gen de inter\u00e9s en la direcci\u00f3n contraria (respecto al promotor en el pl\u00e1smido) </li> </ul> <p>Es posible evitar el caso donde el gen se inserta en la direcci\u00f3n contraria combinando 2 enzimas de restricci\u00f3n diferentes, donde ahora va a haber 2 sitios de restricci\u00f3n en el pl\u00e1smido (uno para cada enzima) y los dos sitios de restricci\u00f3n en el ADN sint\u00e9tico van a ser diferentes (uno para cada enzima, en el mismo orden que en el pl\u00e1smido). Si bien en esta versi\u00f3n no es posible que el gen sea insertado en la direcci\u00f3n contraria, s\u00ed es posible que se vuelva a insertar el fragmento de pl\u00e1smido entre los sitios de restricci\u00f3n, pero hay formas de controlar estos casos. Cuando usamos 2 enzimas de reestricci\u00f3n en esta forma decimos que estamos \"clonando en forma direccional\".</p> <p>Danger</p> <p>Es importante cuando se usan enzimas de restricci\u00f3n asegurarse que no haya ning\u00fan sitio de corte para las enzimas elegidas en el pl\u00e1smido ni en el ADN sint\u00e9tico fuera de los sitios involucrados en el proceso de inserci\u00f3n (ya que de existir tambi\u00e9n ser\u00e1n cortados y la inserci\u00f3n fracasar\u00e1).</p>","tags":["practicos"]},{"location":"practicos/TP02_EMBOSS/#purificacion-y-tags","title":"Purificaci\u00f3n y Tags","text":"<p>Una vez que nuestros organismos hu\u00e9sped tienen el vector de expresi\u00f3n con el gen de inter\u00e9s, se los deja crecer, reproducirse y expresar la prote\u00edna de inter\u00e9s en grandes cantidades. Una vez hecho esto, es necesario extraer esa prote\u00edna de la soluci\u00f3n, lo que no es trivial.</p> <p>Hay varias formas de purificar prote\u00ednas y una de ellas es la cromatograf\u00eda por afinidad, la cual se basa en la uni\u00f3n reversible entre el analito de inter\u00e9s (en nuestro caso la VpVan) y un ligando espec\u00edfico, inmovilizado en un soporte s\u00f3lido inerte. Cuando la muestra pasa por la columna, s\u00f3lo son retenidas las mol\u00e9culas que se unen de manera selectiva al ligando por afinidad y las que no se unen avanzan con la fase m\u00f3vil. La figura a continuaci\u00f3n muestra un ejemplo donde se usan anticuerpos inmovilizados en una columna para purificar a la prote\u00edna roja del resto de la soluci\u00f3n:</p> <p> </p> <p>Para poder construir estas columnas es necesario conseguir un ligando que reconozca a nuestra prote\u00edna de inter\u00e9s. Si bien esto es te\u00f3ricamente cierto, como nosotros estamos sintetizando el ADN desde cero podemos pensar lateralmente y agregarle a nuestra prote\u00edna una secuenc\u00eda aminoac\u00eddica en uno de sus extremos para la cual ya conozcamos ligandos. Estas secuencias pueden ser desde pocos amino\u00e1cidos hasta a prote\u00ednas peque\u00f1as y son denominadas tags.</p>","tags":["practicos"]},{"location":"practicos/TP02_EMBOSS/#bases-del-experimento","title":"Bases del experimento","text":"<p>Volviendo a nuestro experimento, queremos insertar el gen de VpVan en un vector de expresi\u00f3n. Nuestro organismo hu\u00e9sped es:</p> <ul> <li>E. coli BL21</li> </ul> <p>Como queremos clonar en forma direccional tenemos que usar dos enzimas de restricci\u00f3n. En el laboratorio est\u00e1n disponibles:</p> <ul> <li>BamHI</li> <li>ApoI</li> <li>HindIII</li> </ul> <p>Al momento de purificar necesitamos agregarle un tag a la prote\u00edna. Vamos a probar 3 tags diferentes:</p> <ul> <li>FLAG-tag</li> <li>His-tag</li> <li>MBP-tag</li> </ul> <p>Por cuestiones de practicidad, todos los tags van a estar en el C-terminal.</p> <p>En los siguientes ejercicios vamos a:</p> <ul> <li>Ejercicio 1: Generar secuencias quim\u00e9ricas VpVan-Tag agregando diferentes tags de inter\u00e9s a la secuencia prote\u00edca de VpVan</li> <li>Ejercicio 2: Obtener el genoma del organismo hu\u00e9sped E. coli BL21 (necesario para el Ejercicio 3)</li> <li>Ejercicio 3: Generar una tabla de frecuencia de uso de codones del organismo hu\u00e9sped</li> <li>Ejercicio 4: Generar la secuencia nucleot\u00eddica VpVan-Tag con los codones optimizados para el organismo hu\u00e9sped</li> <li>Ejercicio 5: Verificar que no hayan quedado sitios de corte para nuestras enzimas de restricci\u00f3n dentro de la secuencia VpVan-Tag optimizada y luego agregar los sitios de restricci\u00f3n en los bordes de la secuencia</li> </ul>","tags":["practicos"]},{"location":"practicos/TP02_EMBOSS/#ejercicio-1-secuencias-aminoacidicas-vpvan-tag","title":"Ejercicio 1. Secuencias aminoac\u00eddicas VpVan-Tag","text":"<p>Para generar las secuencias de amino\u00e1cidos quim\u00e9ricas VpVan-Tag (donde Tag = FLAG/His/MBP) van a necesitar los siguientes archivos que se encuentras en sus materiales de trabajo:</p> <ul> <li>VpVan.fasta</li> <li>FLAG-tag.fasta</li> <li>His-tag.fasta</li> <li>MBP-tag.fasta</li> </ul> <p>Recomendaci\u00f3n de organizaci\u00f3n de archivos</p> <p>Antes de comenzar a trabajar, es altamente recomendable que creen una carpeta para este ejercicio. Esto les va a permitir organizar mejor sus archivos y evitar problemas al momento de correr los scripts.</p> <p>Es altamente recomendado que creen diferentes carpetas para los diferentes TPs y en algunos casos para los diferentes ejercicios (especialemente en este). El nombre y la ubicaci\u00f3n lo pueden decidir ustedes, pero un ejemplo para este ejercicio ser\u00eda ~/Documentos/TP_02/EJ_1.</p> <ul> <li>Una vez creada la carpeta para este ejercicio, muevan los cuatro archivos anteriores a dicha carpeta.</li> </ul> <p>Tip</p> <p>Recuerden que es preferible no usar espacios al crear directorios o archivos</p> <p>Nuestro objetivo ahora es crear 3 nuevos archivos FASTA que contengan las diferentes construcciones (VpVan + cada uno de los tags). Vamos a llamarlos VpVan-FLAG-tag.fasta  reemplazando el nombre del tag correspondiente en cada caso.</p> <p>Ahora bien, como son solo 3 tags esto se podr\u00eda hacer a mano copiando y pegando, pero es un buen momento para profundizar en dos conceptos que aprendimos la clase pasada: scripts y ciclos.</p> <p>1) Creen un archivo vac\u00edo de texto en esa carpeta y llamenlo agregar_tags.sh. Dentro del archivo pongan lo siguiente:</p> C\u00f3digoC\u00f3digo con comentarios <pre><code>vpvan_sequence=`cat VpVAN.fasta | grep -v \"&gt;\"`\nlista_de_archivos_tags=`ls *-tag.fasta`\n\nfor archivo_tag in $lista_de_archivos_tags\ndo \n    tag_sequence=`cat $archivo_tag | grep -v \"&gt;\"`\n\n    new_header=\"&gt;VpVAN-$archivo_tag\"\n    combined_sequence=\"$vpvan_sequence$tag_sequence\"\n\n    echo \"$new_header\" &gt; VpVAN-$archivo_tag\n    echo \"$combined_sequence\" &gt;&gt; VpVAN-$archivo_tag\ndone\n</code></pre> <pre><code># Aca estamos ejecutando comandos de Linux y guardando su output en una variable\n# En estos casos hay que rodear a los comandos con ` (acento grave o comilla invertida)\n\n# Leemos el FASTA de VpVAN y nos quedamos solo con la secuencia\n# (estamos removiendo con grep cualquier linea que tenga &gt;, que aca es solo el header)\nvpvan_sequence=`cat VpVAN.fasta | grep -v \"&gt;\"` \n\n# Creamos una lista que contiene a todos los archivos que terminan con -tag.fasta\n# (esto va a mirar solo archivos que est\u00e9n en la carpeta donde se corre el script)\nlista_de_archivos_tags=`ls *-tag.fasta`\n\n# Este es una estructura a la que llamamos *for each* en el TP 1. Es un *for*, pero en vez de tener \n# una cantidad determinada de ciclos, recorre cada uno de los elementos de una lista\nfor archivo_tag in $lista_de_archivos_tags\ndo \n    # Leemos el FASTA del tag y nos quedamos solo con la secuencia\n    tag_sequence=`cat $archivo_tag | grep -v \"&gt;\"`\n\n    # Creamos una variable que almacene el nuevo header para la secuencia de VpVAN + tag\n    new_header=\"&gt;VpVAN-$archivo_tag\"\n\n    # Calculamos la nueva secuencia VpVAN + tag\n    combined_sequence=\"$vpvan_sequence$tag_sequence\"\n\n    # Escribimos el nuevo header y la nueva secuencia en un nuevo archivo\n    echo \"$new_header\" &gt; VpVAN-$archivo_tag\n    echo \"$combined_sequence\" &gt;&gt; VpVAN-$archivo_tag\ndone\n</code></pre> <p>Como recordatorio del TP 1:</p> <ul> <li><code>cat</code> lee archivos de texto y los escribe en la consola</li> <li><code>|</code> desvia la salida de un programa para que funcione como entrada del siguiente</li> <li><code>grep</code> filtra texto, quedandos\u00e9 solo con aquellas l\u00edneas que contengan un texto dado (y de usar la opci\u00f3n <code>-v</code> se queda solo con aquellas que no lo contengan)</li> <li><code>ls</code> lista los archivos y carpetas dentro del directorio actual</li> <li><code>echo</code> escribe un texto por consola</li> <li><code>&gt;</code> desvia la salida que \u00edria a consola hacia un archivo de texto, sobrescribiendolo</li> <li><code>&gt;&gt;</code> desvia la salida que \u00edria a consola hacia un archivo de texto, sin sobreescribirlo (agrega lineas al final)</li> <li><code>for</code>, <code>in</code>, <code>do</code> y <code>done</code> son todas partes del ciclo for each. El c\u00f3digo entre <code>do</code> y <code>done</code> se va a repetir por cada elemento en <code>$lista_de_archivos_tags</code>, donde en cada iteraci\u00f3n la variable <code>$archivo_tag</code> toma el valor de uno de esos elementos</li> </ul> <p>Hay dos cosas en este script que no vimos en el TP 1. La primera es que estamos ejecutando comandos de Bash y guardando su salida en variables. En estos casos es necesario rodear el comando con <code>`</code>, llamado acento grave o comilla invertida. Por ejemplo:</p> <pre><code>variable=`comando -opciones parametro1 parametro2`\n</code></pre> <p>La segunda novedad es el uso de <code>*</code> con el comando <code>ls</code>. En todo lo que es Linux el caracter <code>*</code> funciona como comod\u00edn, tomando cualquier valor. Esto quiere decir que <code>ls *-tag.fasta</code> va a listar todos los archivos cuyos nombres terminen con \"-tag.fasta\", sin importar como empiecen (pueden probar correr el comando <code>ls *-tag.fasta</code> a mano en la consola y ver que devuelve).</p> <ul> <li>Entienden ahora lo que hace el script?</li> </ul> <p>Lean la pesta\u00f1a C\u00f3digo con comentarios para aclarar cualquier duda que tengan sobre \u00e9l (y si todav\u00eda no se entiende no duden en preguntar).</p> <p>2) Ahora abran la consola y corran el script que acabamos de crear, generando as\u00ed los nuevos 3 archivos.</p> <p>Tip</p> <p>Recuerden que los script se corren con <code>bash ARCHIVO_SCRIPT</code></p> <p>\u00a1Ya tenemos nuestras secuencias quim\u00e9ricas!</p> <p>Tip</p> <p>Este script va a dar problemas si se lo corre multiples veces. Esto se debe a que al correrlo la primera vez estamos creando m\u00e1s archivos que terminan con \"-tag.fasta\", que en una segunda corrida van a ser detectados por el <code>ls</code>. Si no quieren tener problemas con esto pueden agregar el siguiente c\u00f3digo luego de dicho comando: <code>| grep -v \"VpVAN\"</code></p>","tags":["practicos"]},{"location":"practicos/TP02_EMBOSS/#ejercicio-2-genoma-de-e-coli","title":"Ejercicio 2. Genoma de E. coli","text":"<p>Nosotros queremos expresar el gen de un organismo en otro organismo. Si bien el c\u00f3digo gen\u00e9tico es pr\u00e1cticamente universal, diferentes organismos pueden tener preferencia para diferentes codones que generan un mismo amino\u00e1cido. Por esta raz\u00f3n, al hacer expresi\u00f3n recombinante heter\u00f3loga es una buena idea cambiar los codones del gen de inter\u00e9s para que matcheen mejor con la preferencia de codones del organismo hu\u00e9sped (se modifica el ADN pero se sigue produciendo la misma prote\u00edna). El primer paso para realizar esta modificaci\u00f3n es conocer cuales son los codones preferidos por dicho organismo.</p> <p>3) Busquen usando el comando <code>wossname</code> que programas de EMBOSS trabajan con codones (recuerden que est\u00e1 en ingl\u00e9s, asi que tienen que buscar \"codon\"). Lean la descripci\u00f3n de dichos programas, \u00bfcual les parece que vamos a usar para calcular la tabla de uso de codones?</p> Respuesta <p><code>cusp</code>, cuya descripci\u00f3n es \"Create a codon usage table from nucleotide sequence(s)\"</p> <p>Si leen la descripci\u00f3n del programa, ver\u00e1n que pide una secuencia de nucle\u00f3tidos, es decir, que necesitamos un FASTA del genoma completo de E. coli (ya que \u00e9ste es nuestro organismo hospedador).</p> <p>Un buen lugar para obtener informaci\u00f3n de genomas, genes, y prote\u00ednas es RefSeq, que es una colecci\u00f3n curada de secuencias nucleot\u00eddicas y sus productos. En su FAQ (Frequently Asked Questions, o preguntas frecuentes) hay una pregunta que es b\u00e1sicamente lo que queremos hacer nosotros:</p> <p>How can I download RefSeq data for all complete bacterial genomes?</p> <p>Si bien los comandos que ellos sugieren son un poco complejos, vamos a utilizarlos y tratar de explicarlos lo mejor posible.</p> <p>Tip</p> <p>Antes de seguir les recomendamos crear una carpeta nueva para este ejercicio, por ejemplo ~/Documentos/TP_02/EJ_2.</p>","tags":["practicos"]},{"location":"practicos/TP02_EMBOSS/#refseq-paso-1-bajar-y-filtrar-la-tabla-con-los-genomas","title":"RefSeq - Paso 1 - Bajar y filtrar la tabla con los genomas","text":"<p>4) El primer paso indicado en el FAQ es descargar el archivo assembly_summary.txt y ponerlo en la carpeta de este ejercicio. Esto lo pueden hacer desde la p\u00e1gina de RefSeq a mano o abriendo la consola en la carpeta de este ejercicio y corriendo:</p> <pre><code>wget ftp.ncbi.nlm.nih.gov/genomes/refseq/bacteria/assembly_summary.txt\n</code></pre> <p>Question</p> <p>\u00bfQu\u00e9 piensan que hace <code>wget</code>? \u00bfC\u00f3mo pueden averiguarlo si no lo saben?</p> <p>Warning</p> <p>Si el comando <code>wget</code> tarda mucho o ven que tiene errores bajens\u00e9 este archivo desde este link</p> <p>Una vez descargado ese archivo (que pesa bastante) queremos ver sus contenidos. Sabiendo que es un archivo que tiene m\u00e1s de 250.000 l\u00edneas:</p> <p>5) \u00bfQu\u00e9 comando usar\u00edan para ver que tipo de datos tiene adentro? Pru\u00e9benlo.</p> <p>Dado que es un archivo con muchas columnas, probablemente les cueste entender lo que est\u00e1n viendo aunque hayan usado el comando correcto.</p> <p>Para entender la estructura de nuestro archivo vamos a crear un archivo temporal que tenga s\u00f3lo las primeras 20 filas de este archivo:</p> <pre><code>head -20 assembly_summary.txt &gt; assembly_summary_temporal.tsv\n</code></pre> <p>Lo \u00fanico que les deber\u00eda llamar la atenci\u00f3n del comando anterior es que el nuevo archivo tiene la extensi\u00f3n tsv. Esto lo mencionamos por arriba en el TP 1, pero los archivos TSV o \"Tab-Separated Values\" son archivos de texto que contienen una tabla donde sus columnas est\u00e1n separadas entre ellas por un Tab, lo cual es exactamente el caso de la tabla actual.</p> <p>Hagan doble click sobre el archivo assembly_summary_temporal.tsv.</p> <p>Word Wrapping</p> <p>Si abren el archivo y ven que todo est\u00e1 en una sola l\u00ednea, hay que modificar la opci\u00f3n de \"Word Wrapping\" o \"Ajuste de l\u00ednea\" en su editor de texto. Esto deber\u00eda hacer que cada fila se vea en una l\u00ednea diferente, permiti\u00e9ndoles ver la tabla correctamente.</p> <p>En replit vayan a 'All Tools' (el icono de los cuatro cuadraditos a la izquierda), busquen al final de todo 'User Settings' y por \u00faltimo la opci\u00f3n \"Wrappping\" y selecci\u00f3n 'None'.</p> <ul> <li>Identifiquen la columna correspondiente a la especie (son solo las primeras 20 filas, no van a encontrar a E. coli), la cepa y el link a la ubicaci\u00f3n del genoma.</li> </ul> <p>6) Ahora que conocen la estructura de la tabla, y sabiendo que tiene muchos mas organismos que E. coli, tenemos que filtrar el archivo y quedarnos solo con nuestro organismo y cepa de inter\u00e9s. Para esto, corran los siguientes comandos uno a la vez:</p> C\u00f3digoC\u00f3digo con comentarios <pre><code>head -2 assembly_summary.txt &gt; assembly_summary_coli.tsv\ngrep \"Escherichia coli\" assembly_summary.txt | grep \"BL21\" &gt;&gt; assembly_summary_coli.tsv\n</code></pre> <pre><code># Generamos un nuevo archivo con el header de la tabla (que en este caso son 2 filas)\nhead -2 assembly_summary.txt &gt; assembly_summary_coli.tsv\n\n# Buscamos dentro del archivo las filas que contengan \"Escherichia coli\" y \"BL21\" y \n# las agregamos a la nuevo archivo\ngrep \"Escherichia coli\" assembly_summary.txt | grep \"BL21\" &gt;&gt; assembly_summary_coli.tsv\n</code></pre>","tags":["practicos"]},{"location":"practicos/TP02_EMBOSS/#refseq-paso-2-crear-un-archivo-con-links-a-las-carpetas-de-los-genomas","title":"RefSeq - Paso 2 - Crear un archivo con links a las carpetas de los genomas","text":"<p>7) Ahora que tenemos y entendemos la tabla con nuestros datos de E. coli la podemos abrir para verla. Van a ver que no hay solo un genoma de E. coli BL21, sino varios, por lo cual nuestro objetivo de crear una tabla de codones acaba de volverse un poco m\u00e1s complicado. Lo que vamos a hacer entonces es bajar todos los genomas de E. coli BL21 que vemos en la tabla.</p> S\u00f3lo para los m\u00e1s curiosos! Si te interesa saber como usamos awk para hacer este paso lean esto: <pre><code>awk -F \"\\t\" '{if ($12==\"Complete Genome\" &amp;&amp; $11==\"latest\") {print $20}}' assembly_summary_coli.tsv &gt; ftpdirpaths\n</code></pre> <p>Al comando <code>awk</code> lo vimos brevemente al final del TP 1 y sirve para trabajar con tablas en Bash (entre otras cosas). Las diferentes partes de este comando son:</p> <ul> <li><code>-F \"\\t\"</code> indica que el separador de columnas es <code>\\t</code>, o sea, Tab</li> <li><code>$12==\"Complete Genome\"</code> es una condici\u00f3n que filtra las filas, qued\u00e1ndose solo con aquellas donde la columna 12 (assembly_level) es \"Complete Genome\"</li> <li><code>$11==\"latest\"</code> es una condici\u00f3n que filtra las filas, qued\u00e1ndose solo con aquellas donde la columna 11 (version_status) es \"latest\"</li> <li><code>&amp;&amp;</code> se denomina and y une ambas condiciones, pidiendo que ambas se cumplan para que la condici\u00f3n total se cumpla</li> <li><code>{print $20}</code> indica que se va a devolver la columna 20 (ftp_path, contiene el path del genoma, o sea, la carpeta)</li> </ul> <p>Este comando va a crear el archivo ftpdirpaths, que contiene links a las carpetas que contienen los genomas.</p> <ul> <li>Investiguen cuantos links quedaron en ftpdirpaths. \u00bfEntienden por qu\u00e9? Sino consulten.</li> </ul> <p>Los links que tenemos de momento tienen el formato:</p> <p>ftp://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/833/145/GCF_000833145.1_ASM83314v1</p> <p>Sin embargo, estos son links a las carpetas que contienen los genomas. Siguiendo las instrucciones del FAQ de RefSeq podemos crear el link de los genomas, que para el ejemplo anterior ser\u00eda:</p> <p>ftp://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/833/145/GCF_000833145.1_ASM83314v1/GCF_000833145.1_ASM83314v1_cds_from_genomic.fna.gz</p> <p>Donde el nombre del archivo es el nombre de la \u00faltima carpeta + \"_cds_from_genomic.fna.gz\"</p> <p>Los archivos terminados en .fna.gz son secuencias en formato FASTA (f) de nucle\u00f3tidos (na) comprimidas (gz).</p> <p>Hay varias formas de crear estos nuevos links. Nosotros lo vamos a hacer de la siguiente manera:</p> <pre><code>awk -F \"/\" '{print $0 \"/\" $10 \"_cds_from_genomic.fna.gz\"}' ftpdirpaths &gt; ftpfilepaths\n</code></pre> <p>Donde:</p> <ul> <li><code>-F \"/\"</code> indica que el separador de columnas es <code>/</code>. Lo que est\u00e1 haciendo este c\u00f3digo es leer nuestros paths como si fueran tablas de varias columnas, haciendo que cada carpeta quede en su propia columna.</li> <li><code>$0</code> parecer\u00eda indicar la columna 0, pero las columnas en <code>awk</code> van de 1 en adelante (<code>$1</code>, <code>$2</code>, etc). El \u00edndice <code>$0</code> es un \u00edndice especial que devuelve toda la fila (que en este caso es todo el path a la carpeta del genoma).</li> <li><code>$10</code> es la columna 10, la cual contiene el nombre del genoma (es el nombre de la \u00faltima carpeta en el path).</li> <li><code>print</code> va a concatenar <code>$0</code> (el path a la carpeta del genoma), <code>\"/\"</code> (una barra para separar los directorios), <code>$10</code> (la primera parte del nombre del archivo a descargar) y <code>\"_cds_from_genomic.fna.gz\"</code> (la segunda parte del nombre del archivo a descargar). <code>awk</code> va a hacer esto por cada fila del archivo ftpdirpaths.</li> </ul> <p>Una vez que entienden lo que hace este comando abran la terminal y corranl\u00f3.</p> Por si se quedaron con curiosidad de el comando que propon\u00eda el FAQ de RefSeq <p>El comando <code>awk</code> que sugeria el FAQ de RefSeq es un poco m\u00e1s complejo, pero llegaba al mismo resultado. Noten que en este comando el archivo tiene la extensi\u00f3n .gbff.gz que hace referencia al formato de GenBank, que no es el con el que vamos a trabajar. Hay que cambiarlo por \"cds_from_genomic.fna.gz\"</p> <pre><code>awk 'BEGIN{FS=OFS=\"/\";filesuffix=\"genomic.gbff.gz\"}{ftpdir=$0;asm=$10;file=asm\"_\"filesuffix;print ftpdir,file}' ftpdirpaths &gt; ftpfilepaths\n</code></pre> <p>No es necesario que lo entiendan 100%, pero vamos a aclarar algunas cosas:</p> <ul> <li><code>BEGIN</code> significa que las cosas entre las primeras llaves se van a ejecutar solo una vez, y no una vez por fila (como el resto).</li> <li><code>FS</code> es una variable interna de <code>awk</code> que indica como se separan las columnas en la tabla a leer (es equivalente a usar <code>-F</code>). La variable <code>OFS</code> indica lo mismo, pero para la salida de <code>awk</code>. Con <code>FS=OFS=\"/\"</code> estamos indicando que ambos ser\u00e1n la barra <code>/</code>. Lo que est\u00e1 haciendo este c\u00f3digo es leer nuestros paths como si fueran tablas de varias columnas, haciendo que cada carpeta quede en su propia columna.</li> <li>En <code>filesuffix=\"cds_from_genomic.fna.gz\"</code> est\u00e1 definiendo una variable en la que va a almacenar la cadena de texto que queremos agregar al final de cada link.</li> <li>En <code>ftpdir=$0</code> est\u00e1 definiendo una variable en la que parece almacenar la columna 0. Ahora bien, las columnas en <code>awk</code> van de 1 en adelante (<code>$1</code>, <code>$2</code>, etc), pero el \u00edndice <code>$0</code> es un \u00edndice especial que devuelve toda la fila (que en este caso es todo el path a la carpeta del genoma).</li> <li>En <code>asm=$10</code> est\u00e1 definiendo una variable en la que va a almacenar la columna 10, la cual contiene el nombre del genoma (es el nombre de la \u00faltima carpeta en el path).</li> <li>En <code>file=asm\"_\"filesuffix</code> est\u00e1 definiendo una nueva variable como la concatenaci\u00f3n de <code>asm</code>, un gui\u00f3n bajo y <code>filesuffix</code>. Este va a ser el nombre del archivo a descargar (pero todav\u00eda le falta el path).</li> <li><code>print ftpdir,file</code> va a imprimir el valor de <code>ftpdir</code> (el path a la carpeta del genoma) seguido por el valor de file (el nombre del archivo a descargar) por cada fila del archivo ftpdirpaths. La barra entre ambos (<code>/</code>) es agregada autom\u00e1ticamente debido a que declaramos <code>OFS=\"/\"</code> al principio.</li> </ul>","tags":["practicos"]},{"location":"practicos/TP02_EMBOSS/#refseq-paso-3-descargar-genomas-de-e-coli","title":"RefSeq - Paso 3 - Descargar genomas de E. coli","text":"<p>8) Ya falta poco para tener nuestros genomas, solo hay que descargar todos los links que tenemos adentro del archivo ftpfilepaths.</p> <ul> <li>Copi\u00e1 este archivo a tu carpeta de trabajo (<code>Ej02</code>).</li> </ul> <p>Esto se puede hacer usando el comando <code>wget</code>. Ahora bien, por defecto a <code>wget</code> hay que pasarle un link de descarga como hicimos arriba. Por suerte existe una opci\u00f3n que permite pasarle un archivo de entrada y que descargue todos los links que se encuentran en \u00e9l.</p> <ul> <li> <p>Usen <code>wget -h</code> (mas conciso) o <code>man wget</code> (mas extenso) para ver las diferentes opciones de <code>wget</code>, encuentren la que se usa para pasarle un archivo de entrada (o fichero o input file) con links (o URLs) y usen <code>wget</code> con ftpfilepaths para bajar todos los genomas que seleccionamos.</p> <p>Tip</p> <p><code>wget</code> tiene bastantes opciones, asi que para hacerla un poco m\u00e1s f\u00e1cil sepan que la opci\u00f3n que necesitan es una de las 15 primeras y est\u00e1 en la secci\u00f3n Ficheros de registro y de entrada (o Logging and input file)</p> </li> </ul> <p>Este comando puede tardar un rato en descargar todo y va a bajar 11 archivos con extensi\u00f3n .fna.gz donde .fna es una extensi\u00f3n que hace referencia a que el archivo contiene informaci\u00f3n de secuencia (similar a FASTA) y .gz es la extensi\u00f3n de los archivos comprimidos de Linux.</p>","tags":["practicos"]},{"location":"practicos/TP02_EMBOSS/#ejercicio-3-construir-tabla-de-frecuencias-de-uso-de-codones","title":"Ejercicio 3. Construir tabla de frecuencias de uso de codones","text":"<p>Ahora que tenemos nuestros genomas es momento de usar el comando <code>cusp</code> del que hablamos al principio del ejercicio anterior para transformar nuestros genomas en tablas con frecuencias de uso de codones.</p> <p>Como tenemos 11 archivos .fna.gz vamos a tener que correr el comando <code>cusp</code> 11 veces, y la mejor forma de hacer esto es creando un script con un ciclo for each que lo haga por nosotros. Este ciclo va a recorrer todos los archivos .fna.gz que acabamos de descargar, los va a descomprimir y va a ejecutar el comando <code>cusp</code> para cada uno.</p> <p>10) Reemplacen los REEMPLAZAR en el pr\u00f3ximo c\u00f3digo por lo que sea adecuado para conseguir nuestro objetivo:</p> <pre><code>REEMPLAZAR\n\nfor REEMPLAZAR in REEMPLAZAR\ndo \n    REEMPLAZAR\ndone\n</code></pre> <p>Sabiendo que un REEMPLAZAR es:</p> <pre><code># Creamos una lista que contiene a todos los archivos que empiezan con \"GCF\" y terminan con \".gz\"\nlista_de_archivos_genomas=`ls GCF*.gz`\n</code></pre> <p>y otro es:</p> <pre><code># Descomprimimos el archivo \".gz\" y corremos el comando *cusp* para cada $archivo_genoma de la lista\nzcat $archivo_genoma | cusp -auto -sequence \"stdin\" -outfile \"${archivo_genoma}.cusp\"\n</code></pre> <ul> <li><code>zcat</code> es un comando que descomprime archivos .gz y devuelve su contenido por consola (similar a <code>cat</code>).</li> <li><code>-auto</code> hace que <code>cusp</code> use los par\u00e1metros por defecto y no nos consulte cuales usar.</li> <li><code>-sequence \"stdin\"</code> le esta diciendo a <code>cusp</code> que el genoma se lo estamos dando por la consola (mediante el pipe o <code>|</code>).</li> <li> <p><code>-outfile \"${archivo_genoma}.cusp\"</code> define el nombre del archivo de salida de <code>cusp</code>, que en este caso es el nombre del genoma seguido de .cusp. Si bien las llaves no son necesarias en este caso, ayudan a entender donde termina la variable y empieza el string.</p> <p>Tip</p> <p>Si no les sale pueden ver el for each del Ejercicio 1 para usarlo como base (si bien ese es m\u00e1s complicado)</p> <p>Aclaraci\u00f3n</p> <p>Idealmente habr\u00eda que sacarle la extensi\u00f3n anterior al archivo (ya que ahora va a quedar .fna.gz.cusp), pero ya tenemos bastante que hacer.</p> </li> </ul> <p>11) Una vez creado el script, c\u00f3rranlo.</p> Si ven que este script tarda mucho tiempo en correr (varios minutos sin indicar que avanza) lean esto: <ul> <li>Cancelen la corrida apretando Ctrl+C en la terminal</li> <li>Usen para la pr\u00f3xima seccion los archivos ecoli_BL21_codon_table_1.cusp y ecoli_BL21_codon_table_2.cusp que se encuentra en sus materiales de trabajo</li> </ul>","tags":["practicos"]},{"location":"practicos/TP02_EMBOSS/#comparar-tablas-de-codones","title":"Comparar tablas de codones","text":"<p>Recordando nuestro objetivo, nosotros quer\u00edamos una tabla de codones de E. coli para saber como modificar el ADN de nuestra prote\u00edna de inter\u00e9s (VpVan) para que use aquellos codones preferidos por el organismo hu\u00e9sped. En este momento tenemos varias tablas de codones, asi que tenemos que elegir alguna.</p> <p>Abran uno de los archivos .cusp que acabamos de crear y vean que informaci\u00f3n tiene:</p> Ayuda-memoria con amino\u00e1cidos y sus abreviaturas Full Name Abbreviation (3 Letter) Abbreviation (1 Letter) Alanine Ala A Arginine Arg R Asparagine Asn N Aspartate Asp D Aspartate or Asparagine Asx B Cysteine Cys C Glutamate Glu E Glutamine Gln Q Glutamate or Glutamine Glx Z Glycine Gly G Histidine His H Isoleucine Ile I Leucine Leu L Lysine Lys K Methionine Met M Phenylalanine Phe F Proline Pro P Serine Ser S Threonine Thr T Tryptophans Trp W Tyrosine Tyr Y Valine Val V <ol> <li>\u00bfPor qu\u00e9 hay m\u00e1s de un cod\u00f3n para cada amino\u00e1cido?</li> <li>\u00bfQu\u00e9 indica la columna Fraction?</li> <li>\u00bfQu\u00e9 indica la columna Frequency? (pueden encontrar la respuesta usando <code>tfm cusp</code>, pero est\u00e1 mas claro en la ayuda online)</li> <li>Ahora abran otro archivo .cusp, \u00bfnotan diferencias entre las frecuencias de uso de codones de los distintos proyectos genoma de E.Coli BL21?</li> </ol> <p>En un principio parecer\u00eda que ambos archivos .cusp son bastante parecidos, pero queremos estar seguros. EMBOSS tiene un programa llamado <code>codcmp</code> que permite comparar tablas de codones, calculando ciertos estad\u00edsticos. El programa se usa as\u00ed:</p> <pre><code>codcmp ARCHIVO_CUSP_1 ARCHIVO_CUSP_2 ARCHIVO_SALIDA\n</code></pre> <p>12) Usen este comando para comparar los dos archivos .cusp que miraron previamente y guarden la comparaci\u00f3n en un archivo llamado cusp_comparison.out.</p> <ul> <li>Abran cusp_comparison.out y vean los estad\u00edsticos calculados. \u00bfSon compatibles estos resultados con nuestras observaciones previas de que ambos archivos .cusp son muy parecidos?</li> </ul> <p>Hay entoces una noticia buena y una mala:</p> Noticia Buena <p>Todos las tablas de frecuencias de codones son casi id\u00e9nticas, asi que podemos usar cualquiera de ellas y va a funcionar bien.</p> <ul> <li> <p>Aclaraci\u00f3n 1: Los resultados de <code>codcmp</code> no alcanzan para decir que las diferencias no son \"estadisticamente signficativas\" (aunque en este caso es bastante obvio). En el manual de <code>codcmp</code> dan algunas ideas para calcular esto.</p> </li> <li> <p>Aclaraci\u00f3n 2: Otra forma de resolver el \"problema\" de tener muchas tablas de codones podr\u00eda haber sido calcular una nueva tabla de frecuencias de codones que sea un promedio de todas las anteriores, pero esto es un trabajo complejo y no se amerita hacerlo para este caso debido a los similar que son las diferentes tablas entre s\u00ed.</p> </li> </ul> Noticia Mala <p>Todos las tablas de frecuencias de codones son casi id\u00e9nticas, asi que podr\u00edamos haber bajado solo una de ellas y ahorrarnos bastante trabajo (aunque no ten\u00edamos forma de saber esto previamente).</p>","tags":["practicos"]},{"location":"practicos/TP02_EMBOSS/#ejercicio-4-optimizar-secuencia-a-insertar-en-base-a-la-tabla-de-codones","title":"Ejercicio 4. Optimizar secuencia a insertar en base a la tabla de codones","text":"<p>Ya casi estamos. En este momento tenemos la tabla de frecuencia de uso de codones para E. coli BL21 y queremos aplicar dichos codones a las 3 secuencias quim\u00e9ricas que creamos en el Ejercicio 1, es decir, codificar una secuencia amionac\u00eddica de planta en la forma m\u00e1s \u00f3ptima para su traducci\u00f3n en E. coli.</p> <p>Para organizar un poco los archivos volvemos a recomendar crear una carpeta para este ejercicio, por ejemplo ~/Documentos/TP_02/EJ_4. Dentro de la carpeta copien los siguientes archivos:</p> <ul> <li>VpVAN-FLAG-tag.fasta (creado en el Ejercicio 1)</li> <li>VpVAN-His-tag.fasta (creado en el Ejercicio 1)</li> <li>VpVAN-MBP-tag.fasta (creado en el Ejercicio 1)</li> <li>Elijan alguno de los archivos .cusp creados en el Ejercicio 3, copienlo a la nueva carpeta y cambienl\u00e9 el nombre a ecoli_BL21_codon_table.cusp.</li> </ul> <p>Ahora bien, para hacer esta optimizaci\u00f3n de secuencias podemos usar otro de los programas de EMBOSS llamado <code>backtranseq</code>. Este programa toma una secuencia de amino\u00e1cidos correspondiente a una prote\u00edna de inter\u00e9s y una tabla de frecuencia de uso de codones y usa ambos para hacer una traducci\u00f3n inversa desde la secuencia prote\u00edca hacia la secuencia de ADN que, con mayor probabilidad, le dio origen. Es decir, <code>backtranseq</code> devuelve una secuencia de ADN a partir de una secuencia de amino\u00e1cidos. Este comando se usa:</p> <pre><code>backtranseq -auto -sequence ARCHIVO_PROTEINA_FASTA -cfile ARCHIVO_CUSP -outfile ARCHIVO_SALIDA_ADN_FASTA\n</code></pre> <p>13) Corran este comando 3 veces pas\u00e1ndole los archivos correctos y creen los siguientes archivos (si quieren pueden hacer script con un for each, pero no hace falta):</p> <ul> <li>Ecoli-DNA-VpVAN-FLAG-tag.fasta</li> <li>Ecoli-DNA-VpVAN-His-tag.fasta</li> <li>Ecoli-DNA-VpVAN-MBP-tag.fasta</li> </ul> <p>Tip</p> <p>De hacerlo a mano, aca van a tener que ejecutar tres comandos muy similares. Recuerden que pueden usar Up y Down en su terminal para navegar por los ultimos comandos utilizados y modificar lo necesario, as\u00ed como Tab para autocompletar nombres de archivos. Tambi\u00e9n puede serles \u00fatiles la tecla Home (Inicio) y End (Fin) para moverse al principio o al final del comando que est\u00e1n editando.</p>","tags":["practicos"]},{"location":"practicos/TP02_EMBOSS/#ejercicio-5-agregar-enzimas-de-restriccion","title":"Ejercicio 5. Agregar enzimas de restricci\u00f3n","text":"<p>El \u00faltimo paso es agregar los sitios de corte de enzimas de restricci\u00f3n a los costados de mi secuencia quim\u00e9rica, pero antes de eso tengo que asegurarme que dichas enzimas no tengan sitios de corte dentro de mi secuencia. Existe un programa de EMBOSS para hacer esto llamado <code>remap</code>; sin embargo, dicho programa necesita que previamente le hayamos pasado a EMBOSS una base de datos de enzimas de restricci\u00f3n.</p> <p>14) En los materiales de trabajo van a encontrar dos archivos llamados proto.207 y withrefm.207 que contienen la informaci\u00f3n para crear la base de datos de enzimas de restricci\u00f3n. Copienlos a la carpeta donde est\u00e1n trabajando y corran el comando:</p> <pre><code>rebaseextract -infile withrefm.207 -protofile proto.207\n</code></pre> En replit: Si les da error... <p>En replit, tienen que indicarle mediante una variable de entorno donde van a estar ubicados los archivos con los datos de enzimas de restricci\u00f3n. Para esto, ubicados en la carpeta del ejercicio 5, en la consola de replit corran:</p> <pre><code>mkdir -p EMBOSS_data/REBASE\nexport export EMBOSS_data=\"$(pwd)/EMBOSS_data/REBASE\"\n</code></pre> <p>Luego, corran el comando del ejercicio.</p> <p>Info</p> <p>Solo para que sepan, los archivos proto.207 y withrefm.207 se pueden descargar de aca o aca usando <code>wget</code> (con los links anteriores van a bajar un \u00edndice general y luego tienen que pasarle a <code>wget</code> el link de los archivos que quieran). Dependiendo de cuando vayan a esa p\u00e1gina puede ser que encuentren versiones incluso mas recientes.</p> <p>15) Ahora que ya tenemos la base de datos configurada podemos usar <code>remap</code>, pero antes veamos un poco mas informaci\u00f3n sobre nuestras enzimas de restricci\u00f3n. Usando <code>grep</code> busquen dentro del archivo proto.207 a nuestras enzimas de restricci\u00f3n de inter\u00e9s (BamHI, ApoI y HindIII).</p> <ol> <li>\u00bfQu\u00e9 longitud tienen los sitios de restricci\u00f3n de ApoI, BamHI y HindIII?</li> <li>\u00bfQu\u00e9 piensan que significa el s\u00edmbolo ^ en el sitio de restricci\u00f3n? (pueden buscar informaci\u00f3n sobre dichas enzimas online y se van a dar cuenta enseguida)</li> <li>Observe la secuencia de ApoI, \u00bfnota algo raro? \u00bfQu\u00e9 le parece que indica?</li> </ol> <p>Ahora que sabemos un poco m\u00e1s sobre nuestras enzimas vamos a usar el comando <code>remap</code> con las siguientes opciones:</p> <pre><code>remap -auto -sequence ARCHIVO_ADN_FASTA -width 80 -commercial -sitelen 6 -frame 1 -enzymes all -outfile ARCHIVO_SALIDA_REMAP\n</code></pre> <p>Donde:</p> <ul> <li><code>-auto</code> hace que <code>remap</code> use los par\u00e1metros por defecto y no nos consulte cuales usar.</li> <li><code>-width</code> indica el ancho de secuencia a mostrar en el archivo de salida.</li> <li><code>-commercial</code> analiza solo las enzimas de restricci\u00f3n de uso comercial (entre las que se encuentran nuestras enzimas de inter\u00e9s).</li> <li><code>-sitelen</code> indica el m\u00ednimo de longitud del sitio de restricci\u00f3n (como sabemos que los sitios de restricci\u00f3n de nuestras enzimas de inter\u00e9s tienen 6 amino\u00e1cidos ponemos ese n\u00famero).</li> <li><code>frame</code> indica el marco de lectura a traducir (ya que el output tambi\u00e9n va a dar informaci\u00f3n a nivel prote\u00edna). En nuestro caso el <code>frame</code> es 1 (estamos en la hebra codificante y hay que traducir a partir del primer nucle\u00f3tido).</li> <li><code>enzymes</code> indica los nombres de las enzimas a probar. Si bien podr\u00edamos haber puesto nuestras enzimas de inter\u00e9s, ponemos <code>all</code> para ver m\u00e1s informaci\u00f3n del output.</li> </ul> <p>Corran este comando 3 veces pas\u00e1ndole los archivos correctos y creen los siguientes archivos:</p> <ul> <li>enzimas_FLAG.out</li> <li>enzimas_His.out</li> <li> <p>enzimas_MBP.out</p> </li> <li> <p>\u00bfQu\u00e9 le falta a las secuencias?</p> </li> </ul> Respuesta <p>Le falta la secuencia del cod\u00f3n de STOP despu\u00e9s del TAG!</p> <p>16) Agreg\u00e1 la secuencia faltante despu\u00e9s del TAG.</p> <p>17) Una vez creados, abran los archivos con el Editor de Texto. </p> <ol> <li>\u00bfEntienden lo que simboliza el archivo?</li> <li>Busquen nuestras enzimas de restricci\u00f3n de inter\u00e9s.<ul> <li>\u00bfLas encuentran? \u00bfEn que categor\u00eda est\u00e1 cada una?</li> <li>\u00bfSe pueden usar entonces cualquiera de nuestras enzimas de restricci\u00f3n para insertar nuestra secuencia en un pl\u00e1smido?</li> </ul> </li> <li>\u00bfHay alg\u00fan tag de los tres que est\u00e1bamos considerando que no se pueda usar debido a las enzimas de restricci\u00f3n que elegimos?</li> <li>Elijan el tag que quieren usar, copien su construcci\u00f3n Ecoli-DNA-VpVAN-???-tag.fasta a un nuevo archivo y luego cambien el nombre a secuencia_final.fasta.</li> <li>Abran secuencia_final.fasta en el Editor de Texto y agreguen a mano el sitio de restricci\u00f3n de las enzimas seleccionadas.</li> </ol> <p>\u00a1Felicitaciones, tenemos nuestra secuencia lista para mandar a secuenciar!</p>","tags":["practicos"]},{"location":"practicos/TP02_EMBOSS/#bibliografia","title":"Bibliograf\u00eda","text":"","tags":["practicos"]},{"location":"practicos/TP02_EMBOSS/#online","title":"Online","text":"<ul> <li>Insertar secuencias de ADN en pl\u00e1smidos</li> <li>Cromatograf\u00eda de afinidad</li> </ul>","tags":["practicos"]},{"location":"practicos/TP03_Alineamientos/","title":"Practico Tres","text":"","tags":["practicos"]},{"location":"practicos/TP03_Alineamientos/#tp-3-alineamientos-de-secuencias-de-a-pares","title":"TP 3. Alineamientos de secuencias de a pares","text":"<p> Materiales  Google Colab  Slides</p> <p></p> <p>Atenci\u00f3n: Este TP tiene informe.</p> <p>Atenci\u00f3n: Este TP tiene parcialito.</p>","tags":["practicos"]},{"location":"practicos/TP03_Alineamientos/#objetivos","title":"Objetivos","text":"<ul> <li>Entender el funcionamiento b\u00e1sico del algoritmo de alineamiento de pares de secuencias de Needleman-Wunsch.</li> <li>Aprender a interpretar un Dot-Plot, pudiendo identificar las regiones relevantes que contienen patrones.</li> <li>Comprender los conceptos de identidad, similitud y homolog\u00eda de secuencias, y establecer una clara diferencia entre los mismos. </li> <li>Realizar un alineamiento m\u00faltiple de secuencias e interpretar qu\u00e9 informaci\u00f3n importante se puede extraer del mismo. </li> </ul>","tags":["practicos"]},{"location":"practicos/TP03_Alineamientos/#introduccion","title":"Introducci\u00f3n","text":"<p>El alineamiento de secuencias de a pares comprende la asignaci\u00f3n uno-a-uno de correspondencias entre los elementos que componen dichas secuencias sin alterar su orden. En dicho proceso tres eventos principales pueden tener lugar:</p> <ul> <li>Match (M): Cuando los elementos enfrentados son equivalentes.</li> <li>Mismatch (m): Cuando los elementos correspondientes son diferentes.</li> <li>Gap (g): Cuando un elemento de una secuencia no tiene par en la otra y se enfrenta a un espacio, caracterizado por un gui\u00f3n (-).<ul> <li>Gap open: Cuando se abre un gap.</li> <li>Gap extend: Cuando se agregan gaps a continuaci\u00f3n de otro gap.</li> </ul> </li> </ul> <p>Por ejemplo, si alineamos las secuencias AFGIVHKLIVS y AFGIHKIVS un posible resultado ser\u00eda:</p>  A F G I V H K L I V S  A F G I - H K - I V S  <p>Los gaps no existen en la realidad. NO son un amino\u00e1cido o nucle\u00f3tido m\u00e1s, sino una herramienta que utilizamos para poder alinear.</p> <p>La principal funci\u00f3n de los alineamientos es establecer una medida de similitud entre las secuencias que participan en el mismo. Para ello es necesario definir un sistema de puntuaci\u00f3n que pese cada uno de los eventos que tienen lugar en la construcci\u00f3n del alineamiento. Asimismo, este esquema de puntajes o scoring nos permitir\u00e1 optimizar el alineamiento de forma tal que los algoritmos empleados elijan la correspondencia entre secuencias que maximice el puntaje o score global.</p> <p>Existen varios algoritmos de alineamiento:</p> <ul> <li> <p>Los alineamientos globales (o de Needleman-Wunsch por sus creadores), se realizan apareando todos los elementos de una secuencia con todos los elementos de la otra. Este tipo de alineamientos se utiliza principalmente para comparar dos secuencias que son similares en longitud.</p> </li> <li> <p>Los alineamientos locales (o de Smith-Waterman), parean \u00fanicamente parte de las secuencias y son \u00fatiles para identificar, por ejemplo, dominios en com\u00fan.</p> </li> <li> <p>Los alineamientos mixtos, que combinan los dos anteriores.</p> </li> </ul>","tags":["practicos"]},{"location":"practicos/TP03_Alineamientos/#dynamic-programming","title":"Dynamic programming","text":"<p>Dado un par de secuencias y un sistema de puntuaci\u00f3n o scoring se pueden aplicar diversos algoritmos para encontrar el alineamiento que d\u00e9 el mejor puntaje.</p> <p>El algoritmo m\u00e1s popular utiliza un m\u00e9todo matem\u00e1tico llamado dynamic programming. El mismo consiste en comparar ambas secuencias construyendo una matriz del alineamiento. Brevemente:</p> <ol> <li>Se comienza en el extremo superior izquierdo de la matriz, con un puntaje inicial de 0. </li> <li>En cada paso, se calcula el costo que tiene aparejado desplazarse de una celda a la otra, dado el sistema de puntajes pre-establecido, y se elige la opci\u00f3n m\u00e1s favorable, es decir aquella que maximice el puntaje global del alineamiento. </li> <li>En cada iteraci\u00f3n se guarda el puntaje con el que se lleg\u00f3 a una celda dada y el movimiento que origin\u00f3 dicho camino o path, indicado t\u00edpicamente con una flecha. Una vez que la matriz est\u00e1 completa en su totalidad se puede recorrer hacia atr\u00e1s o realizar un traceback, desde el extremo inferior derecho al superior izquierdo, para reconstruir el alineamiento.</li> </ol> <p>La principal ventaja de este m\u00e9todo es que siempre encuentra el alineamiento \u00f3ptimo entre las secuencias dadas.    Sin embargo, una desventaja es que pueden existir varios alineamientos que satisfagan esta condici\u00f3n.    Otra desventaja es de origen t\u00e9cnica: la exhaustividad con la que el algoritmo realiza la b\u00fasqueda hace que su velocidad dependa de la longitud de las secuencias implicadas, haciendo poco eficiente la b\u00fasqueda de similitud de una secuencia contra una base de datos. Para esto existen diferentes adaptaciones del algoritmo que se ver\u00e1n m\u00e1s adelante.</p>","tags":["practicos"]},{"location":"practicos/TP03_Alineamientos/#ejemplo","title":"Ejemplo","text":"<p>Imaginen que queremos alinear las secuencias TCGCA y TCCA utilizando un esquema de scoring de:</p> <ul> <li>Match: M=1</li> <li>Mismatch: m=-1</li> <li>Gap: g=-2</li> </ul> <p>Para eso ubicamos las secuencias en una matriz, donde cada una de sus dimensiones corresponda a una de las secuencias, tal como se muestra en la siguiente figura. </p> <p></p> <p>Si observamos los paths 1 y 2 dibujados en las matrices de la figura podemos ver que se emplearon distintas estrategias para alinear este par de secuencias. </p> <ul> <li> <p>En 1 se eligi\u00f3 alinear los dos primeros nucle\u00f3tidos TC por la diagonal, luego colocar un gap en la secuencia vertical TCCA y para finalizar se alinearon los nucle\u00f3tidos CA restantes por la diagonal.      </p> </li> <li> <p>En 2 el primer nucle\u00f3tido T de ambas secuencias se aline\u00f3 por la diagonal, luego se coloc\u00f3 un gap en la secuencia vertical TCCA y finalmente se alinearon los 3 nucle\u00f3tidos GCA y CCA restantes por la diagonal.      </p> </li> </ul> <p>Si computamos los puntajes de ambos alineamientos, obtenemos que:</p> <ul> <li>La opci\u00f3n 1 tiene un puntaje de 2. Se propone colocar un \u00fanico gap permitiendo alinear al resto de los nucle\u00f3tidos en ambas secuencias con eventos de match.</li> <li>La opci\u00f3n 2 tiene un puntaje de 0. Las secuencias estudiadas se alinean con 1 gap, 1 mismatch y 3 matches. La estrategia es sub\u00f3ptima en relaci\u00f3n a 1.</li> </ul> <p>Pregunta</p> <p>Si hubi\u00e9semos aplicado la metodolog\u00eda de dynamic programming para realizar un alineamiento global de estas secuencias, \u00bfcu\u00e1l ser\u00eda el path \u00f3ptimo resultante?</p> <p>A priori uno pensar\u00eda que es el path 1, pero hagamos el ejercicio para corroborar si esto es efectivamente as\u00ed. </p> <p>Para comenzar, refresquemos c\u00f3mo funcionaba el m\u00e9todo de dynamic programming.</p> <p></p> <p>Para llegar desde el extremo superior izquierdo (= inicio) de la matriz del alineamiento a la posici\u00f3n marcada con una x podr\u00edamos, hipot\u00e9ticamente, tomar cualquiera de los caminos dibujados en la figura de m\u00e1s arriba. Estos paths dar\u00edan alinemientos diferentes de las secuencias TC con TC. </p> <p>Pregunta</p> <p>Pero... \u00bfcu\u00e1l es el procedimiento iterativo empleado por el m\u00e9todo de dynamic programming para obtener el alineamiento \u00f3ptimo entre dos secuencias?</p> <p>Para llegar a cualquier celda de la matriz, uno puede acceder por, como m\u00e1ximo, 3 direcciones. La idea es siempre moverse en la direcci\u00f3n que maximice el score o puntaje. </p> <p>Veamos que :</p> <ul> <li>un movimiento en la direcci\u00f3n horizontal, de la posici\u00f3n (i, j-1) a la posici\u00f3n (i, j), supone introducir un gap en la secuencia del eje vertical i</li> <li>un movimiento en la direcci\u00f3n diagonal, de la posici\u00f3n (i-1, j-1) a la posici\u00f3n (i, j), supone un match o un mismatch entre los nucle\u00f3tidos enfrentados</li> <li>un movimiento en la direcci\u00f3n vertical, de la posici\u00f3n (i-1, j) a la posici\u00f3n (i, j), supone introducir un gap en la secuencia del eje horizontal j</li> </ul> <p>Teniendo en cuenta la f\u00f3rmula para obtener el score enunciada m\u00e1s arriba, podemos comenzar con nuestro ejercicio!</p> <p>Recordemos que la matriz se llenar\u00e1 iterativamente, comenzando por la celda del extremo superior izquierdo, que tiene un puntaje de 0. </p> <p></p> <p>Para moverse del (0, 0) al (0, 1), hay una s\u00f3la opci\u00f3n, moverse en forma horizontal. Esto significa alinear T con un gap, lo cual da un score de 0 + (-2) = -2. </p> <p></p><pre><code>eje j: T\neje i: -\n</code></pre> Lo mismo pasa al moverse del (0, 0) al (1, 0), hay una s\u00f3la opci\u00f3n, moverse en forma vertical. Esto significa alinear T con un gap, lo cual tambi\u00e9n da un score de 0 + (-2) = -2.  <pre><code>eje j: -\neje i: T\n</code></pre> <p>Para moverse del (0, 0) al (1, 1) hay 3 maneras: </p> <p></p> <p>1. Hacer un movimiento vertical, lo cual da un score de -2 + (-2) = -4</p> <ul> <li>-2 es el puntaje de la celda inicial (0, 1)</li> <li>El movimiento vertical implica colocar un gap: -2</li> </ul> <p>Resultado:</p> <pre><code>eje j: T -\neje i: - T\n</code></pre> <p>2. Hacer un movimiento horizontal, lo cual da un score de -2 + (-2) = -4. Similar al caso anterior:</p> <ul> <li>-2 es el puntaje de la celda inicial (1, 0)</li> <li>El movimiento horizontal implica colocar un gap: -2</li> </ul> <p>Resultado:</p> <pre><code>eje j: - T\neje i: T -\n</code></pre> <p>3. Hacer un movimiento diagonal, lo cual da un score de 0 + (+1). Implica alinear ambos nucl\u00e9otidos!</p> <ul> <li>0 es el puntaje de la celda inicial (0, 0)</li> <li>Hay T en las ambas secuencias. Es un match: +1</li> </ul> <p>Resultado:</p> <pre><code>eje j: T \neje i: T\n</code></pre> <p>Para decidir qu\u00e9 valor ubicamos en la celda simplemente optamos por el que nos d\u00e9 el mayor score, en este caso 1, y se marca el movimiento que lo produjo: un movimiento diagonal.</p> <p>De esta manera podemos seguir completando la matriz, </p> <p></p> <p>Obsevando la \u00faltima celda computada, podemos ver que hay nuevamente 3 maneras de llegar a la misma, </p> <ul> <li> <p>Hacer un movimiento vertical, de (1, 3) a (2, 3): Es decir, introducir un gap en la secuencia horizontal j. Si (1, 3) tiene un score de -3, el nuevo score es: -3 + gap penalty = -3 + (-2) = -5 (flecha en direcci\u00f3n vertical).</p> </li> <li> <p>Hacer un movimiento horizontal, de (2, 2) a (2, 3). Es decir, introducir un gap en la secuencia vertical i. Si (2, 2) tiene un score de 2, el nuevo score es: 2 + gap penalty = 2 + (-2) = 0 (flecha en direcci\u00f3n horizontal).</p> </li> <li> <p>Hacer un movimiento diagonal, de (1, 2) a (2, 3). Es decir, alinear los nucle\u00f3tidos G y C. Si (1, 2) tiene un score de -1, el nuevo score es: -1 + mismatch = -1 + (-1) = -2 (flecha en direcci\u00f3n diagonal).</p> </li> </ul> <p>El m\u00e1ximo de los 3 scores calculados es: max(-5, 0, -2) = 0, que corresponde al puntaje del movimiento horizontal. Entonces colocamos 0 en la celda (2, 3) y una flecha horizontal que indique el movimiento de (2, 2) a (2, 3).</p> <p>Al completar todas las celdas de la matriz, podemos saber cu\u00e1l es el puntaje de la celda ubicada en extremo inferior derecho, que en este caso result\u00f3 ser +2. Este tambi\u00e9n es el puntaje final del alineamiento.</p> <p></p> <p>Para reconstruir el mismo, se parte de la celda ubicada en extremo inferior derecho y se siguen las flechas hasta llegar a la celda de inicio, en el extremo superior izquierdo. </p> <p></p> <p>Las flechas en  rojo  resaltan el path del alineamiento, </p>   eje j: T C G C A  eje i: T C - C A   <p>que podemos corroborar que es id\u00e9ntico al path 1 del ejemplo que se plante\u00f3 inicialmente. </p>","tags":["practicos"]},{"location":"practicos/TP03_Alineamientos/#ejercicio-1","title":"Ejercicio 1","text":"<p>1.1 En grupo, realiz\u00e1 el alineamiento de las secuencias ATTGG con AGATGG, usando el esquema de puntajes: M=1, m=-1, g=-2. </p> <p></p> <p>1.2 Cuando termines el ejercicio anterior pod\u00e9s corrobar la soluci\u00f3n que hallaste ingresando en UniFreiburg-FreiburgRNATools.</p> <p>Segu\u00ed las siguientes instrucciones para usar este recurso web:</p> <p>a. Ingres\u00e1 las dos secuencias que quer\u00e9s alinear en los recuadros de Input Sequence a y Sequence b.  Record\u00e1 que la secuencia que figura en tu matriz en sentido horizontal debe ser ingresada como Sequence b y la que figura en sentido vertical debe ser ingresada como Sequence a.</p> <p>b. Seleccion\u00e1 optimizaci\u00f3n de Similarity. </p> <p>c. Complet\u00e1 los valores de tu esquema de scoring.</p> <p>En el output podr\u00e1s apreciar dos salidas:</p> <ul> <li> <p>A la izquierda, los valores de la matriz de alineamiento. Si cliqueas sobre los valores de la matriz, vas a observar que el valor sobre el que te paraste se colorea en verde, mientras que las celdas que dieron origen a ese valor se colorean en rosa. </p> </li> <li> <p>A la derecha, se observa el alineamiento final, donde un match se esquematiza en con *, un mismatch con | y un gap con _.</p> </li> </ul> <p>1.3 Respond\u00e9 a las siguientes preguntas:</p> <p>1.3.1 Reproduc\u00ed el alineamiento que vimos como ejemplo al inicio (TCGCA con TCCA, esquema de puntajes: M=1, m=-1, g=-2) en la web de la UniFreiburg-FreiburgRNATools</p> <p>\u00bfCu\u00e1ntas soluciones \u00f3ptimas hay para este alineamiento? \u00bfSucede lo mismo para el alineamiento que realizaste en el Ejercicio 1.1? \u00bfPor qu\u00e9?</p> <p>1.3.2 Observ\u00e1 con detenimiento el output del panel de la izquierda (la matriz) </p> <p>Seleccion\u00e1 una celda. \u00bfQu\u00e9 sucede cuando clique\u00e1s en una celda y se colorea en verde y la celda aleda\u00f1a a la misma en rosa? \u00bfA qu\u00e9 corresponde este coloreado o resaltado de las celdas? </p> <p>Observ\u00e1 nuevamente la matriz del alineamiento que obtuviste en 1.2. Cliqu\u00e9a en la celda con puntaje -2 en la posici\u00f3n (A3, T2). Observ\u00e1 que se colorea en verde y dos celdas aleda\u00f1as a la misma en rosa.   \u00bfEntend\u00e9s qu\u00e9 significa esto? \u00bfPod\u00e9s relacionarlo con los dos caminos \u00f3ptimos posibles que existen para este alineamiento? </p>","tags":["practicos"]},{"location":"practicos/TP03_Alineamientos/#dot-plots","title":"Dot-Plots","text":"<p>Los dot-plots son representaciones gr\u00e1ficas que dan un pantallazo sobre la similitud entre dos secuencias. En ellos se pueden identificar patrones que aporten informaci\u00f3n sobre la relaci\u00f3n entre ambas secuencias. La forma de obtener uno es muy sencilla: se establece una matriz donde cada elemento de una de las secuencias se corresponde con una fila y los de la otra con una columna. Acto seguido se procede a colorear cada celda donde los caracteres correspondientes a fila y columna sean equivalentes. Por ejemplo:</p> <p></p> <p>Nosotros podemos utilizar la herramienta de EMBOSS <code>dotmatcher</code> para generar nuestros propios plots. Para esto, vamos a usar el Google colab que se encuentra al lado de los materiales del TP.</p> <p>Recordatorio</p> <p>Para ver qu\u00e9 par\u00e1metros toma de entrada la funci\u00f3n, se puede ver la ayuda corriendo <code>dotmatcher -h</code> en bash.</p>","tags":["practicos"]},{"location":"practicos/TP03_Alineamientos/#ejercicio-2","title":"Ejercicio 2","text":"<p>2.1 Utiliz\u00e1 la secuencia HS-ch11-fragment.fasta que se encuentra en la carpeta data para compararla contra s\u00ed misma. Esta secuencia es un peque\u00f1o fragmento del cromosoma 1 de Homo sapiens y la vamos a utilizar \u00fanicamente para ver algunos de los patrones que podemos encontrar en un dotplot. </p> <p>Gener\u00e1 un dotplot utilizando la secuencia HS-ch11-fragment.fasta contra s\u00ed misma.</p> <pre><code>!dotmatcher -graph pdf HS-ch1-fragment.fasta HS-ch1-fragment.fasta\n</code></pre> <p>Atenci\u00f3n</p> <p>Recuerden abrir el archivo HS-ch11-fragment.fasta y chequear que la secuencia es de ADN. Es una buena pr\u00e1ctica conocer qu\u00e9 hay en los archivos que vamos a utilizar. </p> <p>\u00bfQu\u00e9 pod\u00e9s interpretar de este dotplot?</p> <p>La verdad es que el plot es bastante ruidoso, esto sucede muy a menudo en secuencias gen\u00f3micas ya que la cantidad de caracteres que componen las secuencias es muy limitada (solo 4) y por ello hay muchas ocurrencias y por lo tanto muchos puntos. Para limpiar el plot y quedarnos con los matches m\u00e1s significativos podemos jugar con dos par\u00e1metros:</p> <ul> <li>windowsize: Tama\u00f1o de ventana</li> <li>threshold: Umbral de ocurrencia</li> </ul> <p>Esto quiere decir que <code>dotmatcher</code> s\u00f3lo va a poner un punto cuando un fragmento del largo windowsize contenga un score mayor a threshold. Por ejemplo:</p> <pre><code>!dotmatcher -graph pdf -windowsize 50 -threshold 20 HS-ch1-fragment.fasta HS-ch1-fragment.fasta\n</code></pre> <p>Si aument\u00e1s estos par\u00e1metros pod\u00e9s ir eliminando fragmentos que corresponden a secciones compartidas m\u00e1s cortas, sin embargo existe una relaci\u00f3n de compromiso, utilizar tama\u00f1o de ventana y umbral muy grandes nos llevan a perder informaci\u00f3n por lo que hay que seleccionarlos con cuidado. Aqui hay algunos patrones con los que te pod\u00e9s encontrar en este tipo de plots:</p> <p></p> <p>a) Match perfecto. b) Repeticiones. c) Pal\u00edndromo. d) Repeticiones invertidas. e) Zonas de baja complejidad (microsatelites). f) Zonas altamente repetitivas (minisatelites). g) Secuencias con alta conservaci\u00f3n. h) Inserci\u00f3n o deleci\u00f3n.  </p> <p>2.2 Cambi\u00e1 los par\u00e1metros windowsize y threshold hasta obtener un plot que te parezca adecuado. \u00bfQu\u00e9 pod\u00e9s interpretar del mismo? Identific\u00e1 patrones.</p>","tags":["practicos"]},{"location":"practicos/TP03_Alineamientos/#identidad-similitud-y-homologia","title":"Identidad, Similitud y Homolog\u00eda","text":"<p>Los t\u00e9rminos identidad, similitud y homolog\u00eda se suelen utilizar como sin\u00f3nimos por muchos investigadores, sin embargo no lo son.</p> <ul> <li> <p>La identidad es una es una caracter\u00edstica cuantitativa de un par de secuencias, donde se cuenta cu\u00e1ntos elementos (residuos, nucle\u00f3tidos, amino\u00e1cidos etc) son id\u00e9nticos entre ambas secuencias despu\u00e9s de alinearlas. </p> </li> <li> <p>La similitud es una caracter\u00edstica cuantitativa de un par de secuencias, donde se establece en qu\u00e9 grado estas se parecen (por ejemplo aplicando los algoritmos antes vistos, utilizando un sistema de puntaje) despu\u00e9s de alinearlas. </p> </li> <li> <p>La homolog\u00eda, por otro lado, es una caracter\u00edstica cualitativa, dos secuencias SON o NO SON hom\u00f3logas. Homolog\u00eda implica espec\u00edficamente que el par de secuencias estudiadas provienen de un mismo ancestro com\u00fan. Esta afirmaci\u00f3n es completamente hipot\u00e9tica, ya que, salvo en contados casos, no se puede corroborar. Uno puede inferir que este es el caso dado la similitud observada en las secuencias actuales, sin tener acceso a las secuencias ancestrales.</p> </li> </ul> <p>Atenci\u00f3n</p> <p>Decir que un par de secuencias tiene N% de homolog\u00eda es TOTALMENTE incorrecto.</p> <p>A partir de esta relaci\u00f3n entre similitud y homolog\u00eda se pueden inferir relaciones entre diferentes especies, buscar posibles funciones de una secuencia desconocida, etc.</p>","tags":["practicos"]},{"location":"practicos/TP03_Alineamientos/#ejercicio-3","title":"Ejercicio 3","text":"<p>3.1 Determinar qu\u00e9 especies est\u00e1n m\u00e1s relacionadas utilizando la ribonucleasa pancre\u00e1tica de caballo (Equus caballus), ballena enana (Balaenoptera acutorostrata) y canguro rojo (Macropus rufus).</p> <p>3.1.1 Utiliz\u00e1 la herramienta de alineamiento global de EMBOSS <code>needle</code> (pueden leer el manual para ver que opciones admite) para comparar las tres secuencias.   </p> <p></p><pre><code>needle -gapopen 10 -gapextend 1 -asequence *secuencia_1* -bsequence *secuencia_2* -outfile *salida*\n</code></pre> 3.1.2 Observ\u00e1 e interpret\u00e1 las salidas obtenidas. <ul> <li>\u00bfQu\u00e9 secuencias son m\u00e1s similares? \u00bfTiene sentido el resultado obtenido?</li> </ul> <p>3.1.3 Analiz\u00e1 \u00e1rbol filogen\u00e9tico de la Fig. 1 del paper de O'Leary et al., 2013.  Sabiendo que los caballos y las ballenas pertenecen al clado Euungulata y los canguros al clado Marsupialia, ubic\u00e1 estos clado en el \u00e1rbol.</p> <ul> <li>\u00bfEsta informaci\u00f3n coincide con los resultados que obtuviste en 3.1.3?</li> </ul> <p></p> <p>3.2 Realiz\u00e1 el mismo procedimiento pero esta vez para determinar si los mamuts (Mammuthus primigenius) son m\u00e1s cercanos a los elefantes africanos (Loxodonta africana) o asi\u00e1ticos (Elephas maximus) utilizando la secuencia de la cadena alfa de la hemoglobina.  </p> <p>3.2.1 \u00bfQu\u00e9 te sugieren los resultados obtenidos?</p> <p>3.2.2 \u00bfEs relevante la diferencia hallada?</p> <p>3.2.3 \u00bfC\u00f3mo har\u00edas para sacar conclusiones m\u00e1s fuertes sobre las relaciones filogen\u00e9ticas entre los organismos estudiados en los ejercicios 3.1 y 3.2?</p> <p></p>","tags":["practicos"]},{"location":"practicos/TP03_Alineamientos/#alineamientos-multiples","title":"Alineamientos m\u00faltiples","text":"<p>Un alineamiento m\u00faltiple (MSA) involucra tres o m\u00e1s secuencias biol\u00f3gicas. Debido a que la tarea de alinear m\u00faltiples secuencias de largos biol\u00f3gicamente significativos suele ser muy demandante en t\u00e9rminos de recursos computacionales y tiempos de ejecuci\u00f3n estos requieren metodolog\u00edas m\u00e1s sofisticadas para llevarse a cabo. Por ello la mayor\u00eda de los programas disponibles para realizar MSA utiliza heur\u00edsticas en vez de algoritmos de optimizaci\u00f3n global.</p> <p>Heur\u00edstica</p> <p>Es una estrategia que busca resolver un problema m\u00e1s simple cuya soluci\u00f3n se interseca con la soluci\u00f3n de un problema m\u00e1s complejo. Generalmente esto implica que no es seguro encontrar el mejor resultado pero s\u00ed una soluci\u00f3n que sea aceptable. Las heur\u00edsticas se aplican con frecuencia en computaci\u00f3n para poder resolver problemas que, por su complejidad, ser\u00edan imposibles de abordar dados los limitados recursos con los que se cuentan.</p> <p>Dadas las secuencias de amino\u00e1cidos de un set de prote\u00ednas que se quieren comparar, el MSA muestra los residuos de cada prote\u00edna en una fila junto con los gaps que le correspondan de tal manera que todos los residuos \"equivalentes\" se encuentren en la misma columna. La utilidad de esta equivalencia depende de quien mire el alineamiento:</p> <ul> <li>Alguien que hace una filogenia puede enfocarse en que comparten un ancestro com\u00fan;</li> <li>Alguien que hace biolog\u00eda estructural puede enfocarse en que son residuos en posiciones an\u00e1logas de una estructura proteica;</li> <li>Alguien que hace biolog\u00eda molecular puede enfocarse en el rol funcional de esos residuos en la prote\u00edna.</li> </ul> <p>En cada caso un MSA provee un pantallazo sobre las restricciones evolutivas, estructurales o funcionales que caracterizan un set de prote\u00ednas de una manera visual e intuitiva.</p> <p></p> <p>Un pipeline t\u00edpico para realizar un MSA ser\u00eda:</p> <ol> <li>Formular la pregunta que se quiere contestar. Por ejemplo,  \"\u00bfQu\u00e9 estructura secundaria adopta X regi\u00f3n de mi prote\u00edna de inter\u00e9s?\"</li> <li>Obtener secuencias que puedan contestar a mi pregunta. Por ejemplo, secuencias que est\u00e9n relacionadas a mi prote\u00edna de inter\u00e9s.</li> <li>Utilizar alguno de los programas disponibles para llevar a cabo el MSA. Por ej. EMBOSS</li> <li>Realizar ajustes manuales para corregir posibles errores de los algoritmos de alineamiento.</li> </ol>","tags":["practicos"]},{"location":"practicos/TP03_Alineamientos/#ejercicio-4-adicional","title":"Ejercicio 4 (Adicional)","text":"<p>La gp120 es una prote\u00edna que recubre al virus del HIV y facilita su uni\u00f3n e ingreso a la c\u00e9lula que infecta (linfocitos CD4+) Entre nuestros archivos contamos con un multifasta (gp120.fasta) que contiene 27 secuencias de gp120 de HIV-1, HIV-2 y SIV. Estas prote\u00ednas contienen 9 puentes disulfuro conservados. Tambi\u00e9n es de inter\u00e9s el loop V3, una porci\u00f3n expuesta de la prote\u00edna, conocido target de anticuerpos el cual constituye una regi\u00f3n hipervariable dada la presi\u00f3n selectiva a la que se ve sometido. </p> <p> Pueden ver la disposici\u00f3n de las distintas regiones de la gp120 en el siguiente esquema:  </p> <p>Figure 1. Glicoprote\u00edna gp120 de HIV</p> <p> Mathys L, Balzarini J. Several N-Glycans on the HIV Envelope Glycoprotein gp120 Preferentially Locate Near Disulphide Bridges and Are Required for Efficient Infectivity and Virus Transmission. PLoS One. 2015 Jun 29;10(6):e0130621. doi: 10.1371/journal.pone.0130621. PMID: 26121645; PMCID: PMC4488071.</p> <p></p> <p>4.1 Utiliz\u00e1 las herramientas de EMBOSS para realizar un alineamiento m\u00faltiple con las secuencias de gp120 (recuerden que para buscar herramientas pueden usar <code>wossname</code>)  </p> Pista <p>El comando a utilizar es <code>emma</code>. Para ver la ayuda, tipe\u00e1 <code>emma -help</code> en la terminal.</p> <p>4.2 Utiliz\u00e1 el comando <code>showalign</code> de EMBOSS para obtener una mejor visualizaci\u00f3n del alineamiento.  </p> <p>4.3 Observ\u00e1 el alineamiento, como primer control podemos corroborar que las 18 Ciste\u00ednas (C) est\u00e9n bien alineadas.  </p> <p>4.4 Utiliz\u00e1 el esquema de gp120 para identificar diversas regiones ya sea conservadas o muy variables (Estructuras, loops, etc.) </p> <p>Tip</p> <p>Not\u00e1 que las posiciones en el alineamiento cuentan gaps por lo que no se corresponden exactamente con el esquema. Utiliz\u00e1 las posiciones de las ciste\u00ednas conservadas para identificar diferentes regiones.</p>","tags":["practicos"]},{"location":"practicos/TP03_Alineamientos/#ejercicio-a-informar","title":"Ejercicio a informar","text":"<p>Info</p> <p>Fecha l\u00edmite de entrega: Jueves, 5 de septiembre 2025, 23:59hs.</p> <p> Materiales</p>","tags":["practicos"]},{"location":"practicos/TP03_Alineamientos/#enunciado","title":"Enunciado","text":"<p>Usted trabaja en un laboratorio que estudia distintos aspectos del virus del papiloma humano (HPV). Como parte de su colaboraci\u00f3n con Servicio Virus Oncog\u00e9nicos del Instituto Nacional de Enfermedades Infecciosas ANLIS \u201cDr. Carlos G. Malbr\u00e1n\u201d, todos los d\u00edas se obtienen nuevas secuencias de aislamientos de HPV. Recientemente, el servicio comparti\u00f3 con su jefe un nuevo aislamiento del virus, y su jefe le ha encomendado a usted la tarea de analizar dicho aislamiento para extraer toda la informaci\u00f3n bioinform\u00e1tica posible de su colecci\u00f3n de datos.</p>","tags":["practicos"]},{"location":"practicos/TP03_Alineamientos/#breve-descripcion-del-virus-del-papiloma-humano","title":"Breve descripci\u00f3n del virus del papiloma humano","text":"<p>El virus del papiloma humano (VPH o HPV, del ingl\u00e9s human papillomavirus) es el virus responsable de una de las infecciones de transmisi\u00f3n sexual m\u00e1s frecuentes en todo el mundo. Se estima que 4 de cada 5 personas van a contraer uno o varios de los tipos de VPH en alg\u00fan momento de sus vidas.  Existen alrededor de 100 tipos de HPV, de los cuales 40 afectan la zona genital y anal. Los distintos tipos de HPV se clasifican en dos grandes grupos, denominados de alto y bajo riesgo oncog\u00e9nico. Los HPV de bajo riesgo suelen estar asociados con lesiones benignas o de bajo grado, mientras que las infecciones con HPV de alto riesgo oncog\u00e9nico pueden evolucionar a c\u00e1ncer, siendo el c\u00e1ncer de cuello de \u00fatero el m\u00e1s frecuente. Los tipos de HPV de alto riesgo m\u00e1s comunes son el 16 y 18. La determinaci\u00f3n del tipo de HPV se realiza con distintas t\u00e9cnicas de biolog\u00eda molecular que permiten identificar diferencias gen\u00f3micas. Los HPV son grupos diversos de virus ADN pertenecientes a la familia de los Papillomaviridae. Las diferencias entre estos virus a nivel de secuencia de ADN permiten clasificarlos (o genotipificarlos), lo cual resulta muy importante debido a la diferencia de patolog\u00edas que pueden causar los distintos tipos de HPV.</p>","tags":["practicos"]},{"location":"practicos/TP03_Alineamientos/#trabajo-a-realizar","title":"Trabajo a realizar","text":"<p>Usted cuenta con un conjunto de secuencias que utiliza normalmente en su laboratorio, organizadas de la siguiente manera:</p> Nombre del archivo Descripci\u00f3n all_sequences.fasta Archivo multifasta con 11 secuencias de distintos tipos de HPV all_sequences.gb Archivo GenBank. Almacena las mismas 11 secuencias que el archivo fasta, con informaci\u00f3n adicional (como anotaciones de prote\u00ednas) conjunto_de_secuencias Archivo de hoja de c\u00e1lculo con informaci\u00f3n sobre la secuencia y el organismo al que pertenece <p>Pero\u2026 Cuando usted recibe los datos (<code>secuencia_incognita.fasta</code>) se da cuenta que el archivo no ha sido nombrado correctamente. Este tipo de errores son comunes debido a la gran cantidad de secuencias que maneja el Servicio Virus Oncog\u00e9nico, ya que este servicio act\u00faa como Laboratorio Nacional de Referencia del Ministerio de Salud (MSAL) para el virus papiloma humano (HPV) y el virus de Epstein-Barr (EBV). </p> <p>Para solucionar el problema, decide aplicar las herramientas que aprendi\u00f3 en el trabajo pr\u00e1ctico N3 de bioinform\u00e1tica cuando era estudiante y procede a:</p> <ol> <li> <p>Verificar que la secuencia que le mandaron corresponde al virus de HPV y no a otro. Para esto, hay que comparar la secuencia del nuevo aislamiento con alguna secuencia de su conjunto de secuencias. \u00bfPertenece el nuevo aislamiento a un HPV?</p> <p>Tip</p> <p>Recuerden usar par\u00e1metros adecuados de ventana y umbral</p> </li> <li> <p>Debido a la importancia a nivel diagn\u00f3stico, ahora quiere saber qu\u00e9 tipo de HPV es. Para esto decide determinar el % de similitud que posee su secuencia con cada una de las secuencias  con las que usted trabaja com\u00fanmente. \u00bfPuede decir que tipo de virus es en base a la informaci\u00f3n que posee?</p> <p>Tip</p> <p>Si necesitan dividir el archivo <code>All_Sequences.fasta</code> en archivos individuales pueden buscar wossname split. </p> </li> <li> <p>Ahora comparen el tipo de HPV del aislamiento con otros del mismo riesgo y de distinto nivel de riesgo. \u00bfEncuentran alguna regi\u00f3n que pueda ser \u00fatil para genotipificaci\u00f3n? \u00bfQu\u00e9 eventos observan en los dotplots cuando comparan HPV de igual y de distinto riesgo?</p> </li> </ol> <p>Extra! (y por ende opcional)</p> <p>Para resolver los puntos 2 y 3 se puede hacer un script de bash tanto para el alineamiento, para ver los % de similitud y para crear dotplots. El par\u00e1metro que tienen que agregar a dotmatcher para que el archivo generado sea un pdf de nombre \u201cgrafico.pdf\u201d es -graph pdf -goutfile grafico. Si lo logran (o si lo intentan), los invito a incluirlo en el trabajo pr\u00e1ctico (a\u00fan cuando no les sali\u00f3).</p>","tags":["practicos"]},{"location":"practicos/TP04_Busqueda_por_similitud/","title":"Practico Cuatro","text":"","tags":["practicos"]},{"location":"practicos/TP04_Busqueda_por_similitud/#tp-4-busqueda-de-secuencias-por-similitud","title":"TP 4. B\u00fasqueda de secuencias por similitud","text":"<p> Materiales  Google Colab  Slides</p> <p></p>","tags":["practicos"]},{"location":"practicos/TP04_Busqueda_por_similitud/#objetivos","title":"Objetivos","text":"<ul> <li>Familiarizarse con el uso de programas de b\u00fasqueda de secuencias en bases de datos (BLAST y FASTA), y en particular con el uso de estos programas en google colab.</li> <li>Familiarizarse con la visualizaci\u00f3n de histogramas que arroja FASTA.</li> <li>Familiarizarse con el uso de par\u00e1metros estad\u00edsticos en relaci\u00f3n a la b\u00fasqueda en bases de datos.</li> </ul> <p>\u00a1Antes de comenzar!</p> <p>Este TP lo vamos a realizar con google colab. Los programas que vamos a utilizar son: blastall, blastcl3, formatdb y fastacmd (NCBI-Toolkit), fasta, tfasta, fastx, tfastx, fasty, tfasty, ssearch, prss (FASTA program package). </p> <p>Para instalarlos, ejecuten en su colab las celdas que se encuentran en la secci\u00f3n M\u00f3dulos, programas y directorios.</p>","tags":["practicos"]},{"location":"practicos/TP04_Busqueda_por_similitud/#introduccion-a-bases-de-datos-de-proteinas","title":"Introducci\u00f3n a Bases de Datos de Prote\u00ednas","text":"<p>La mayor base de datos de Uniprot es UniProtKB (UniProt KnowledgeBase) que est\u00e1 dividida en dos secciones: TrEMBL y Swiss-Prot.</p> <ul> <li> <p>TrEMBL es una recolecci\u00f3n de prote\u00ednas anotadas autom\u00e1ticamente que en su mayor\u00eda, aunque no de manera exclusiva, fueron obtenidas a partir de la traducci\u00f3n de secuencias nucleot\u00eddicas codificantes (CoDing Sequences, CDS) disponibles en GenBank.</p> Recordatorio <p>Una secuencia codificante (CDS) es una regi\u00f3n de ADN o ARN cuya secuencia determina la secuencia de amino\u00e1cidos en una prote\u00edna. No se debe confundir con un marco abierto de lectura (Open Reading Frame, ORF) que es una regi\u00f3n continua de codones de ADN que empiezan con un cod\u00f3n de inicio y termina con un cod\u00f3n stop. Todos los CDS son ORFs pero no todos los ORFs son CDS, por ejemplo, los ORFs incluye a los intrones.</p> </li> <li> <p>Swiss-Prot es una base de datos de prote\u00ednas que fueron revisadas y anotadas manualmente por un curador/a experto/a. Por lo tanto, Swiss-Prot contiene la informaci\u00f3n de m\u00e1s alta calidad para secuencias de prote\u00ednas.</p> </li> </ul> <p>TrEMBL brinda los datos crudos para que los curadores de Swiss-Prot los revisen. Por lo tanto, TrEMBL tiene m\u00e1s entradas que Swiss-Prot, pero carece de la anotaci\u00f3n manual de un experto.</p> <p>En este TP trabajaremos con Swiss-Prot.</p>","tags":["practicos"]},{"location":"practicos/TP04_Busqueda_por_similitud/#introduccion-a-blast","title":"Introducci\u00f3n a BLAST","text":"<p>BLAST busca secuencias similares a una secuencia query en una base de datos de secuencias, utilizando distintas estrategias de b\u00fasqueda:</p> <ul> <li>BLASTn: compara una secuencia nucleot\u00eddica query contra una base de datos de secuencias nucleot\u00eddicas.</li> <li>BLASTx: compara una secuencia nucleot\u00eddica query, que es traducida en los 6 posibles marcos de lectura (resultando en 6 secuencias proteicas), contra una base de datos de secuencias proteicas. </li> <li>tBLASTn: compara una secuencia proteica query contra las traducciones (6 posibles marcos de lectura) de una base de datos de secuencias nucleot\u00eddicas. </li> <li>BLASTp: compara una secuencia proteica query contra una base de datos de secuencias proteicas.</li> </ul> <p>BLAST, tal como es distribu\u00eddo por el NCBI, se encuentra disponible mediante el comando <code>blastall</code>. Este comando necesita como m\u00ednimo tres argumentos para realizar una b\u00fasqueda:</p> <ul> <li><code>-i</code> una secuencia query (recordar, i = input) </li> <li><code>-d</code> una base de datos con secuencias (recordar, d = database) </li> <li><code>-p</code> el tipo de busqueda (p = programa: blastp, blastn, blastx, etc.) </li> </ul> Tip <p>Para ver una lista de los argumentos que acepta <code>blastall</code> prueben correr el comando sin argumentos. Si esto no les funciona pueden ver todos los argumentos haciendo click aqu\u00ed. Para una lista detallada de los comandos que acepta cada programa, pueden consultar la p\u00e1gina del NCBI.</p> Recordatorio: Estad\u00edstica de los Alineamientos <p>\u00bfQu\u00e9 es un Expect value o E-value?</p> <p>El E-value (E) es un par\u00e1metro que describe el n\u00famero de hits que uno espera encontrar por azar cuando est\u00e1 buscando en una base de datos de un tama\u00f1o particular. Este disminuye exponencialmente a medida que el Score (S) del alineamiento aumenta. Esencialmente el E-value describe el ruido de fondo aleatorio que est\u00e1 presente al realizar una b\u00fasqueda en una base de datos de secuencias. </p> <p>Cuanto m\u00e1s peque\u00f1o sea el E-value, o m\u00e1s cercano a 0, m\u00e1s significativo resulta ser nuestro hit. Sin embargo, siempre hay que tener en cuenta que los alineamientos cortos tienen E-values relativamente altos, y esto es debido a que el E-value tiene en cuenta el largo de la secuencia query. Estos E-values tienen sentido porque las secuencias cortas tienen una probabilidad m\u00e1s alta de estar presentes en una base de datos puramente por azar.</p> <p>El E-value es un par\u00e1metro conveniente para establecer un umbral de significancia a la hora de reportar los resultados de una b\u00fasqueda en una base de datos. Uno puede cambiar el E-value umbral al listar los resultados de una b\u00fasqueda con BLAST. </p> <p>Recordemos la f\u00f3rmula para calcular el E-value (E) de la te\u00f3rica.</p> <p></p>","tags":["practicos"]},{"location":"practicos/TP04_Busqueda_por_similitud/#ejercicio-1","title":"Ejercicio 1","text":"<p>1.1 Como primer ejemplo podemos usar la secuencia xlrhodop.pep para realizar una b\u00fasqueda contra Swiss-Prot. Como estamos trabajando con una secuencia y una base de datos de prote\u00ednas, usamos <code>blastp</code> para realizar la busqueda: </p> <pre><code>!blastall -p blastp -i xlrhodop.pep -d ~/Swissprot_db/Swissprot.fasta\n</code></pre> <p>Atenci\u00f3n</p> <p>Recuerden que para indicarle a colab que es un comando de bash, tienen que utilizar el prefijo <code>!</code>.</p> <p>Atenci\u00f3n</p> <p>Este comando no se ejecutar\u00e1 correctamente si las secuencia xlrhodop y la base de datos Swiss-Prot no est\u00e1n en los directorios correctos. Chequeen donde est\u00e1 la base de datos, y si el comando no se ejecuta, especifiquen el camino o path completo.</p> <p>En este ejemplo, el resultado de la b\u00fasqueda es volcado en la consola (stdout). Para que el resultado aparezca en un archivo, podemos redireccionar stdout (usando <code>&gt;</code>, ver TP01-Linux) o usar la opcion <code>-o</code> (output).</p> <pre><code>!blastall -p blastp -i xlrhodop.pep -d ~/Swissprot_db/Swissprot.fasta -o xlrhodop.blastp\n</code></pre> <p>Pueden ver el resultado del <code>blastp</code>, por ejemplo, revisando las n l\u00edneas del principio (head) o del final (tail):</p> <pre><code>!head -n 10 xlrhodop.blastp\n</code></pre> <ul> <li> <p>Inspeccionen el archivo y respondan: \u00bfQu\u00e9 indican las \u00faltimas l\u00edneas de este archivo?</p> </li> <li> <p>Si recuerda c\u00f3mo se computa el E-value, \u00bfcu\u00e1l es la relevancia de reportar el tama\u00f1o de la base de datos (number of letters, number of sequences)?</p> </li> </ul> <p></p> <p>Nota</p> <p>El t\u00e9rmino neighboring words refiere a palabras \"vecinas\" o \"cercanas\", es decir con alta similitud de secuencia. </p> <p>Atenci\u00f3n</p> <p>Si corren <code>blastp</code> s\u00f3lo, es decir sin invocar primero al comando <code>blastall</code>, van a poder realizar las mismas b\u00fasquedas pero los nombres de los argumentos del comando <code>blastp</code> s\u00f3lo difieren de los de <code>blastall -p blastp</code>. Por lo tanto, no les recomendamos correrlo de esta forma.</p> <p>1.2 Explore las siguientes opciones del programa <code>blastp</code>:  </p> <ul> <li><code>-G</code> Costo del gap open (default: 11)</li> <li><code>-E</code> Costo del gap extend (default: 1)   </li> <li><code>-W</code> Tama\u00f1o de la ktupla. (default: 3, puede variar entre 2 y 7)</li> </ul> <p>Atenci\u00f3n</p> <p>Hay tuplas de valores permitidos para los argumentos <code>-G</code> y <code>-E</code>, no cualquier combinaci\u00f3n de costos es v\u00e1lida.</p> <ul> <li>Pruebe con distintas combinaciones de estos par\u00e1metros y preste atenci\u00f3n al impacto que esto tiene en los alineamientos reportados.</li> </ul> <p>1.2.1 Responda a las siguientes preguntas:</p> <p>a. Si observa los primeros 20 hits de su b\u00fasqueda, \u00bfpuede detectar alguna diferencia en los alineamientos reportados si cambia los par\u00e1metros indicados m\u00e1s arriba?</p> <p>b. A medida que va descendendiendo en la lista de los hits reportados (menor Score, mayor E-value), \u00bfqu\u00e9 patrones puede observar en los alineamientos que arroja BLAST?</p> <p>c. Tome como ejemplo dos de los siguientes hits: </p> <pre><code>- OPSD_CARAU \n- OPN4A_DANRE\n- OPN4_RUTRU\n</code></pre> <p>y complete para cada uno de los alineamientos reportados la siguiente tabla, teniendo en cuenta los diferentes costos de gap open y gap extend propuestos. </p> N\u00famero total de gaps Extensi\u00f3n de la regiones con gaps Gap open: 6 + gap extend: 2 Gap open: 13 + gap extend: 1 <p>1.2.2 Opcional: Evaluando el impacto del par\u00e1metro longitud de la k-tupla.</p> <p>Responda a las siguientes preguntas:</p> <p>Para una misma combinaci\u00f3n de costos para gap open y gap extend (pueden usar los valores default):</p> <p>a. \u00bfQu\u00e9 sucede con los valores de ktupla=2 y ktupla=7 ? </p> <p>b. \u00bfCu\u00e1l b\u00fasqueda es la que tarda m\u00e1s? \u00bfCu\u00e1l menos? </p> <p>c. \u00bfCu\u00e1ntas secuencias devuelven?</p> <p>Para los m\u00e1s curiosos, las respuestas a estas preguntas pueden hallarlas en el siguiente link.</p>","tags":["practicos"]},{"location":"practicos/TP04_Busqueda_por_similitud/#introduccion-a-fasta","title":"Introducci\u00f3n a FASTA","text":"<p>Curiosidad</p> <p>El nombre FASTA proviene de \"FAST-All\" porque funciona con cualquier alfabeto, esto significa que es una extensi\u00f3n de las herramientas originales para realizar alineamientos \"FAST-P\" (prote\u00ednas) y \"FAST-N\" (nucle\u00f3tidos). El formato \".fasta\" para almacenar secuencias de prote\u00ednas o nucle\u00f3tidos se origina con el software FASTA, es por esto que llevan el mismo nombre. </p> <p>Al igual que BLAST, FASTA necesita los mismos tres argumentos obligatorios. Sin embargo, el paquete FASTA provee un comando ejecutable para cada tipo de b\u00fasqueda.</p> <p>Comparaci\u00f3n de programas en el paquete FASTA</p> <p>FASTA permite comparar una secuencia proteica contra una base de datos de prote\u00ednas o una secuencia de ADN contra una base de datos de ADN (Pearson and Lipman, 1988, Pearson, 1996). La velocidad de la b\u00fasqueda y la selectividad est\u00e1n controladas por el par\u00e1metro ktup (word size). Para comparaciones entre prote\u00ednas, ktup=2 es el default, ktup=1 es m\u00e1s sensible pero m\u00e1s lento. Para comparaciones entre secuencias de ADN, ktup=6 es el default, ktup=3 o ktup=4 proveen una mayor sensibilidad, ktup=1 debe ser utilizado para oligonucle\u00f3tidos (secuencias query de ADN de longitud &lt; 20).</p> <ul> <li> <p>ssearch: Compara una secuencia proteica contra una base de datos de prote\u00ednas o una secuencia de ADN contra una base de datos de ADN usando el algoritmo de Smith-Waterman (Smith and Waterman, 1981). </p> </li> <li> <p>fastx y fasty: Compara una secuencia de ADN contra una base de datos de prote\u00ednas.</p> <ul> <li> <p>fasty compara la secuencia de ADN traducida en 3 marcos de lectura, permitiendo gaps y frameshifts (cambios en el marco de lectura). Es m\u00e1s lento que fastx pero produce mejores alineamientos para secuencias de baja calidad ya que los frameshifts se admiten entre codones. </p> </li> <li> <p>fastx usa un algoritmo m\u00e1s simple y r\u00e1pido para alineamientos que permiten frameshifts s\u00f3lo entre codones. </p> </li> </ul> </li> <li> <p>tfastx: Compara una secuencia proteica a una base de datos de ADN, calculando las similaridades con frameshifts para las orientaciones forward y reverse.  </p> </li> <li> <p>tfasta: Compara una secuencia proteica a una base de datos de ADN, calculando las similaridades (sin frameshifts) para los 3 forward y los 3 reverse ORFs. tfastx es preferido debido a que calcula las similaridades teniendo en cuenta frameshifts. </p> </li> <li> <p>fasts: Compara un set peque\u00f1o de p\u00e9ptidos, obtenidos por ejemplo de un experimento de espectrometr\u00eda de masas, contra una base de datos de prote\u00ednas (fasts) o de ADN (tfasts). </p> </li> </ul>","tags":["practicos"]},{"location":"practicos/TP04_Busqueda_por_similitud/#ejercicio-2","title":"Ejercicio 2","text":"<p>Ahora corramos la misma b\u00fasqueda del ejemplo anterior usando FASTA: </p> <p></p><pre><code>!fasta -H Data/xlrhodop.pep Data/Swissprot_db/Swissprot.fasta &gt; xlrhodop.fasta\n</code></pre> Para interpretar correctamente el histograma que FASTA da como output tenemos que pensar que est\u00e1 apaisado (o rotado 90 grados en sentido horario) con respecto al t\u00edpico histograma que muestra la distribuci\u00f3n de scores para todas las secuencias halladas. Esto se ilustra en la siguiente figura. <p></p> <p>2.1 Responda a las siguientes preguntas con respecto al histograma apaisado que obtuvo como output:</p> <p>a. \u00bfQu\u00e9 valores se representan en el eje y (vertical)?</p> <p>b. \u00bfQu\u00e9 valores se representan en el eje x (horizontal)?</p> <p>c. \u00bfQu\u00e9 representan los asteriscos \"*\" ?</p> <p>d. \u00bfQu\u00e9 representan los iguales \"=\" ? \u00bfCu\u00e1nto representa el \"=\" ?</p> <p>e. \u00bfQu\u00e9 es la primera columna de n\u00fameros?, \u00bfpor qu\u00e9 hay un \"&lt;\" en la primera l\u00ednea? y \u00bfpor qu\u00e9 hay un \"&gt;\" en la \u00faltima?</p> <p>f. \u00bfQu\u00e9 es la segunda columna de n\u00fameros? (Pista: miren el n\u00famero de iguales que hay en esa l\u00ednea)</p> <p>g. \u00bfQu\u00e9 es la tercera columna de n\u00fameros?</p> <p>h. \u00bfQu\u00e9 es un inset? \u00bfQu\u00e9 regi\u00f3n del histograma est\u00e1 representada en el inset? \u00bfCu\u00e1nto representa el \"=\" en el inset?</p> <p>i. \u00bfEl valor del \u201c=\u201d en el inset es mayor o menor que en el resto del histograma? \u00bfTiene sentido?</p> <p>2.2 \u00bfPor qu\u00e9 le parece que es relevante que se reporte el tama\u00f1o de la base de datos (\"x residues in y sequences\") en el header del archivo de salida? </p> <p>2.3 \u00bfQu\u00e9 par\u00e1metros se utilizaron en esta corrida con FASTA?</p> <p>2.4 \u00bfEn qu\u00e9 se diferencian las distribuciones esperadas y observadas? \u00bfQu\u00e9 implica?</p> <p>2.5 \u00bfEn qu\u00e9 regi\u00f3n del histograma se ubican los puntajes de los alineamientos que consideramos m\u00e1s significativos (hits con mejor puntaje)?</p> <p>2.6 \u00bfQu\u00e9 representa el n\u00famero que est\u00e1 entre par\u00e9ntesis en el E (ver figura m\u00e1s abajo)? \u00bfCu\u00e1l es el E-value para el mejor hit?</p> <p></p> Diferencias entre BLAST y FASTA <ul> <li> <p>ktup: Tanto FASTA como BLAST usan una estrategia de b\u00fasqueda inicial basada en palabras cortas. ktup en FASTA es el par\u00e1metro que indica el tama\u00f1o de la palabra utilizada en esta b\u00fasqueda inicial.</p> <ul> <li>FASTA utiliza por default ktup=2,</li> <li>BLAST utiliza ktup=3.</li> </ul> <p>Sin embargo:</p> <ul> <li>FASTA s\u00f3lo considera identidades respecto a la palabra,</li> <li>BLAST utiliza identidades y sustituciones conservativas. Por lo tanto BLAST con ktup=3 es en general m\u00e1s sensible que FASTA con ktup=2. FASTA con ktup=1 es m\u00e1s sensible, pero es tambi\u00e9n m\u00e1s lento.</li> </ul> </li> <li> <p>Matrices y scores: BLAST y FASTA usan distintas matrices de scoring y gap penalties por default </p> <ul> <li>FASTA: BLOSUM50, gap open:-10, gap extend:-2</li> <li>BLAST: BLOSUM62, gap open:-11, gap extend:-1. </li> </ul> </li> <li> <p>Estad\u00edsticas Los par\u00e1metros kappa y lambda son centrales para estimar scores en BLAST y en FASTA.</p> <ul> <li>FASTA calcula estos par\u00e1metros on the fly a partir de la base de datos (se tiene en cuenta el tama\u00f1o) y la matriz de scoring. Esto produce estad\u00edsticas m\u00e1s representativas, pero puede ser problem\u00e1tico para bases de datos peque\u00f1as. Si la base de datos es de menos de 10 secuencias, FASTA no estima estos par\u00e1metros.</li> <li>BLAST usa valores pre-calculados para estos par\u00e1metros, que fueron derivados a partir de simulaciones. </li> </ul> </li> <li>Alineamientos: <ul> <li>BLAST puede mostrar varios alineamientos por cada par de secuencias (varios high-scoring pairs o HSPs) aunque por default s\u00f3lo muestra el mejor,</li> <li>FASTA \u00fanicamente reporta un alineamiento posible. </li> </ul> </li> <li> <p>Filtrado de secuencias de baja complejidad: </p> <ul> <li>BLAST, por default, filtra secuencias de baja complejidad o repeticiones,</li> <li>FASTA no filtra!</li> </ul> <p>Esto puede afectar la capacidad de discriminar falsos positivos, aunque FASTA provee otro tipo de opciones para manejar este tipo de casos. Ver la secci\u00f3n espec\u00edfica sobre este punto m\u00e1s abajo en la gu\u00eda. </p> </li> <li> <p>Traducciones:</p> <ul> <li>blastx hace 6 b\u00fasquedas independientes (una en cada marco de lectura) </li> <li>fastx3 y fasty3 hacen una \u00fanica b\u00fasqueda forward (o reverse usando <code>-i</code>) que permite frameshifts. Estos \u00faltimos son m\u00e1s sensibles y pueden producir mejores alineamientos que blastx cuando se usan secuencias de baja calidad (lo mismo es cierto para tblastn vs tfastx3 y tfasty3). </li> </ul> </li> <li>Hom\u00f3logos distantes: <ul> <li>En FASTA existe una opci\u00f3n (<code>-F</code>) que les permite ignorar (i.e. que no aparezcan en el output) secuencias altamente similares al query. Esto es \u00fatil, por ejemplo, para focalizar una b\u00fasqueda en las secuencias m\u00e1s divergentes.</li> <li>En BLAST no existe una opci\u00f3n similar. </li> </ul> </li> <li>Secuencias cortas: Ya sea que busquen un primer (iniciador) o un p\u00e9ptido, si quieren utilizar BLAST o FASTA para esto, tengan en cuenta que BLAST es generalmente in\u00fatil al respecto. Esto es porque BLAST tiene un l\u00edmite inferior sobre la longitud que puede tener una palabra (ktup). En el caso de nucle\u00f3tidos, el l\u00edmite inferior es 7 (el default es 11). En este sentido FASTA es mejor, porque siempre pueden usar ktup=1. Por otra parte, en el caso espec\u00edfico de p\u00e9ptidos, FASTA provee algunos algoritmos particulares de b\u00fasqueda (fastf, fasts y tfasf, tfasts).</li> </ul> <p>Tip</p> <p>Usar un cuchillo en lugar de un destornillador, a veces puede funcionar, pero no deja de ser cierto que cada herramienta fue dise\u00f1ada para un fin distinto. Si quieren realizar b\u00fasquedas de secuencias cortas prueben primero con fuzznuc, fuzzpro o findpatterns (todos parte de EMBOSS).</p>","tags":["practicos"]},{"location":"practicos/TP04_Busqueda_por_similitud/#filtrado-de-secuencias-de-baja-complejidad","title":"Filtrado de secuencias de baja complejidad","text":"<p>Muchas secuencias son altamente repetitivas. Si la secuencia query contiene regiones de baja complejidad o repeticiones, es posible que una b\u00fasqueda encuentre muchas secuencias no relacionadas, con altos scores (por ej. hits contra colas de poly-A o regiones ricas en Prolina). En otros casos, la secuencia puede contener un vector (pl\u00e1smido) o repeticiones Alu, que ustedes pueden querer omitir en la b\u00fasqueda. </p> <p>BLAST permite filtrar el primer tipo de casos, mediante la opci\u00f3n <code>-F</code>.</p> <p>FASTA en cambio no provee esta alternativa. Es el usuario el que tiene que filtrar el query antes de realizar una b\u00fasqueda. </p>","tags":["practicos"]},{"location":"practicos/TP04_Busqueda_por_similitud/#ejercicio-3","title":"Ejercicio 3","text":"<p>3.1 Usar la prote\u00edna Groucho de Drosophila (grou_drome) para buscar secuencias similares en Swiss-Prot usando BLAST. Comparar los resultados obtenidos usando (<code>-F T</code>) y sin usar (<code>-F F</code>) la opci\u00f3n de filtrado que provee BLAST. </p> <ul> <li>Observen el primer hit en las lista de los alineamientos resultantes y responda: \u00bfQu\u00e9 pueden detectar de diferencia entre los dos comandos que corrieron?</li> </ul> <p>3.2 Ahora para repetir el mismo ejercicio con FASTA, tenemos que detectar y marcar las regiones de baja complejidad. Para esto se utiliza <code>segmasker</code>: </p> <pre><code>!segmasker -in Data/grou_drome.fasta -outfmt fasta &gt; grou_drome_lc.fasta\n</code></pre> <p>3.3 Comparen las secuencias grou_drome.fasta y grou_drome_lc.fasta e identifiquen las diferencias. \u00bfQu\u00e9 hizo segmasker con la secuencia? </p> <p>Ahora, podemos buscar secuencias similares en Swiss-Prot usando grou_drome.fasta (con opciones standard) y grou_drome_lc.fasta (usando la opci\u00f3n <code>-S</code>). </p> <pre><code>!fasta -H Data/grou_drome.fasta Data/Swissprot_db/Swissprot.fasta | head -74\nprint(\"\\n\")\n!fasta -H -S grou_drome_lc.fasta Data/Swissprot_db/Swissprot.fasta | head -74\n</code></pre> <ul> <li>Responda: \u00bfQu\u00e9 diferencias encuentran en los histogramas de cada b\u00fasqueda? </li> </ul>","tags":["practicos"]},{"location":"practicos/TP04_Busqueda_por_similitud/#bases-de-datos-propias","title":"Bases de datos propias","text":"<p>Tener acceso a BLAST o FASTA en la l\u00ednea de comando les da la posibilidad de crear sus propias bases de datos para realizar b\u00fasquedas.  FASTA puede realizar b\u00fasquedas sobre un archivo en formato fasta conteniendo varias secuencias sin ning\u00fan otro tipo de tratamiento. BLAST, sin embargo necesita contar con una base de datos indexada. <code>formatdb</code> es el comando que vamos a utilizar para generar los \u00edndices que BLAST necesita. </p>","tags":["practicos"]},{"location":"practicos/TP04_Busqueda_por_similitud/#adicional-ejercicio-4","title":"Adicional: Ejercicio 4","text":"<p>4.1 Primero, vamos a generar un archivo fasta m\u00faltiple con algunas secuencias. Por ejemplo, para construir una base de datos con secuencias de opsinas podemos empezar con: </p> <p></p><pre><code>!seqret Data/Swissprot_db/Swissprot.fasta:ops* fasta::ops\n\n!head ops\n</code></pre> Esto deber\u00eda generar un archivo FASTA m\u00faltiple conteniendo secuencias de opsinas.  <p>4.2 Responda: \u00bfCu\u00e1ntas secuencias tiene nuestra base de datos? </p> <p>Ahora para indexar el archivo ops (en formato fasta), usamos <code>formatdb</code>, indic\u00e1ndole el archivo que contiene las secuencias (<code>-i</code>) y si el archivo contiene secuencias de ADN (<code>-p F</code>) o de prote\u00ednas (<code>-p T</code>). </p> <pre><code>!formatdb -i ops -p T\n</code></pre> <p>4.3 Una vez indexada la base de datos, podemos hacer una b\u00fasqueda, por ejemplo, con nuestra ya conocida xlrhodop.pep</p> <pre><code>!blastall -p blastp -d ./ops -i Data/xlrhodop.pep &gt; xlrhodop.ops.blastp\n</code></pre> <p>Pueden ver las opciones que acepta el comando <code>formatdb</code> pidiendo ayuda: </p> <pre><code>!makeblastdb -help\n</code></pre>","tags":["practicos"]},{"location":"practicos/TP04_Busqueda_por_similitud/#blast-con-multiples-secuencias","title":"BLAST con m\u00faltiples secuencias","text":"<p>Si tienen un archivo con m\u00faltiples secuencias en formato fasta, pueden usarlo como query en una b\u00fasqueda, usando BLAST. </p>","tags":["practicos"]},{"location":"practicos/TP04_Busqueda_por_similitud/#adicional-ejercicio-5","title":"Adicional: Ejercicio 5","text":"<p>5.1 El archivo opsv.fasta contiene la secuencia de 4 fotorreceptores, usen este archivo para realizar una b\u00fasqueda, usando blastp, contra la base de datos ops que crearon en el ejercicio anterior. </p> <p>5.2 El output generado consiste en 4 reportes de BLAST, concatenados en un \u00fanico archivo. \u00bfC\u00f3mo pueden navegar f\u00e1cilmente dentro del documento usando <code>sed</code>? </p> <p>Tip</p> <p>Tip: \u00bfqu\u00e9 palabras o conjunto de palabras ocurren una sola vez en cada reporte?</p> <p>5.3 Ahora puedo leer el reporte y manejarme bien dentro de \u00e9l. Si quiero partirlo en 4 reportes individuales \u00bfC\u00f3mo hago? </p> <p>Tanto en Linux como en cualquier Unix, una manera de partir un archivo en varios usando un pattern es usando el comando <code>awk</code>: </p> <p>Dado un archivo llamado blast.out, podemos partirlo en varios usando la siguiente invocaci\u00f3n: </p> <pre><code>!awk -v i=0 '/pattern/{i++}{print &gt; \"blast.\"i}' blast.out \n</code></pre> <p>Atenci\u00f3n</p> <p>Recuerden reemplazar \"pattern\" por el patr\u00f3n que quieren utilizar para dividir el archivo y blast.out por el nombre del archivo que quieren partir.</p> <p>\u00bfLo lograron?</p>","tags":["practicos"]},{"location":"practicos/TP04_Busqueda_por_similitud/#bibliografia","title":"Bibliograf\u00eda","text":"<ul> <li>Tutorial de BLAST en la web del NCBI: The Statistics of Sequence Similarity Scores</li> </ul>","tags":["practicos"]},{"location":"practicos/TP05_PSI-BLAST/","title":"Practico Cinco","text":"","tags":["practicos"]},{"location":"practicos/TP05_PSI-BLAST/#tp-5-perfiles-de-secuencias-y-psi-blast","title":"TP 5. Perfiles de secuencias y PSI-BLAST","text":"<p> Materiales</p> <p>Atenci\u00f3n: Este TP tiene informe.</p>","tags":["practicos"]},{"location":"practicos/TP05_PSI-BLAST/#construccion-de-logos-y-matrices-peso-especificas","title":"Construcci\u00f3n de Logos y Matrices peso-espec\u00edficas","text":"","tags":["practicos"]},{"location":"practicos/TP05_PSI-BLAST/#objetivos","title":"Objetivos","text":"<ul> <li>Familiarizarse con la construcci\u00f3n de matrices peso-espec\u00edficas o PSSM.</li> <li>Familiarizarse con la visualizaci\u00f3n de logos de secuencias, y el uso del contenido de informaci\u00f3n.</li> <li>Utilizar las matrices peso-espec\u00edficas como m\u00e9todos predictivos, y entender las m\u00e9tricas PCC (Pearson correlation coefficient) y Aroc (Area under the Receiver Operating Characteristic curve) empleadas para evaluar la calidad de los modelos. </li> </ul>","tags":["practicos"]},{"location":"practicos/TP05_PSI-BLAST/#introduccion","title":"Introducci\u00f3n","text":"<p>En este TP utilizaremos herramientas bioinform\u00e1ticas para predecir la uni\u00f3n de p\u00e9ptidos a MHC, o por sus siglas en ingl\u00e9s Major Histocompatibility Complex, y seleccionaremos potenciales ep\u00edtopes como candidatos para desarrollar una vacuna.  </p> <p>Los pasos a seguir ser\u00e1n:  </p> <ol> <li>Identificaci\u00f3n de motivos de uni\u00f3n a MHC.  </li> <li>Visualizaci\u00f3n de motivos utilizando logos de secuencias.  </li> <li>Entrenamiento de m\u00e9todos de predicci\u00f3n de uni\u00f3n a MHC.  </li> <li>Utilizaci\u00f3n de los m\u00e9todos desarrollados para la selecci\u00f3n de candidatos vacunales.  </li> </ol> <p>La uni\u00f3n de p\u00e9ptidos a MHC es el paso m\u00e1s selectivo en el camino de procesamiento y presentaci\u00f3n antig\u00e9nica. Este evento es crucial ya que solamente 1 de cada 200 p\u00e9ptidos forma un complejo con el MHC. Existe una gran variedad de MHC diferentes, cada uno con una alta especificidad.</p> <p>El motivo de uni\u00f3n de los MHC de la v\u00eda de clase I es, en la mayor\u00eda de los casos, de 9 amino\u00e1cidos de longitud. Estos est\u00e1n caracterizados por una marcada preferencia por ciertos amino\u00e1cidos en determinadas posiciones del motivo. Estas posiciones son llamadas \"anclas\" o, en ingl\u00e9s, anchor positions. Para una gran cantidad de complejos de MHC de clase I estas anclas se encuentran en las posiciones P2 y P9. Sin embargo, este no es siempre el caso.</p> <p>Existe una gran cantidad de datos que describen las diferentes especificidades de las mol\u00e9culas de MHC. Una base de datos muy conocida que almacena esta informaci\u00f3n es SYFPEITHI. En ella se puede encontrar informacion de ligandos y motivos de MHC.  </p> <p>Con este tipo de informaci\u00f3n es posible desarrollar un modelo de predicci\u00f3n de uni\u00f3n de p\u00e9ptidos a MHC y usarlo para descubrir nuevos ep\u00edtopes con los cuales dise\u00f1ar vacunas. Esto puede ser aplicado a nivel de proteomas enteros para ahorrar tanto tiempo como recursos.  </p> <p>A continuaci\u00f3n vamos a:</p> <ol> <li>Visualizar motivos de uni\u00f3n utilizando logos de secuencias.  </li> <li>Entrenar un modelo predictivo utilizando el servidor de EasyPred.  </li> <li>Aplicar el modelo para seleccionar p\u00e9ptidos con potencial inmunog\u00e9nico de prote\u00ednas de SARS-CoV-2.  </li> </ol>","tags":["practicos"]},{"location":"practicos/TP05_PSI-BLAST/#identificacion-de-motivos-de-union-a-mhc","title":"Identificaci\u00f3n de motivos de uni\u00f3n a MHC","text":"<p>Dir\u00edjanse a la p\u00e1gina web de SYFPEITHI. All\u00ed, una vez que hagan click en el logo, pueden buscar motivos con el bot\u00f3n Find your motif, Ligand or Epitope.</p> <p>All\u00ed seleccionen con el men\u00fa de la izquierda el alelo de MHC HLA-A*02:01 y presionen Do Query. </p> <p>Nota</p> <p>El resto de las opciones se pueden usar para refinar la b\u00fasqueda, limit\u00e1ndola a ligandos de prote\u00ednas determinadas o por referencia bibliogr\u00e1fica. En este caso queremos obtener TODOS los ligandos para poder ver qu\u00e9 caracter\u00edsticas comparten.</p> <p>En el resultado de la b\u00fasqueda podemos ver las posiciones anchor principales y auxiliares, y tambi\u00e9n otras posiciones con residuos preferidos. Tambi\u00e9n tenemos una lista de otros amino\u00e1cidos que se ven con frecuencia en los ligandos del alelo que estamos estudiando. Por \u00faltimo, m\u00e1s abajo, se muestra la lista de los ligandos que existen en esta base de datos, junto a su proteina de procedencia, la referencia del trabajo donde se lo identific\u00f3 y alguna nota como la asociaci\u00f3n de un p\u00e9ptido dado con una enfermedad.  </p> <p>1. Respondan a las siguientes preguntas :</p> <p>a. \u00bfQu\u00e9 posiciones identifican como anchors? \u00bfQu\u00e9 residuos son preferidos en estas posiciones? \u00bfY en los auxiliary anchors?</p> <p>b. \u00bfQu\u00e9 otras posiciones muestran preferencias de residuos? \u00bfQu\u00e9 residuos son preferidos en estas posiciones? </p> <p>c. \u00bfQu\u00e9 diferencia observa para las posiciones anchor en el conjunto de p\u00e9ptidos en comparaci\u00f3n al resto de las posiciones? Recu\u00e9rdenla para el ejercicio de logos de secuencia.</p> <p>2. Repitan el mismo an\u00e1lisis para el alelo HLA-B*27. \u00bfCoinciden las posiciones anchor con las del alelo HLA-A*02:01?, \u00bfy los residuos preferidos?</p>","tags":["practicos"]},{"location":"practicos/TP05_PSI-BLAST/#logos-de-secuencias","title":"Logos de secuencias","text":"<p>Los logos son una herramienta muy \u00fatil para visualizar motivos de uni\u00f3n. En un logo de secuencia se grafica en el eje y el contenido de informaci\u00f3n de cada posici\u00f3n del motivo, generalmente expresado en bits. A su vez, la frecuencia con la que aparece una letra (nucle\u00f3tido u aminino\u00e1cido) en una dada posici\u00f3n se grafica con un tama\u00f1o proporcional a dicha magnitud.</p> <p>Un servidor que nos permite generar facilmente logos de secuencia es Seq2Logo. Este m\u00e9todo nos da la opci\u00f3n de ingresar un alineamiento m\u00faltiple (MSA), una lista de p\u00e9ptidos o una matriz peso-espec\u00edfica con la cual realizar el gr\u00e1fico. </p> <p>La informaci\u00f3n puede pegarse directamente en el  cuadro de texto  que provee la web, o subiendo directamente un archivo local utilizando la opci\u00f3n  Switch to file upload  que se encuentra debajo del cuadro.</p> <p></p> <p>Dentro de las opciones que nos permite cambiar tenemos:  </p> <ul> <li>Logo type: Esto refiere a la magnitud que se calcular\u00e1 para cada posici\u00f3n y se graficar\u00e1 en el eje y (Kullback-Leiber, Shannon, etc.).  </li> <li>Clustering method: Agrupa las secuencias que son muy similares para no sesgar el resultado, se pueden optar por diferentes m\u00e9todos.  </li> <li>Weight on prior: Es el valor que le asignamos al par\u00e1metro beta en la ecuacion del c\u00e1lculo del contenido de informaci\u00f3n. Recuerden que la relaci\u00f3n entre alfa y beta es determinante para este c\u00e1lculo.   </li> <li>Information content units: Generalmente se expresa en bits, pero en algunos casos se opta por half-bits.  </li> <li>Output format: El tipo de archivo de imagen adonde se guardar\u00e1 el logo. </li> </ul> <p>Tambi\u00e9n tenemos la opci\u00f3n de realizar cambios avanzados, como modificar las frecuencias de background o la matriz de scoring, limitar la regi\u00f3n del alineamiento que queremos graficar, etc. y opciones gr\u00e1ficas, como el tama\u00f1o de la imagen y los colores con los que se representa cada amino\u00e1cido.  </p> <p>Por convenci\u00f3n los colores que se utilizan son:  </p> <ul> <li>Rojo: Amino\u00e1cidos \u00e1cidos [DE]  </li> <li>Azul: Amino\u00e1cidos b\u00e1sicos [HKR]  </li> <li>Negro: Amino\u00e1cidos hidrof\u00f3bicos [ACFILMPVW]  </li> <li>Verde: Amino\u00e1cidos polares y glicina [GNQSTY]  </li> </ul> <p>Atenci\u00f3n</p> <p>Recuerden guardar los logos de secuencia generados.</p> <p>3. En Materiales pueden encontrar los archivos HLA-A0201 y HLA-B27, los cuales contienen ligandos de cada uno de estos alelos de MHC.  \u00dasenlos para generar logos que muestren sus motivos de preferencia. Utilicen como opci\u00f3n de clustering Heuristics. </p> <p>Usamos para el resto de las opciones los valores default. Identifiquen las posiciones ancla y las preferencias de cada alelo. </p> <p>a. \u00bfEl logo obtenido para HLA-A02:01 y HLA-B27 se condice con lo que encontr\u00f3 en la base de datos en el punto anterior? </p> <p>b. \u00bfQu\u00e9 magnitud es la que est\u00e1 diferenciando a las posiciones anchor del resto? \u00bfEn qu\u00e9 unidad aparece representada en el logo? \u00bfCoincide con lo supuesto en el punto 1.c?</p>","tags":["practicos"]},{"location":"practicos/TP05_PSI-BLAST/#construccion-de-matrices-peso-especificas-pssm","title":"Construcci\u00f3n de matrices peso-espec\u00edficas (PSSM)","text":"<p>Para este punto vamos a utilizar el servidor de EasyPred. Esta herramienta nos permite construir tanto matrices peso-espec\u00edficas, o PSSM (Position-Specific Scoring Matrix), como aplicarlas a un set de datos para calcular su score. </p> <p>El servidor consta de dos cuadros de texto, el de la izquierda en el cual se ingresan datos para construir la matriz, y el de la derecha donde uno puede ingresar secuencias sobre las cuales quiere realizar una predicci\u00f3n.</p> <p></p> <p>Para explorar un poco la construcci\u00f3n de matrices solo utilizaremos el recuadro de la izquierda donde ingresaremos las siguientes secuencias:</p> <p></p><pre><code>VFAAA  \nVHYWW  \nVLQPK  \nLREWQ  \nLPYIH  \n</code></pre> Las opciones que tenemos aqu\u00ed son muy similares a las que habiamos visto en el servidor de Seq2Logo debido a que ambos realizan c\u00e1lculos del contenido de informaci\u00f3n. En este caso vamos a seleccionar Clustering method: No clustering y Weight on prior: 10000. Usamos para el resto de las opciones los valores default. <p>4. Antes de generar la PSSM, reflexionen un poco acerca de los par\u00e1metros empleados para la construcci\u00f3n de la misma.</p> <p>a. \u00bfPor qu\u00e9 consideran que no estamos usando ning\u00fan m\u00e9todo de clustering?</p> <p>b. \u00bfPor qu\u00e9 creen que es tan alto el valor sugerido para el weight on prior (\u03b2) ?</p> Recordatorio <p>La ecuaci\u00f3n utilizada para estimar la frecuencia p<sub>a</sub>, para una dada posici\u00f3n, en una matriz peso-espec\u00edfica es,</p> <p></p> <p>donde \u03b1 es el n\u00famero de secuencias en el MSA-1, \u03b2 es el weight on prior o weight on pseudocounts, f<sub>a</sub> es la frecuencia observada para el amino\u00e1cido a en esa posici\u00f3n y g<sub>a</sub> es la pseudo frecuencia para el amino\u00e1cido a en esa misma posici\u00f3n.</p> <p> Hagan Submit query y observen la salida. All\u00ed podr\u00e1n encontrar informaci\u00f3n sobre los par\u00e1metros utilizados y un logo que representa el set de datos que ingresamos.</p> <p>Observando el logo generado:</p> <p>5. \u00bfQu\u00e9 amino\u00e1cidos es m\u00e1s probable hallar en la posici\u00f3n P1?</p> Pista <p>Son los que est\u00e1n por encima de y=0.</p> <p> 6. \u00bfCu\u00e1ntos amino\u00e1cidos diferentes hay en P1 (en y&gt;=0)? \u00bfCu\u00e1les se encuentran datos de entrada? \u00bfCu\u00e1les en el logo generado?</p> <p>7. \u00bfA qu\u00e9 se debe esta diferencia?  </p> <p>8. Realice el mismo ejercicio pero ahora elija un weight on prior \u03b2=0. \u00bfCambian sus respuestas para los puntos 5., 6. y 7.?</p>","tags":["practicos"]},{"location":"practicos/TP05_PSI-BLAST/#prediccion-de-union-a-mhc","title":"Predicci\u00f3n de uni\u00f3n a MHC","text":"<p>Habi\u00e9ndonos familiarizado con la interfaz de EasyPred vamos a utilizarla para entrenar un modelo con m\u00e1s datos y ponerlo a prueba. Para eso utilizaremos dos sets de entrenamiento que poseen p\u00e9ptidos fueron testeados con el alelo HLA-A02:01. Cada uno tiene un valor asociado que denota si son positivos (1) o negativos (0.1). A lo largo del proceso iremos variando diferentes par\u00e1metros para observar qu\u00e9 efectos esto tiene sobre el poder predictivo del modelo, al ser testeado en un set de evaluaci\u00f3n con valores de afinidad (binding affinity) de uni\u00f3n a MHC reales (reescalados entre 0 y 1). </p> <p>Los datos que utilizaremos est\u00e1n en los archivos:</p> <ul> <li>Entrenamiento_chico.set que contiene 110 p\u00e9ptidos de los cuales s\u00f3lo 10 son positivos.  </li> <li>Entrenamiento_grande.set contiene 232 p\u00e9ptidos de los cuales todos son positivos.  </li> </ul> <p>Para evaluar el desempe\u00f1o de nuestro modelo utilizaremos el archivo Evaluacion.set, el cual contiene 1266 peptidos con valores de afinidad convertidos al rango 0-1 mediante la formula 1-log(x)/log(50000). Utilizando esta transformaci\u00f3n, </p> <ul> <li>valores mayores a 0.638 (equivalente a 50nM) representan una uni\u00f3n fuerte, </li> <li>entre 0.638 y 0.426 (equivalente a 500nM) una uni\u00f3n d\u00e9bil </li> <li>y p\u00e9ptidos con valores menores a 0.426 no se consideran ligandos. </li> </ul> <p>Atenci\u00f3n</p> <p>Una buena pr\u00e1ctica antes de comezar a hacer cualquier cosa con nuestros datos es observarlos y entender el formato en el que est\u00e1n almacenados.</p> <p>Por ejemplo, si hacemos un <code>cat</code> del archivo Entrenamiento_chico.set (si est\u00e1n con la VM o bien pueden abrir el archivo con el \"Block de notas\" haciendo click derecho sobre el archivo y Abrir con... elegir el block de notas entre las opciones), nos encontramos con lo siguiente:</p> <p> </p> <p>Este es un archivo con dos columnas, la primera contiene a los p\u00e9ptidos y la segunda a los valores de afinidad de uni\u00f3n o binding affinity de los mismos. (\u00bfEn qu\u00e9 escala est\u00e1n los valores de binding affinity? \u00bfEst\u00e1n normalizados entre 0 y 1?)</p> <p>Para analizar el desempe\u00f1o de nuestros modelos vamos a tener en cuenta dos m\u00e9tricas:</p> <ul> <li>Aroc (Area under the Receiver Operator Curve): este valor var\u00eda entre 0 y 1, siendo 1 el puntaje perfecto y 0.5 el valor aleatorio. Por regla general, valores mayores a 0.85 son altamente deseables.  </li> <li>Coeficiente de correlaci\u00f3n  de Pearson (PCC): tambi\u00e9n oscila entre 0 y 1, siendo 1 una correlaci\u00f3n perfecta entre las dos variables de estudio, y -1 una anticorrelaci\u00f3n perfecta. En este caso el valor que implica aleatoriedad total o no correlaci\u00f3n entre las dos variables es 0.  </li> </ul> <p>Estas m\u00e9tricas nos van a ayudar a seleccionar el mejor de nuestros modelos, siendo \u00e9ste el que alcance los mejores valores de Aroc y Coeficiente de Pearson.</p> <p>Note</p> <p>A continuaci\u00f3n vamos a entrenar varios modelos y comparar sus resultados. Haga cada prueba en una ventana nueva o guarde las salidas de alguna manera que crea conveniente.</p>","tags":["practicos"]},{"location":"practicos/TP05_PSI-BLAST/#primera-prueba","title":"Primera prueba","text":"<p>Atenci\u00f3n</p> <p>Volvamos a abrir EasyPred o recarguemos la p\u00e1gina para que todas las opciones vuelvan a estar por defecto.</p> <p>Realicemos los siguientes cambios: los datos del archivo Entrenamiento_chico.set en el recuadro de entrenamiento y los de Evaluacion.set en el recuadro de evaluaci\u00f3n. Coloquemos el umbral de corte para positivos (Cutoff for counting an example as a positive example) en 0 y apretemos el bot\u00f3n Submit query.  </p> <p>La salida consta de varias partes:</p> <ul> <li>Al principio tenemos una peque\u00f1a descripci\u00f3n de los par\u00e1metros con los que se llev\u00f3 a cabo el entrenamiento, tanto de los datos como del m\u00e9todo. Esto es siempre \u00fatil para poder reproducir los resultados. </li> <li>Luego tenemos un logo constru\u00eddo a partir de los datos de entrenamiento. Esto nos puede ayudar a identificar (como hicimos anteriormente) la preferencia de la mol\u00e9cula que se une a nuestro set de p\u00e9ptidos.  </li> <li>A continuaci\u00f3n sigue la informaci\u00f3n sobre la evaluaci\u00f3n. All\u00ed podemos encontrar los valores del coeficiente de Pearson y Aroc y la lista de predicciones sobre el set de evaluaci\u00f3n. F\u00edjense que Assignment se refiere al valor medido o real que est\u00e1 en el archivo de evaluaci\u00f3n y va de 0 a 1, sin embargo la predicci\u00f3n puede adoptar otros valores, incluso negativos. </li> </ul> <p>Tip</p> <p>Las m\u00e9tricas que utilizamos no se enfocan en reportar la precisi\u00f3n del m\u00e9todo (proporci\u00f3n de verdaderos positivos entre todos los p\u00e9ptidos predichos como positivos) sino que muestran:</p> <ol> <li> <p>la habilidad del m\u00e9todo para distinguir instancias positivas de negativas (Aroc) y</p> </li> <li> <p>la correlaci\u00f3n entre los valores predichos y los valores reales u observados (PCC).</p> </li> </ol> <p>Revisando la salida contesten:</p> <p>9. \u00bfQu\u00e9 valores de Aroc y PCC obtuvieron? \u00bfQu\u00e9 implica esto?</p> <p>10. Viendo el logo resultante, \u00bfEntienden por qu\u00e9 el modelo tiene tan mal desempe\u00f1o?  </p> <p>11. \u00bfCu\u00e1ntos de los 110 p\u00e9ptidos se utilizaron para la construcci\u00f3n de la matriz? \u00bfPor qu\u00e9 se us\u00f3 ese n\u00famero de p\u00e9ptidos?</p> Pista <p>Mire el archivo de entrada Entrenamiento_chico.set y vea cu\u00e1les son los valores de afinidad para los p\u00e9ptidos all\u00ed listados.</p>","tags":["practicos"]},{"location":"practicos/TP05_PSI-BLAST/#segunda-prueba","title":"Segunda prueba","text":"<p>Volvamos a la p\u00e1gina principal de EasyPred. Esta vez coloquemos el umbral de positivos en 0.5 pero especifiquemos que no haya clustering y pongamos un weight on prior de 0.0.</p> <p>12. \u00bfQu\u00e9 valores de desempe\u00f1o tienen ahora? \u00bfQu\u00e9 implican estos valores? \u00bfSon mejores o peores que en la primera prueba? \u00bfPor qu\u00e9 cree que cambiaron?</p> <p>13. \u00bfCu\u00e1ntos de los 110 p\u00e9ptidos se utilizaron en este caso para la construcci\u00f3n de la matriz?  </p> <p>14. Mirando el logo, \u00bfSe parece al motivo de uni\u00f3n de HLA-A*02:01 que hab\u00edan visto antes? \u00bfPor qu\u00e9 cree que ocurre esto?</p> Pista <p>Tenga en cuenta el n\u00famero de secuencias que se usaron para construir la matriz y recuerde que siempre es una buena pr\u00e1ctica revisar las instrucciones de la gu\u00eda y los archivos de entrada. </p>","tags":["practicos"]},{"location":"practicos/TP05_PSI-BLAST/#tercera-prueba","title":"Tercera prueba","text":"<p>Volvamos atr\u00e1s y repitamos el caso anterior pero seleccionando Clustering at 62% identity. Mantengamos el weight on prior en 0.0 y el resto de los par\u00e1metros como se hab\u00edan seteado en la segunda prueba. </p> <p>15. \u00bfCu\u00e1l es el desempe\u00f1o ahora?  </p> <p>16. \u00bfCambi\u00f3 el logo con respecto al anterior? Si es as\u00ed\u2026 \u00bfA qu\u00e9 cree que se debe el cambio?</p> Pista <p>De nuevo, es una buena pr\u00e1ctica revisar qu\u00e9 contienen los archivos de entrada, es decir los datos crudos. Miren con atenci\u00f3n las secuencias de los positivos.</p>","tags":["practicos"]},{"location":"practicos/TP05_PSI-BLAST/#cuarta-prueba","title":"Cuarta prueba","text":"<p>Volvamos una vez m\u00e1s, manteniendo Clustering at 62% identity pero utilicemos como weight on prior un valor de 200, y el umbral de positivos en 0.5.</p> <p>17. Una vez m\u00e1s revisen las m\u00e9tricas de desempe\u00f1o.</p> <p>18. Mirando el logo, \u00bfCu\u00e1l es la gran diferencia con aquellos que ven\u00edan viendo? \u00bfCu\u00e1l es la raz\u00f3n de este cambio? \u00bfEmpieza ahora a parecerse a los motivos que hab\u00edan visto antes?  </p>","tags":["practicos"]},{"location":"practicos/TP05_PSI-BLAST/#quinta-y-ultima-prueba","title":"Quinta (y \u00faltima) prueba","text":"<p>Hasta ahora ven\u00edamos utilizando un set de datos sumamente reducido, con solo 10 p\u00e9ptidos positivos para entrenar. A\u00fan asi hemos conseguido valores de desempe\u00f1o bastante aceptables. Sin embargo, estos m\u00e9todos suelen utilizar muchas m\u00e1s informaci\u00f3n para su entrenamiento.  </p> <p>A continuaci\u00f3n recarguen la p\u00e1gina de EasyPred y carguen para entrenar el archivo Entrenamiento_grande.set. En el cuadro de evaluaci\u00f3n vuelvan a cargar Evaluacion.set. Seleccionen una vez m\u00e1s Clustering at 62% identity, pongan el weight on prior en 200 y el umbral de positivos en 0.5. Tilden tambi\u00e9n la opci\u00f3n Sort output on predicted values para ver la tabla de p\u00e9ptidos ordenada por los valores de predicci\u00f3n.</p> <p>19. Revisen una vez m\u00e1s los valores de desempe\u00f1o.</p> <p>20. Vean el logo, \u00bfqu\u00e9 les parece?</p> <p>21. Mirando la tabla de predicciones, \u00bfCu\u00e1ntos falsos positivos encuentran entre los primeros 20 p\u00e9ptidos? (con Assignment menor a 0.426)</p> <p>Atenci\u00f3n</p> <p>Antes de cerrar la ventana haga click en Parameters for prediction method luego del logo. All\u00ed podr\u00e1 descargar la matriz calculada a partir de los datos de entrenamiento (Se descarga con el nombre para.dat, es un archivo de texto plano). Esta puede ser utilizada luego para llevar a cabo predicciones.</p>","tags":["practicos"]},{"location":"practicos/TP05_PSI-BLAST/#psi-blast","title":"PSI-BLAST","text":"","tags":["practicos"]},{"location":"practicos/TP05_PSI-BLAST/#objetivos_1","title":"Objetivos","text":"<ul> <li>Comprender el funcionamiento del algoritmo PSI-BLAST, aplicando el mismo en un caso de estudio en el que BLAST no funciona. </li> <li>Generar y reutilizar la PSSM que arroja PSI-BLAST, para encontrar hits en otras bases de datos relevantes tales como PDB.</li> <li>Entender la informaci\u00f3n que nos otorga la PSSM constru\u00edda por PSI-BLAST en relaci\u00f3n a los residuos o dominios conservados de una prote\u00edna.</li> </ul>","tags":["practicos"]},{"location":"practicos/TP05_PSI-BLAST/#introduccion_1","title":"Introducci\u00f3n","text":"<p>PSI-BLAST (o Position Specific Iterated BLAST) es un algoritmo alternativo de BLAST que construye iterativamente una matriz de puntajes posici\u00f3n espec\u00edfica, o PSSM (Position-Specific Scoring Matrix), para calcular el score de los alineamientos. </p> <p>En su forma b\u00e1sica de funcionamiento lo que hace es realizar un simple BLAST con una secuencia query y, a partir de los resultados o hits que obtiene, construye un perfil o PSSM. Entonces, la siguiente b\u00fasqueda la realiza con ese perfil, lo que permitir\u00e1 encontrar, idealmente, nuevos hits, correspondientes a secuencias m\u00e1s distantes de la secuencia query. Con esos nuevos hits genera un nuevo perfil, el cual, idealmente, contendr\u00e1 mayor cantidad de informaci\u00f3n y con el que se podr\u00e1 realizar otra b\u00fasqueda. Es un proceso iterativo.</p> <p>En resumen, a partir de la segunda iteraci\u00f3n los puntajes de la matriz variar\u00e1n acorde a la conservaci\u00f3n de los amino\u00e1cidos o nucle\u00f3tidos en cada posici\u00f3n permitiendo refinar nuestra b\u00fasqueda y as\u00ed recuperando secuencias distantes que comparten motivos o dominios con nuestra secuencia query original.</p>","tags":["practicos"]},{"location":"practicos/TP05_PSI-BLAST/#cuando-blast-falla","title":"Cuando BLAST falla","text":"<p>Digamos que se tiene una secuencia query (abajo) y se quiere predecir su estructura y funci\u00f3n. Como vimos anteriormente uno recurre generalmente a BLAST para este tipo de tareas. Si logramos identificar una prote\u00edna suficientemente similar podr\u00edamos hipotetizar que comparten dichas caracteristicas.</p> <pre><code>&gt;QUERY1\nMKDTDLSTLLSIIRLTELKESKRNALLSLIFQLSVAYFIALVIVSRFVRYVNYITYNNLV\nEFIIVLSLIMLIIVTDIFIKKYISKFSNILLETLNLKINSDNNFRREIINASKNHNDKNK\nLYDLINKTFEKDNIEIKQLGLFIISSVINNFAYIILLSIGFILLNEVYSNLFSSRYTTIS\nIFTLIVSYMLFIRNKIISSEEEEQIEYEKVATSYISSLINRILNTKFTENTTTIGQDKQL\nYDSFKTPKIQYGAKVPVKLEEIKEVAKNIEHIPSKAYFVLLAESGLRPGELLNVSIENID\nLKARIIWINKETQTKRAYFSFFSRKTAEFLEKVYLPAREEFIRANEKNIAKLAAANENQE\nIDLEKWKAKLFPYKDDVLRRKIYEAMDRALGKRFELYALRRHFATYMQLKKVPPLAINIL\nQGRVGPNEFRILKENYTVFTIEDLRKLYDEAGLVVLE\n</code></pre> <p>Vayan a la pagina de BLAST y utilicen el algoritmo de Protein BLAST para buscar secuencias similares. En el campo de base de datos seleccione pdb que es la base que contiene estructuras.</p> <p>Tip</p> <p>Pueden correr la b\u00fasqueda eligiendo el par\u00e1metro \"Show results in a new window\".</p> <p> </p> <p>1. \u00bfCu\u00e1ntos hits con E-value &lt; 0.05 encuentran? Vuelvan atr\u00e1s y, en Program selection: Algorithm, seleccionen PSI-BLAST. \u00bfCambi\u00f3 el resultado en comparaci\u00f3n a lo que hab\u00edan obtenido anteriormente?</p>","tags":["practicos"]},{"location":"practicos/TP05_PSI-BLAST/#usando-psi-blast","title":"Usando PSI-BLAST","text":"<p>Atenci\u00f3n</p> <p>Realicen cada corrida de BLAST (e iteraci\u00f3n de PSI-BLAST) en una ventana diferente, en varios casos van a necesitar comparar las salidas.</p> <p>Vuelvan atr\u00e1s a la p\u00e1gina de alineamiento de prote\u00ednas, pero esta vez seleccionen la base de datos Non-redundant protein sequences (nr) y en la secci\u00f3n de algoritmos seleccionen PSI-BLAST.</p> <p>Teniendo en cuenta que el primer hit es nuestro query y por lo tanto vamos a ignorarlo:</p> <p>2. Ahora, \u00bfCu\u00e1ntos hits significativos encuentran (E-value &lt; 0.005)?</p> <p>3. \u00bfQu\u00e9 significa la variable Query Cover? Una manera visual para entender el query coverage es mirar el Graphic Summary. Dentro de la pesta\u00f1a Descriptions, coloquen la pesta\u00f1a Show en 100. Luego cliqueen en la pesta\u00f1a Graphic Summary. \u00bfCu\u00e1l es la cobertura de los hits obtenidos? </p>","tags":["practicos"]},{"location":"practicos/TP05_PSI-BLAST/#construyendo-la-pssm","title":"Construyendo la PSSM","text":"<p>Si se fijan debajo de los hits significativos van a tener la opci\u00f3n de seguir iterando PSI-BLAST:</p> <p></p> <p>All\u00ed pueden especificar cuantas secuencias queremos utilizar para refinar nuestras PSSM (Position-Specific Scoring Matrix). Conservando el valor por defecto corramos la siguiente iteraci\u00f3n.</p> <p>4. \u00bfCu\u00e1ntos hits significativos pueden encontrar ahora (E-value &lt; 0.005)?</p> <p>5. \u00bfC\u00f3mo se modific\u00f3 el coverage de estos hits? Vuelvan a mirar el Graphic Summary, colocando previamente en Descriptions la pesta\u00f1a Show en 250. </p> <p>6. \u00bfPor qu\u00e9 creen que PSI-BLAST puede identificar ahora m\u00e1s hits significativos y que es lo que est\u00e1 afectando el query coverage?</p> <p>7. \u00bfQu\u00e9 significan que los hits est\u00e9n resaltados en amarillo, y qu\u00e9 significa que est\u00e9n en blanco con un tick verde?</p> <p>Nota</p> <p>Antes de proseguir realicen una o dos iteraciones m\u00e1s y observen la aparici\u00f3n de nuevas prote\u00ednas identificadas (marcadas con amarillo).</p>","tags":["practicos"]},{"location":"practicos/TP05_PSI-BLAST/#guardando-y-reutilizando-la-pssm","title":"Guardando y reutilizando la PSSM","text":"<p>Ahora podemos utilizar la PSSM que est\u00e1 ajustada con los resultados obtenidos de PSI-BLAST para realizar b\u00fasquedas m\u00e1s significativas en otras bases de datos. Para obtener la PSSM descarguenla arriba donde dice \"Donwload All\"</p> <p></p> <p>Volvamos una vez m\u00e1s a la p\u00e1gina para realizar la b\u00fasqueda. Sin ingresar ninguna secuencia query seleccionemos otra vez la base de datos de estructuras Protein Data Bank (pdb) y como algoritmo PSI-BLAST. Por \u00faltimo, justo debajo del bot\u00f3n de BLAST, abramos el men\u00fa de Algorithm parameters y carguemos nuestra PSSM (justo al final). Ahora s\u00ed corramos la b\u00fasqueda.</p> <p>8. \u00bfPueden encontrar hits significativos de PDB ahora?</p> <p>9. \u00bfQu\u00e9 funci\u00f3n pueden identificar en los primeros hits?</p>","tags":["practicos"]},{"location":"practicos/TP05_PSI-BLAST/#identificando-residuos-conservados","title":"Identificando residuos conservados","text":"<p>Ahora (si tuvimos suerte) habremos podido identificar una relaci\u00f3n estructural entre nuestra secuencia query y las secuencias de la base de datos de estructuras proteicas PDB. Digamos que, en este punto, nos gustar\u00eda validar esa relaci\u00f3n.</p> <p>Para identificar los residuos conservados en nuestra secuencia query vayan al servidor de Blast2logo y suban dicha secuencia. Seleccionen BLAST Database NR70 y denle Submit (esto puede llevar un tiempito). En caso de que algo falle puede encontrar la salida ac\u00e1.</p> <p>Cuando esto termine deber\u00edan tener un logo de toda la secuencia. </p> <p>Atenci\u00f3n</p> <p>Si les resulta dif\u00edcil de leer pueden hacer click en el bot\u00f3n Customize visualization using Seq2Logo. Al hacer esto los transfiere al servidor de Seq2logo y all\u00ed, sin tocar ninguna opci\u00f3n, denle Submit. </p> <p>Arriba les va a aparecer la opci\u00f3n de descargar cada imagen por separado (JPEG(1), JPEG(2), etc.) o en un s\u00f3lo archivo EPS (similar a PDF). Se recomienda esto \u00faltimo.</p> <p>10. Viendo el logo: \u00bfPor qu\u00e9 creen que las primeras ~150 posiciones se ven bastante planas (Bits&lt;1)? \u00bfCu\u00e1les son las posiciones con contenido de informaci\u00f3n m\u00e1s alto? \u00bfPueden identificar el dominio conservado que hab\u00edan visto en el ejercicio anterior?</p> <p>Para probar qu\u00e9 residuos dentro del dominio m\u00e1s conservado son los m\u00e1s relevantes para la estructura y/o funci\u00f3n de nuestra prote\u00edna, podr\u00edamos realizar un ensayo de mutag\u00e9nesis en el laboratorio. Debido a que la secuencia de nuestra prote\u00edna es larga (m\u00e1s de 400 amino\u00e1cidos), un estudio completo de mutag\u00e9nesis podr\u00eda resultar extremadamente costoso.</p> <p>Por esta raz\u00f3n, teniendo en cuenta lo realizado con el servidor Blast2logo, vamos a seleccionar (guiados por la conservaci\u00f3n de los residuos) 4 de los siguientes 8 residuos para llevar a cabo nuestro hipot\u00e9tico ensayo de mutag\u00e9nesis:</p> <ul> <li>(a): H271</li> <li>(b): R287</li> <li>\u00a9: E290</li> <li>(d): Y334</li> <li>(e): F371</li> <li>(f): R379</li> <li>(g): R400</li> <li>(h): Y436</li> </ul> <p>11. \u00bfCu\u00e1les creen que son los 4 residuos que podr\u00edamos mutar de la lista para generar un impacto en la estructura de nuestra prote\u00edna query?</p>","tags":["practicos"]},{"location":"practicos/TP05_PSI-BLAST/#ejercicio-a-informar","title":"Ejercicio a informar","text":"<p>Info</p> <p>Fecha l\u00edmite de entrega: Viernes, 20 de Septiembre 2023, 23:59hs.</p> <p> Materiales para el Informe</p>","tags":["practicos"]},{"location":"practicos/TP05_PSI-BLAST/#enunciado","title":"Enunciado","text":"<p>Su jefe ley\u00f3 el siguiente paper acerca de la respuesta inmune de c\u00e9lulas T CD8+ en pacientes infectados con COVID-19 y est\u00e1 muy interesado en realizar un estudio preliminar in silico, por lo cual lo convoca a usted que es un experto en Inmuno-bioinform\u00e1tica.</p> <p>Ferretti, Andrew P et al. \u201cUnbiased Screens Show CD8 + T Cells of COVID-19 Patients Recognize Shared Epitopes in SARS-CoV-2 that Largely Reside outside the Spike Protein.\u201d Immunity vol. 53,5 (2020): 1095-1107.e3. doi:10.1016/j.immuni.2020.10.006</p> <p>En a\u00f1os anteriores, colegas de su mismo grupo de investigaci\u00f3n ya hab\u00edan realizado estudios bioinform\u00e1ticos acerca de qu\u00e9 ligandos del alelo HLA-A*02:01 se encuentran en las prote\u00ednas del SARS-CoV-2.</p> <p>En ese momento, su jefe hab\u00eda decidido trabajar con las prote\u00ednas S (spike o prote\u00edna de glicoprote\u00edna de superficie), E (prote\u00edna de la envoltura), M (prote\u00edna de membrana) y N (fosfoprote\u00edna de la nucleoc\u00e1pside) del SARS-CoV-2 ya que cre\u00eda que eran las que conten\u00edan una mayor cantidad de p\u00e9ptidos inmunog\u00e9nicos. (Puede encontrar una descripci\u00f3n de coronavirus y sus prote\u00ednas en ViralZone de Expasy.)</p> <p>A la luz de los nuevos hallazgos, le propone a usted que trabaje con la prote\u00edna ORF1ab (NCBI: YP_009724389.1) de la cual se originan ~50% de todos p\u00e9ptidos inmunog\u00e9nicos identificados en el estudio de Ferretti et al., 2020.</p> <p>Para comenzar, se le ocurre realizar predicciones utilizando la matriz peso-espec\u00edfica del alelo HLA-A*02:01 que ya hab\u00eda generado en un curso de Bioinform\u00e1tica tiempo atr\u00e1s y que sabe que funciona muy bien.</p> <p>Decide adem\u00e1s utilizar la herramienta EasyPred que ya us\u00f3 previamente para generar su matriz peso-espec\u00edfica, pero esta vez la usar\u00e1 para realizar una predicci\u00f3n. Por lo tanto, deja el recuadro de entrenamiento vac\u00edo e ingresa el archivo con la secuencia de la prote\u00edna a evaluar en el recuadro de evaluaci\u00f3n. Por \u00faltimo, sube el archivo con la matriz en la secci\u00f3n Load saved prediction method.</p> <p></p> <p>Selecciona Sort output on predicted values y aprieta el bot\u00f3n Submit query.</p> <p>Atenci\u00f3n</p> <p>Importante: En la salida no hay logos ni m\u00e9tricas porque ya no se est\u00e1 entrenando ni testeando el modelo. En este punto se est\u00e1 utilizando un modelo ya entrenado (su matriz) para hacer predicciones en datos que nunca vio. La lista de p\u00e9ptidos son todas aquellas secuencias de 9 amino\u00e1cidos que se pueden obtener de la secuencia proteica que se le administra al servidor, junto con el valor de predicci\u00f3n.</p> <p>1. Describa lo que observa en el output de EasyPred. \u00bfQu\u00e9 operaci\u00f3n realiza el servidor para obtener las predicciones para cada p\u00e9ptido?</p> <p>2. Realice un histograma que ilustre la distribuci\u00f3n de los valores de predicci\u00f3n obtenidos para todos los p\u00e9ptidos. \u00bfQu\u00e9 caracter\u00edstica posee esta distribuci\u00f3n?</p> <p>3. Elija las secuencias con valores de predicci\u00f3n mayores 8 y luego seleccione otro conjunto de secuencias con valores de predicci\u00f3n entre 2 y 3. Realice logos para ambos conjuntos de secuencias. Para realizar los logos, utilice Seq2Logo y genere logos con los p\u00e9ptidos seleccionados ajustando los par\u00e1metros seg\u00fan su criterio.</p> <p>Atenci\u00f3n</p> <p>Importante: Seq2Logo toma como m\u00e1ximo 50 secuencias para construir el logo!</p> <p>Extra (y por ende opcional)</p> <p>4. En base a los conocimientos adquiridos en su curso de Bioinform\u00e1tica, \u00bfen qu\u00e9 difieren ambos logos? \u00bfEsto es esperable? \u00bfCu\u00e1l de los logos se parece m\u00e1s al motivo hallado para el alelo HLA-A*02:01? \u00bfPuede ver claramente las posiciones ancla? \u00bfQu\u00e9 amino\u00e1cidos son los preferidos para estas posiciones?</p> <p>5. En la Tabla 1 del paper de Ferretti et al., 2020, se listan 29 p\u00e9ptidos que han resultado inmunog\u00e9nicos al ser testeados con c\u00e9lulas T CD8+ de memoria de pacientes de COVID-19 con el mismo MHC (o HLA). Para la prote\u00edna no-estructural ORF1ab y el alelo HLA-A*02:01, se identificaron 3 p\u00e9ptidos inmunog\u00e9nicos compartidos entre pacientes. \u00bfQu\u00e9 valores de predicci\u00f3n obtuvo para los mismos con su PSSM? \u00bfHay alguno de estos p\u00e9ptidos que no predijo? \u00bfPor qu\u00e9? Comente al respecto.</p>","tags":["practicos"]},{"location":"practicos/TP05_PSI-BLAST/#material-extra-para-practicar","title":"Material extra para practicar","text":"<ul> <li> <p>Handout 1: The Psi-Blast alignment scoring matrix</p> </li> <li> <p>Handout 2: Estimation of pseudo counts</p> </li> <li> <p>Resoluci\u00f3n del ejercicio Estimation of pseudo counts</p> </li> </ul>","tags":["practicos"]},{"location":"practicos/TP06_HMM/","title":"Practico Seis","text":"","tags":["practicos"]},{"location":"practicos/TP06_HMM/#tp-6-hidden-markov-models-hmms","title":"TP 6. Hidden Markov Models (HMMs)","text":"<p> Materiales</p> <p></p> <p>Atenci\u00f3n: Este TP NO tiene informe.</p>","tags":["practicos"]},{"location":"practicos/TP06_HMM/#objetivos","title":"Objetivos","text":"<ul> <li>Comprender c\u00f3mo se entrena y eval\u00faa un modelo basado en redes neuronales.</li> <li>Familiarizarse con el esquema de validaci\u00f3n cruzada para el entrenamiento de dichos modelos.</li> <li>Construir un perfil basado en HMMs y utilizar el mismo para realizar b\u00fasquedas en bases de datos de secuencias.</li> <li>Crear una base de datos de perfiles de secuencias y utilizar la misma para identificar dominios conservados en secuencias query.</li> </ul>","tags":["practicos"]},{"location":"practicos/TP06_HMM/#hmmer","title":"HMMer","text":"<p>Atenci\u00f3n</p> <p>Si est\u00e1n trabajando en una m\u00e1quina virtual o en su propia PC corran el siguiente comando <code>sudo apt install hmmer2</code>, para instalar el programa <code>hmmer2</code>.</p>","tags":["practicos"]},{"location":"practicos/TP06_HMM/#introduccion","title":"Introducci\u00f3n","text":"<p>HMMer es un paquete de programas que nuclea varias funciones para realizar b\u00fasquedas en bases de datos mediante la utilizaci\u00f3n de perfiles de secuencias. Est\u00e1 basado en profile Hidden Markov Models, presentados por Anders Krogh (Krogh et al., 1994). Estos perfiles son una aproximaci\u00f3n estad\u00edstica del consenso de un alineamiento m\u00faltiple y utilizan un sistema de puntaje posici\u00f3n-espec\u00edfico, en contraste con m\u00e9todos ya vistos como BLAST o FASTA en donde la matriz de puntajes utilizada es la misma en cada posici\u00f3n.</p>","tags":["practicos"]},{"location":"practicos/TP06_HMM/#construccion-de-un-perfil","title":"Construcci\u00f3n de un perfil","text":"<p>Supongamos que trabajamos con globinas y queremos buscar hom\u00f3logos lejanos. Para ello contamos con 50 secuencias de globinas las cuales alineamos y guardamos en el archivo globins50.msf. Como primer paso para realizar la b\u00fasqueda debemos generar un profile o perfil que las represente. Para crear el profile utilizamos la funci\u00f3n <code>hmm2build</code> de la siguiente manera:</p> <pre><code>hmm2build globin.hmm globins50.msf\n</code></pre> <p><code>hmm2build</code> recibe como argumentos el archivo en el cual va a guardar el perfil (globin.hmm) y el archivo con el cual crearlo (globins50.msf). Si bien el contenido del archivo donde se guard\u00f3 el perfil es legible, su contenido no deber\u00eda tener sentido para ustedes (m\u00e1s all\u00e1 del encabezado con informaci\u00f3n sobre las opciones que se utilizaron para crearlo) porque \u00fanicamente almacena los pesos de las transiciones de estado del HMM.</p>","tags":["practicos"]},{"location":"practicos/TP06_HMM/#calibracion-del-perfil","title":"Calibraci\u00f3n del perfil","text":"<p>Este paso no es imprescindible pero s\u00ed aconsejable. La calibraci\u00f3n del perfil le otorga mayor sensibilidad en la b\u00fasqueda ya que modifica la estimaci\u00f3n del E-value de los hits encontrados. Si recuerdan, la b\u00fasqueda contra bases de datos nos devuelve junto con cada alineamiento un score y un E-value, este \u00faltimo nos da una idea sobre la cantidad de hits que esperamos encontrar con ese score en una base de datos construida con secuencias aleatorias y se calcula seg\u00fan la longitud de la secuencia query y subject, el tama\u00f1o de la base de datos y la matriz de scoring.</p> <p>En el caso de HMMer, la estimaci\u00f3n del E-value es anal\u00edtica y resulta muy conservativa, por lo que se dejan de lado posibles hits (como hom\u00f3logos lejanos). Utilizando <code>hmm2calibrate</code> podemos calibrar el c\u00e1lculo de E-values de manera emp\u00edrica incrementando de manera significativa la sensibilidad de la b\u00fasqueda.</p> <p></p><pre><code>hmm2calibrate globin.hmm\n</code></pre> <code>hmm2calibrate</code> lee un archivo con un modelo HMM como globin.hmm y punt\u00faa un n\u00famero grande de secuencias sintetizadas al azar (por default 5000 secuencias) con este modelo. Luego ajusta una EVD (Extreme Value Distribution) al histograma de los puntajes obtenidos y guarda nuevamente el modelo HMM con estos nuevos par\u00e1metros. <p>Como para realizar este c\u00e1lculo se sintetizan secuencias al azar, estableceremos una semilla (o seed) para poder reproducir nuestros resultados. Entonces el comando se modifica de la siguiente forma, </p> <pre><code>hmm2calibrate --seed 1 globin.hmm  \n</code></pre>","tags":["practicos"]},{"location":"practicos/TP06_HMM/#busqueda-en-bases-de-datos","title":"B\u00fasqueda en bases de datos","text":"<p>El comando para utilizar nuestro flamante profile en una b\u00fasqueda es <code>hmm2search</code>. En este caso lo vamos a utilizar contra el archivo Artemia.fa que contiene una \u00fanica secuencia de globina en b\u00fasqueda de dominios pertenecientes a nuestra familia de inter\u00e9s.</p> <pre><code>hmm2search globin.hmm Artemia.fa\n</code></pre> <p>La salida de este comando es m\u00e1s larga que las anteriores, consta de un encabezado con la informaci\u00f3n sobre el programa y los par\u00e1metros que utilizamos en la b\u00fasqueda:</p> <pre><code>hmmsearch - search a sequence database with a profile HMM\nHMMER 2.3.2 (Oct 2003)\nCopyright (C) 1992-2003 HHMI/Washington University School of Medicine\nFreely distributed under the GNU General Public License (GPL)\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nHMM file:                   globin.hmm [globins50]\nSequence database:          Artemia.fa\nper-sequence score cutoff:  [none]\nper-domain score cutoff:    [none]\nper-sequence Eval cutoff:   &lt;= 10        \nper-domain Eval cutoff:     [none]\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nQuery HMM:   globins50\nAccession:   [none]\nDescription: [none]\n  [HMM has been calibrated; E-values are empirical estimates]\n</code></pre> <p>Una lista parecida a la que da BLAST con los hits m\u00e1s importantes ordenados por su E-value:</p> <pre><code>Scores for complete sequences (score includes all domains):\nSequence Description                                    Score    E-value  N \n-------- -----------                                    -----    ------- ---\nS13421   S13421 GLOBIN - BRINE SHRIMP                   120.3    6.2e-37   4\n</code></pre> <p>Noten que despu\u00e9s del E-value hay un campo que no se encontraba en los otros algoritmos de b\u00fasqueda denominado \"N\". Este valor representa la cantidad de dominios de nuestro profile que fueron encontrados en el hit.</p> <p>Luego encontramos informaci\u00f3n sobre los dominios de nuestro profile individualmente. </p> <pre><code>Parsed for domains:\nSequence Domain  seq-f seq-t    hmm-f hmm-t      score  E-value\n-------- ------- ----- -----    ----- -----      -----  -------\nS13421     3/4     771  1075 ..     1   333 []    34.0    3e-13\nS13421     1/4       1   288 [.     1   333 []    31.9  3.8e-13\nS13421     4/4    1085  1390 ..     1   333 []    29.4    5e-13\nS13421     2/4     303   607 ..     1   333 []    25.0  8.1e-13\n</code></pre> <p>Los campos son:</p> <ul> <li> <p>el nombre del hit </p> </li> <li> <p>el dominio que se aline\u00f3 (por ej. 2/4 significa que es el dominio Nro 2 de 4 que hay en total en nuestro perfil) </p> </li> <li> <p>seq-f y seq-t son las posiciones del hit donde comienza y termina el alineamiento con ese dominio y el campo siguiente a estos valores (sin nombre) es una codificaci\u00f3n de qu\u00e9 parte de la secuencia fue alineada. </p> </li> <li> <p>los corchetes significan extremos y los puntos posiciones en el medio, por lo que:</p> <ul> <li> <p>\"..\" significa que el alineamiento comenz\u00f3 y termin\u00f3 en una posici\u00f3n que no es terminal de la secuencia hit</p> </li> <li> <p>\"[.\" significa que el alineamiento empieza al comienzo de la secuencia y termina en alguna posici\u00f3n en medio</p> </li> <li> <p>al rev\u00e9s, \".]\" empieza en una posici\u00f3n intermedia y termina en el fin de la secuencia</p> </li> <li> <p>por \u00faltimo \"[]\" es que el dominio abarca toda la secuencia. </p> </li> </ul> </li> <li> <p>Los tres siguientes campos son an\u00e1logos pero refiri\u00e9ndose a la secuencia del dominio en nuestro perfil HMM.</p> </li> <li> <p>Luego se reportan el score y el E-value.</p> </li> </ul> <p>La secci\u00f3n siguiente contiene los alineamientos de los dominios que fueron hit en la lista anterior en un formato similar al de BLAST, teniendo como primera secuencia el consenso del profile (noten que hay amino\u00e1cidos en may\u00fasculas, estos se encuentran altamente conservados en el profile). </p> <p>Al igual que BLAST en medio de ambas secuencias se escriben los amino\u00e1cidos que coinciden o \"matchean\" y signos m\u00e1s (+) en donde hay mismatches con puntaje positivo en la matriz de sustituci\u00f3n.</p> <pre><code>Alignments of top-scoring domains:\nS13421: domain 3 of 4, from 771 to 1075: score 34.0, E = 3e-13\n                   *-&gt;viqealvnssShLsaeeKalvkslWygKV..ggnaeeyGaeaLgRlF\n                                  L+a eK+ ++++W  + ++ g +++ +++++ RlF\n      S13421   771    T-----------LTALEKQSIQDIW-SNLrsTG-LQDLAVKIFTRLF 804  \n\n                   vvYPwTqryFp.hFgdLssldAvkGspkvKAHGkKVltalgdavkhLDdt\n                    ++P+ +  F + Fg++     +  ++ +KAH  +Vl+a++ ++  LDd \n      S13421   805 SAHPEYKLLFTgRFGNVDN---INENAPFKAHLHRVLSAFDIVISTLDDS 851  \n\n                   gnlkgalakLSelHAdKLrVDPeNFklLghclivVLAahfgkdFtPevqA\n                   + l   l++L+  H + L+ ++ +F +++ +++ V +   +   t     \n      S13421   852 EHLIRQLKDLGLFH-TRLGMTRSHFDNFATAFLSVAQDIAPNQLTVLGRE 900  \n\n                   AwdKflagvanaLahKYrelgFQggftviqealvnssShLsaeeKalvks\n                   ++ K +++   ++ ++   l      t+           Lsa e a vk+\n      S13421   901 SLNKGFKLMHGVIEEGLLQLERINPITG-----------LSAREVAVVKQ 939  \n\n                   lWygKVggnaeeyGaeaLgRlFvvYPwTqryFphFgdLssldAvkGspkv\n                   +W   V++++ ++G  ++  lF ++P  q+ Fp+F+d+ +ld + + p v\n      S13421   940 TW-NLVKPDLMGVGMRIFKSLFEAFPAYQAVFPKFSDV-PLDKLEDTPAV 987  \n\n                   KAHGkKVltalgdavkhLDdtgnlkgalakLSelHAdKLrVDPeNFklLg\n                    +H   V t l++ +  LD   nl+    +L+e H   LrV    Fk +g\n      S13421   988 GKHSISVTTKLDELIQTLDEPANLALLARQLGEDH-IVLRVNKPMFKSFG 1036 \n\n                   hclivVLAahfgkdFtPevqAAwdKflagvanaLahKYr&lt;-*\n                   ++l+  L   +g  F+  +  +w K++++++  + ++     \n      S13421  1037 KVLVRLLENDLGQRFSSFASRSWHKAYDVIVEYIEEGLQ    1075 \n</code></pre> <p>Llegando al final encontramos un histograma, similar al que nos mostraba FASTA. En este caso como nuestra \"base de datos\" tiene una sola secuencia no es informativo en absoluto.</p> <pre><code>Histogram of all scores:\nscore    obs    exp  (one = represents 1 sequences)\n-----    ---    ---\n  120      1      0|=      \n</code></pre> <p>Y por \u00faltimo algunos detalles estad\u00edsticos que corresponden al ajuste de la EVD, en los cuales no vamos a focalizar. </p> <pre><code>% Statistical details of theoretical EVD fit:\n              mu =  -226.7154\n          lambda =     0.1106\nchi-sq statistic =     0.0000\n  P(chi-square)  =          0\n\nTotal sequences searched: 1\n\nWhole sequence top hits:\ntophits_s report:\n     Total hits:           1\n     Satisfying E cutoff:  1\n     Total memory:         20K\n\nDomain top hits:\ntophits_s report:\n     Total hits:           4\n     Satisfying E cutoff:  4\n     Total memory:         25K\n</code></pre>","tags":["practicos"]},{"location":"practicos/TP06_HMM/#busqueda-en-bases-de-datos-reales","title":"B\u00fasqueda en bases de datos reales","text":"<p>HMMer puede leer los formatos de la mayor\u00eda de las bases de datos conocidas. A diferencia de BLAST no es necesario indexar la base de datos. Si recuerdan de la pr\u00e1ctica de BLAST/FASTA, uno pod\u00eda crear su propia base de datos donde realizar los alineamientos a partir de un archivo multifasta utilizando el comando formatdb, el cual crea todo el sistema de \u00edndices de ktuplas y dem\u00e1s archivos para facilitar la b\u00fasqueda. En este caso HMMer puede realizar la b\u00fasqueda directamente sobre el multifasta sin necesidad de m\u00e1s procesamiento. En nuestro servidor podemos realizar la b\u00fasqueda utilizando:</p> <pre><code>hmm2search globin.hmm ~/Swissprot_db/Swissprot.fasta &gt; globin.swissprot.search\nless globin.swissprot.search\n</code></pre> <p>Atenci\u00f3n</p> <p>Este comando no les va a funcionar si no tienen a la carpeta Swissprot_db en su home directory.</p> <p>A tener en cuenta:</p> <p>Notar\u00e1n que la b\u00fasqueda directa aumenta considerablemente el tiempo de c\u00f3mputo necesario para obtener un resultado.</p>","tags":["practicos"]},{"location":"practicos/TP06_HMM/#modos-de-alineamiento","title":"Modos de alineamiento","text":"<p>HMMer no utiliza los m\u00e9todos cl\u00e1sicos de alineamiento (Smith-Waterman o Needleman-Wunsch) como el resto de los algoritmos de alineamiento sino que el modo de alinear (local o global) est\u00e1 dado por el modelo que construimos. </p> <p>Por defecto <code>hmm2build</code> lleva a cabo alineamientos que son globales con respecto al HMM y locales con respecto a la secuencia objetivo, permitiendo alinear varios dominios en esa misma secuencia. \u00bfQu\u00e9 significa esto? Que cada dominio se intenta alinear completamente en alguna porci\u00f3n de la secuencia objetivo. Si queremos recuperar secuencias que contengan alineamientos parciales de dominios podemos agregar a <code>hmm2build</code> la opcion <code>-f</code> .</p>","tags":["practicos"]},{"location":"practicos/TP06_HMM/#bases-de-datos-de-hmm","title":"Bases de datos de HMM","text":"<p>As\u00ed como nos es posible realizar b\u00fasquedas de profiles contra bases de datos de secuencias, podemos crear una base de datos de profiles y utilizar como query a una secuencia. Este es el caso de la base de datos PFAM (Sonnhammer et al., 1997; Sonnhammer et al., 1998) que nuclea profiles de una gran variedad de dominios y es una herramienta sumamente utilizada para analizar secuencias de prote\u00ednas de las cuales no tenemos informaci\u00f3n previa.</p> <p>Como ejemplo, tomemos el producto del gen Sevenless de Drosophila melanogaster que codifica un receptor de tyrosine kinase esencial para el desarrollo de las c\u00e9lulas R7 del ojo de la mosca.  La secuencia proteica de este receptor se encuentra en el archivo 7LES_DROME. Realice una b\u00fasqueda de esta secuencia en PFAM. Para esto ingrese en JUMP TO el accession number de la secuencia: P13368. En la tabla de resultados vaya al final y haga click en Show donde dice: Show or hide domain scores.</p> <p>Inspeccione la tabla y conteste:</p> <ul> <li>\u00bfQu\u00e9 dominios fueron identificados en esta prote\u00edna y en qu\u00e9 posiciones se encuentran? Recuerde estos resultados para contrastarlo con lo que har\u00e1 m\u00e1s adelante. </li> </ul> <p>Las bases de datos de profiles no son m\u00e1s que m\u00faltiples HMMs concatenados, por lo que el comando para construirlas es tambi\u00e9n hmm2build, pero vamos a utilizar la opci\u00f3n -A (append) para agregar nuevos profiles a nuestro archivo de HMMs original.</p> <p>Por ejemplo, si queremos construir una base de datos \"myhmms\" que contiene perfiles de dominios rrm de reconocimiento de ARN, fn3 de fibronectina tipo III y pkinase del dominio catal\u00edtico de las kinasas podemos realizarlo f\u00e1cilmente con:</p> <pre><code>hmm2build -A myhmms rrm.sto\nhmm2build -A myhmms fn3.sto\nhmm2build -A myhmms pkinase.sto\n</code></pre> <p>Para realizar b\u00fasquedas en nuestra nueva base de datos utilizamos el comando <code>hmm2pfam</code>. En este caso empleamos nuevamente, como ejemplo, a la prote\u00edna codificada por el gen Sevenless de Drosophila melanogaster (archivo 7LES_DROME):</p> <pre><code>hmm2pfam myhmms 7LES_DROME\n</code></pre> <p>La salida es muy parecida a la de hmm2search pero los hits reportados no ser\u00e1n secuencias sino dominios contenidos en la base de datos. </p> <p>En nuestro caso particular podr\u00e1n notar que tenemos un hit contra un dominio RRM a\u00fan cuando nuestra prote\u00edna query no contiene ning\u00fan dominio de este tipo. </p> <p>Relacionado con esto mismo, \u00bfrecuerdan si la base de datos PFAM identific\u00f3 este dominio en la prote\u00edna de estudio?</p> <p>Nos podemos dar cuenta que este hit es al menos sospechoso debido a su score negativo y su E-value cercano a 1. Por defecto el l\u00edmite de E-value, al igual que BLAST es 10, este umbral es extremadamente permisivo y proclive a devolver ruido. Si queremos ser m\u00e1s quisquillosos podemos utilizar la opci\u00f3n -E seguida del umbral deseado. Por ejemplo:</p> <pre><code>hmm2pfam -E 0.1 myhmms 7LES_DROME\n</code></pre>","tags":["practicos"]},{"location":"practicos/TP06_HMM/#adicional-alineamientos-multiples-con-hmm","title":"Adicional: Alineamientos m\u00faltiples con HMM","text":"<p>Otro uso que se les da a los profiles es el de asistir a la hora de llevar a cabo alineamientos m\u00faltiples de grandes cantidades de secuencias. En general este proceso suele ser lento y los alineamientos resultantes contienen errores que requieren curarse a mano. Utilizando HMMs construidos a partir de un alineamiento de unas pocas secuencias representativas, se pueden alinear grandes cantidades de secuencias relacionadas f\u00e1cilmente. </p> <p>Siguiendo con nuestras globinas, tenemos un archivo (globins630.fa), que como habr\u00e1n deducido, contiene 630 secuencias de globinas que vamos a alinear utilizando el comando <code>hmm2align</code>:</p> <pre><code>hmm2align -o globins630.ali globin.hmm globins630.fa\n</code></pre> <p>mediante la opci\u00f3n <code>-o</code> indicamos el archivo en el que deseamos guardar el alineamiento (globins630.ali), y como argumentos debemos indicar el profile que vamos a utilizar como \"semilla\" y el archivo con las secuencias a alinear (globin.hmm y globins630.fa respectivamente). </p> <p>Noten que tambi\u00e9n se puede utilizar la opci\u00f3n <code>--outformat</code> para cambiar el formato del alineamiento producido. Por defecto se utiliza el formato Stockholm, pero tambi\u00e9n puede producir alineamientos en formato MSF, Clustal, Phylip y SELEX.</p>","tags":["practicos"]},{"location":"practicos/TP07_Quimioinformatica/","title":"Practico Siete","text":"","tags":["practicos"]},{"location":"practicos/TP07_Quimioinformatica/#tp-7-quimioinformatica","title":"TP 7. Quimioinform\u00e1tica","text":"<p>Atenci\u00f3n: Este TP NO tiene informe.</p>","tags":["practicos"]},{"location":"practicos/TP07_Quimioinformatica/#slides-mostrados-en-la-clase","title":"Slides mostrados en la clase","text":"<ul> <li> Slides TP</li> </ul>","tags":["practicos"]},{"location":"practicos/TP07_Quimioinformatica/#software-a-usar","title":"Software a usar","text":"<ul> <li>Google Colab</li> <li>RDKit</li> </ul>","tags":["practicos"]},{"location":"practicos/TP07_Quimioinformatica/#objetivos","title":"Objetivos","text":"<ul> <li>Conocer las bases de datos de compuestos qu\u00edmicos: PubChem, ChEMBL, SureChEMBL</li> <li>Familiarizarse con la representaci\u00f3n de estructuras qu\u00edmicas (SMILES, InchI)</li> <li>Aprender a caracterizar fisicoqu\u00edmicamente compuestos qu\u00edmicos</li> </ul>","tags":["practicos"]},{"location":"practicos/TP07_Quimioinformatica/#parte-1-bases-de-datos","title":"Parte 1: Bases de datos","text":"","tags":["practicos"]},{"location":"practicos/TP07_Quimioinformatica/#base-de-datos-1-pubchem","title":"Base de datos 1: PubChem","text":"<p>La primera que vamos a ver es PubChem, que es una base de datos qu\u00edmicos abierta del National Institutes of Health (NIH).</p> <p></p> <p></p> <p></p> <p>En esa base de datos se pueden cargar datos generados por nosotros o podemos usar los datos cargados por otras personas. Recopila informaci\u00f3n sobre estructuras qu\u00edmicas, identificadores, propiedades qu\u00edmicas y f\u00edsicas, actividades biol\u00f3gicas, patentes, salud, seguridad, datos de toxicidad y muchos otros.</p> <p>Ahora vamos a ingresar y a recorrerla. Pueden acceder ingresando a este link: PubChem. En la p\u00e1gina principal podemos ver que tenemos la opci\u00f3n de cargar una mol\u00e9cula en el recuadro blanco, de dibujar una estructura, de subir una lista de datos, de recorrer los datos disponibles y de acceder a una tabla peri\u00f3dica. En el pr\u00e1ctico de hoy vamos a trabajar ingresando una s\u00f3la mol\u00e9cula, pero ustedes pueden explorar el resto de las opciones m\u00e1s tarde.</p>","tags":["practicos"]},{"location":"practicos/TP07_Quimioinformatica/#actividad-usando-pubchem","title":"Actividad usando Pubchem","text":"<ol> <li>Dentro del recuadro blanco pegar esta mol\u00e9cula: <code>C1=CC=C(C=C1)CNC(=O)CN2C=CN=C2[N+](=O)[O-]</code> y usar la lupa para buscarlo dentro de la base de datos</li> <li>Ver\u00e1n que aparece un s\u00f3lo resultado, una mol\u00e9cula llamada \"BENZNIDAZOLE\". Vamos a hacer click en el nombre para ingresar a ver la informaci\u00f3n que tiene cargada.</li> <li>A la derecha encontrar\u00e1n la tabla de \"CONTENTS\" donde hay una lista de toda la informaci\u00f3n disponible para este compuesto. Recorran las diferentes secciones.</li> <li>Bajen hasta la secci\u00f3n \"Names and Identifiers\" \u00bfQue ven ah\u00ed?</li> </ol> <p>En esta secci\u00f3n podemos ver que un compuesto qu\u00edmico puede escribirse de muchas maneras: - The International Chemical Identifier (InChI) - A 27-character hash code derived from an InChI (InChIKey) - The Simplified Molecular-Input Line-Entry System (SMILES)</p> <p>Cada una de estas notaciones tiene sus ventajas y desventajas.</p> <p>Para cualquier trabajo quimioinform\u00e1tico, la notaci\u00f3n que usemos para las mol\u00e9culas va a ser clave. A continuaci\u00f3n encontrar\u00e1n un breve ilustraci\u00f3n de la sintaxis de cada notaci\u00f3n:</p> <p></p> <p></p> <p></p> <p>En el caso de que quieran profundizar sobre los diferentes tipos de notaci\u00f3n, en la publicaci\u00f3n de dicha imagen pueden encontrar m\u00e1s informaci\u00f3n al respecto. Pueden acceder ingresando a este link: https://doi.org/10.1186/s13321-020-00466-z</p>","tags":["practicos"]},{"location":"practicos/TP07_Quimioinformatica/#base-de-datos-2-chembl","title":"Base de datos 2: ChEMBL","text":"<p>La segunda base de datos que vamos a ver es ChEMBL, es una base de datos curada manualmente de mol\u00e9culas bioactivas del Laboratorio Europeo de Biolog\u00eda Molecular (EMBL).</p> <p></p> <p></p> <p></p> <p>Es una base de datos de mol\u00e9culas peque\u00f1as similares a f\u00e1rmacos bioactivos, contiene estructuras bidimensionales, propiedades calculadas (p. ej., logP, peso molecular, par\u00e1metros de Lipinski, etc.) y bioactividades resumidas (p. ej., constantes de uni\u00f3n, farmacolog\u00eda y datos ADMET).</p> <p>Ahora vamos a ingresar y a recorrerla. Pueden acceder ingresando a este link: ChEMBL. En la p\u00e1gina principal podemos ver que tenemos la opci\u00f3n de cargar una mol\u00e9cula en el recuadro blanco o de recorrer los datos disponibles. Vamos a volver a ingresar la misma mol\u00e9cula que usamos antes.</p>","tags":["practicos"]},{"location":"practicos/TP07_Quimioinformatica/#actividad-n-1-usando-chembl","title":"Actividad N\u00b0 1 usando ChEMBL","text":"<ol> <li>En el recuadro de b\u00fasqueda pegar esta mol\u00e9cula: \"(2S)-2-amino-3-(1H-indol-3-yl)propanoic acid\". (Es importante que le pongan las comillas!)</li> <li>Apretar en la lupa para buscar</li> <li>Ingresar al compuesto \"CHEMBL54976\".</li> <li>A la derecha encontrar\u00e1n una lista de toda la informaci\u00f3n disponible para este compuesto. Recorrer las diferentes secciones.</li> </ol>","tags":["practicos"]},{"location":"practicos/TP07_Quimioinformatica/#actividad-n2-usando-chembl","title":"Actividad N\u00b02 usando ChEMBL","text":"<ol> <li>Debajo del recuadro blanco, ingresar a \"Advanced Search\".</li> <li>En la pesta\u00f1a de \"Chemical Structure\" pegar esta mol\u00e9cula: <code>C1=CC=C(C=C1)CNC(=O)CN2C=CN=C2[N+](=O)[O-]</code></li> <li>Subir la \"Similarity\" al 100%</li> <li>Apretar el recuadro de \"Similarity\"</li> <li>Ingresar al compuesto \"CHEMBL110\".</li> <li>A la derecha encontrar\u00e1n una lista de toda la informaci\u00f3n disponible para este compuesto. Recorrer las diferentes secciones.</li> <li>\u00bfQue diferencias encuentran con la informaci\u00f3n en PubChem?</li> </ol>","tags":["practicos"]},{"location":"practicos/TP07_Quimioinformatica/#base-de-datos-3-surechembl","title":"Base de Datos 3: SureChEMBL","text":"<p>SureChEMBL es una base de datos qu\u00edmica que proporciona acceso a informaci\u00f3n valiosa sobre patentes relacionadas con compuestos qu\u00edmicos. Es una herramienta poderosa y ampliamente utilizada en el campo de la qu\u00edmica y la investigaci\u00f3n farmac\u00e9utica.</p> <p>Lo que distingue a SureChEMBL es su enfoque en el an\u00e1lisis y la extracci\u00f3n de datos de patentes qu\u00edmicas de manera eficiente y estructurada. La base de datos recopila y organiza millones de patentes de todo el mundo, permitiendo a los investigadores explorar una gran cantidad de informaci\u00f3n en busca de nuevos compuestos, reacciones qu\u00edmicas y avances tecnol\u00f3gicos.</p> <p>En 2013 la empresa Digital Science (due\u00f1a de SureChem) transfiri\u00f3 esta base de datos al EMBL-EBI, poniendola en el dominio p\u00fablico. Es la primera vez que una colecci\u00f3n de estructuras qu\u00edmicas de patentes mundiales de este tama\u00f1o se pone a disposici\u00f3n del p\u00fablico y de forma gratuita, lo que lo convierte en un avance significativo en el descubrimiento de f\u00e1rmacos. (Ver noticia)</p> <p></p> <p></p> <p></p> <p>Ahora vamos a ingresar y a recorrerla. Pueden acceder ingresando a este link: SureChEMBL. En la p\u00e1gina principal podemos ver que tenemos la opci\u00f3n de cargar una mol\u00e9cula en el recuadro blanco o de cargarla usando Marvin Js.</p>","tags":["practicos"]},{"location":"practicos/TP07_Quimioinformatica/#actividad-n1-usando-surechembl","title":"Actividad N\u00b01 usando SureChEMBL","text":"<ol> <li>Ingresar a la secci\u00f3n \"Structure Search\" que se encuentra debajo de la caja de b\u00fasqueda. </li> <li>Dentro del recuadro de Marvin Js, pegar este smiles <code>CC(C)(C)C1=CC(=C(C=C1NC(=O)C2=CNC3=CC=CC=C3C2=O)O)C(C)(C)C</code></li> <li>Seleccionar la b\u00fasqueda seg\u00fan Identical</li> <li>Apretar el recuadro de \"Search\"</li> <li>Seleccionar \"See More\" en la mol\u00e9cula \"SCHEMBL351373\"</li> </ol> <p>\u00bfCu\u00e1ntas patentes tiene este compuesto?</p>","tags":["practicos"]},{"location":"practicos/TP07_Quimioinformatica/#actividad-n2-usando-surechembl","title":"Actividad N\u00b02 usando SureChEMBL","text":"<ol> <li>Ingresar a la secci\u00f3n \"Structure Search\" que se encuentra debajo de la caja de b\u00fasqueda. </li> <li>Dentro del recuadro de Marvin Js, pegar este smiles <code>O=C1C=CNC2=CC=CC=C12</code></li> <li>Seleccionar la b\u00fasqueda seg\u00fan Substructure</li> <li>Apretar el recuadro de \"Search\"</li> </ol> <p>\u00bfQue encontramos haciendo este tipo de b\u00fasqueda?</p>","tags":["practicos"]},{"location":"practicos/TP07_Quimioinformatica/#parte-2-analisis-de-datos-quimioinformaticos","title":"Parte 2: An\u00e1lisis de datos quimioinform\u00e1ticos","text":"","tags":["practicos"]},{"location":"practicos/TP07_Quimioinformatica/#usando-rdkit","title":"Usando RDKit","text":"<p>RDKit es un software quimioinform\u00e1tico de c\u00f3digo abierto.</p> <p></p> <p>Fue desarrollado por Greg Landrum con numerosas contribuciones adicionales de la comunidad de c\u00f3digo abierto RDKit. Tiene una interfaz de programaci\u00f3n de aplicaciones para Python, Java, C++ y C#</p> <ul> <li>Homepage: http://www.rdkit.org Documentation, links</li> <li>Github (https://github.com/rdkit)) Downloads, bug tracker, git repository</li> <li>Sourceforge (http://sourceforge.net/projects/rdkit) Mailing lists</li> <li>Blog (https://greglandrum.github.io/rdkit-blog/) Tips, tricks, random stuff</li> <li>Tutorials (https://github.com/rdkit/rdkit-tutorials) Jupyter-based tutorials for using the RDKit</li> <li>KNIME integration (https://github.com/rdkit/knime-rdkit) RDKit nodes for KNIME</li> </ul>","tags":["practicos"]},{"location":"practicos/TP07_Quimioinformatica/#introduccion-a-google-colab","title":"Introducci\u00f3n a Google Colab","text":"","tags":["practicos"]},{"location":"practicos/TP07_Quimioinformatica/#que-es-google-colab","title":"\u00bfQu\u00e9 es Google Colab?","text":"<p>Colab, o Colaboratory, permite escribir y ejecutar Python en nuestro navegador. Nos da acceso a una m\u00e1quina de manera remota.Las ventajas son:</p> <ul> <li> <p>No es necesaria ninguna configuraci\u00f3n</p> </li> <li> <p>Es f\u00e1cil de compartir</p> </li> <li> <p>Podemos utilizar f\u00e1cilmente procesadores GPU (Graphics Processing Unit) que se diferencia del procesador \u201ccom\u00fan\u201d, el CPU (Central Processing Unit) porque tiene m\u00e1s n\u00facleos, m\u00e1s especializados y por lo tanto permite realizar c\u00f3mputos m\u00e1s complejos de manera m\u00e1s r\u00e1pida.</p> </li> </ul> <p>Una caracter\u00edstica no muy amigable es que no se pueden editar al mismo tiempo los documentos de Google Colab (que a partir de ahora llamaremos Notebooks)</p> <p>Vayan a https://colab.research.google.com/</p> <p>Y se les abre una ventana. En la parte inferior elijan: New Notebook</p> <p>Y ahora s\u00ed! Manos a la obra!</p>","tags":["practicos"]},{"location":"practicos/TP07_Quimioinformatica/#preparacion-del-notebook","title":"Preparaci\u00f3n del notebook","text":"<p>En la celda que se encuentra a continuaci\u00f3n vamos a importar e instalar todas las librer\u00edas que se van a usar.</p> <p>Primero vamos a instalar todo el software RDKit y otras librerias que vamos a usar con el comando <code>!pip install</code>. Este comando permite que las librerias est\u00e9n descargadas e instaladas en Google Colab.</p> <p>Luego le vamos a pedir que \"tenga a mano\" las librer\u00edas que vamos a usar con el comando <code>import</code>. De esta manera las tiene abiertas dentro de Google Colab para que est\u00e9n disponibles para usar.</p> <p>Si comparar\u00e1ramos las librer\u00edas de Python con libros f\u00edsicos, podr\u00edamos decir que <code>!pip install</code> es el equivalente a comprar el libro y tenerlo en nuestra estanter\u00eda y que <code>import</code> es el equivalente a agarrarlo de la estanteria y a abrirlo en nuestro escritorio.</p> <pre><code># Instalar las librerias\n!pip install rdkit\n</code></pre> <p>Ahora vamos a importar las librerias que vamos a usar. </p> <pre><code># Importar libreria de RDKit\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem\nfrom rdkit.Chem import Descriptors\nfrom rdkit.Chem import Draw\nfrom rdkit.Chem.Draw import rdMolDraw2D\n</code></pre> <p>A lo largo de este pr\u00e1ctico vamos a estar explorando las bases de datos quimioinform\u00e1ticos y trabajando con los comandos b\u00e1sicos de RDKit para trabajar con mol\u00e9culas.</p>","tags":["practicos"]},{"location":"practicos/TP07_Quimioinformatica/#generar-una-molecula-a-partir-de-smiles","title":"Generar una mol\u00e9cula a partir de SMILES","text":"<p>Para comenzar a trabajar necesitamos ingresar a la computadora el compuesto con el que vamos a trabajar, para eso vamos a generar una variable con la notaci\u00f3n del compuesto. En este caso, vamos a usar la notaci\u00f3n en smiles.</p> <p>En programaci\u00f3n se llama \"variable\" a la asignaci\u00f3n de una palabra para identificar un objeto. En este caso, la palabra \"smiles\" la vamos a usar como variable para identificar la secuencia en smiles del Benznidazol.</p> <pre><code># Generar la variable \"smiles\"\nsmiles = 'C1=CC=C(C=C1)CNC(=O)CN2C=CN=C2[N+](=O)[O-]'\n</code></pre> <p>Al generar la variable llamada smiles, guardamos la estructura en una palabra que podemos usar en el resto del c\u00f3digo.</p> <p>Vamos a ver que pasa si imprimimos la variable usando el comando print():</p> <pre><code># Imprimir la variable\nprint(smiles)\n</code></pre> <p>RDKit cuenta con un m\u00f3dulo llamado <code>Chem()</code></p> <p>Usando la analog\u00eda del comienzo, un m\u00f3dulo es un c\u00e1pitulo del libro de RDKit.</p> <p>Este m\u00f3dulo se escribe continuado por la acci\u00f3n que queremos que haga. Vamos a usarla mucho, a medida que la usemos vamos a ver que se puede hacer con ella.</p> <p>En este link encontrar\u00e1n todas las opciones posibles: https://www.rdkit.org/docs/source/rdkit.Chem.html</p> <p>En este caso, el m\u00f3dulo va a estar seguido de la funci\u00f3n <code>MolFromSmiles()</code>, porque queremos que transforme el string que generamos a una mol\u00e9cula.</p> <p>Vamos a generar la variable molecula para guardar la mol\u00e9cula de Benznidazol generada.</p> <pre><code># Generar una mol\u00e9cula a partir del smiles\nmolecula = Chem.MolFromSmiles(smiles)\n</code></pre>","tags":["practicos"]},{"location":"practicos/TP07_Quimioinformatica/#actividad-n1-usando-smiles","title":"Actividad N\u00b01 usando SMILES","text":"<p>\ud83d\udcad \u00bfQu\u00e9 pasa si ahora imprimimos la variable? </p><pre><code>print(molecula)\n</code></pre> <p>\ud83d\udcad \u00bfQu\u00e9 pasa si imprimo s\u00f3lo la mol\u00e9cula? </p><pre><code>molecula\n</code></pre> <p>Imprimiendo s\u00f3lo la variable que generamos con la informaci\u00f3n de la mol\u00e9cula podemos visualizarla!</p>","tags":["practicos"]},{"location":"practicos/TP07_Quimioinformatica/#actividad-n2-usando-smiles","title":"Actividad N\u00b02 usando SMILES","text":"<p>\ud83d\udcad \u00bfLo que observas en la celda anterior corresponde con lo que viste en PubChem y en ChEMBL?</p>","tags":["practicos"]},{"location":"practicos/TP07_Quimioinformatica/#generar-una-molecula-a-partir-de-inchi","title":"Generar una mol\u00e9cula a partir de InChI","text":"<p>Vamos a repetir el paso anterior pero usando la nomenclatura en InChI:</p> <pre><code># Generar la variable \"InChI\"\ninchi = \"InChI=1S/C12H12N4O3/c17-11(14-8-10-4-2-1-3-5-10)9-15-7-6-13-12(15)16(18)19/h1-7H,8-9H2,(H,14,17)\"\n</code></pre>","tags":["practicos"]},{"location":"practicos/TP07_Quimioinformatica/#actividad-n1-usando-inchi","title":"Actividad N\u00b01 usando InChI","text":"<p>\ud83d\udcad \u00bfQu\u00e9 pasa si ahora imprimimos la variable?</p> <p>Ahora vamos a generar la mol\u00e9cula usando RDKit</p> <p></p><pre><code># Generar una mol\u00e9cula a partir del InChI\nmolecula = Chem.MolFromInchi(inchi)\n</code></pre> Este tipo de objeto nos va a permitir realizar trabajar directamente con la mol\u00e9cula. <p>Ahora vamos a visualizarla!</p> <p>Para hacerlo, s\u00f3lo tienen que ejecutar el nombre de la variable: \ud83d\udc47</p> <pre><code># Visualizar la mol\u00e9cula\nmolecula\n</code></pre> <p>Y podemos transformar la nomenclatura de la mol\u00e9cula a InchiKey usando el siguiente comando:</p> <pre><code># Generar el InchiKey de una mol\u00e9cula\ninchikey = Chem.MolToInchiKey(molecula)\nprint(inchikey)\n</code></pre>","tags":["practicos"]},{"location":"practicos/TP07_Quimioinformatica/#propiedades-fisicoquimicas","title":"Propiedades fisicoqu\u00edmicas","text":"<p>Ahora vamos a algunas propiedades fisicoqu\u00edmicas. </p> <p>Para hacerlo, vamos a usar la funci\u00f3n <code>Descriptors</code> y <code>Chem</code> de RDKit.</p> <p>Esta funci\u00f3n permite indicar que tipo de descriptor queremos calcular para una mol\u00e9cula.</p> <p>Vamos a calcular:</p> <ul> <li> <p>El n\u00famero de donodores de enlaces de hidr\u00f3geno en la mol\u00e9cula </p> </li> <li> <p>El n\u00famero de aceptores de enlaces de hidr\u00f3geno en la mol\u00e9cula</p> </li> <li> <p>El peso molecular de la mol\u00e9cula</p> </li> <li> <p>El logP (coeficiente de partici\u00f3n octanol-agua) de la mol\u00e9cula</p> </li> <li> <p>El n\u00famero de enlaces rotativos en la mol\u00e9cula</p> </li> </ul> <p>RDKit permite calcular m\u00e1s descriptores, pero estos son los m\u00e1s usados. Si quieren saber m\u00e1s sobre esto pueden acceder al manual de RDKit</p> <p>Para calcular las propiedades podemos usar este c\u00f3digo reemplazando molecula por el nombre de la molecula que quieran usar: </p><pre><code># Calcular el peso molecular exacto de la mol\u00e9cula\nmolecular_weight = Descriptors.ExactMolWt(molecula)\n\n# Calcular el logP (coeficiente de partici\u00f3n octanol-agua) de la mol\u00e9cula\nlogp = Descriptors.MolLogP(molecula)\n\n# Calcular el n\u00famero de donodores de enlaces de hidr\u00f3geno en la mol\u00e9cula\nh_bond_donor = Descriptors.NumHDonors(molecula)\n\n# Calcular el n\u00famero de aceptores de enlaces de hidr\u00f3geno en la mol\u00e9cula\nh_bond_acceptors = Descriptors.NumHAcceptors(molecula)\n\n# Calcular el n\u00famero de enlaces rotativos en la mol\u00e9cula\nrotatable_bonds = Descriptors.NumRotatableBonds(molecula)\n</code></pre>","tags":["practicos"]},{"location":"practicos/TP07_Quimioinformatica/#actividad-n1-usando-las-propiedades-fisicoquimicas","title":"Actividad N\u00b01 usando las propiedades fisicoqu\u00edmicas","text":"<p>\ud83d\udcad Coincide con peso molecular calculado en el punto anterior con el obtenido por RDKit? </p><pre><code>#Escrib\u00ed el c\u00f3digo ac\u00e1\n</code></pre>","tags":["practicos"]},{"location":"practicos/TP07_Quimioinformatica/#ejercicio-integrador","title":"Ejercicio integrador","text":"<p>Para utilizar resolver este ejercicio seguir los siguientes pasos:</p> <ol> <li>Ingresar a la siguiente Notebook en este link</li> <li>Generar una copia de la Notebook en tu drive</li> <li>Empez\u00e1 a trabajar!</li> </ol>","tags":["practicos"]},{"location":"practicos/TP07_Quimioinformatica/#material-de-lectura-y-consulta","title":"Material de lectura y consulta","text":"<p>Si les interesa profundizar en el uso de Python les dejamos una notebook con algunos comandos para pr\u00e1cticar en este link</p> <p>Pueden ver todos las funciones de este m\u00f3dulo entrando a este link</p> <p>En el caso de que quieras profundizar en alguna (o buscar nuevas) ahi encontrar\u00e1s toda la informaci\u00f3n</p> <ul> <li> O'Boyle NM, Banck M, James CA, Morley C, Vandermeersch T, Hutchison GR. Open Babel: An open chemical toolbox. J Cheminform. 2011 Oct 7;3:33. DOI:10.1186/1758-2946-3-33. PMID:21982300.</li> <li> <p> A beginner's guide for understanding Extended-Connectivity Fingerprints(ECFPs). Manish Kumar (2021). </p> </li> <li> <p> Hu Y, Stumpfe D, Bajorath J. Recent Advances in Scaffold Hopping. J Med Chem. 2017 Feb 23;60(4):1238-1246. DOI:10.1021/acs.jmedchem.6b01437. Epub 2016 Dec 21. PMID:28001064.</p> </li> <li> Mitternacht S. FreeSASA: An open source C library for solvent accessible surface area calculations. F1000Res. 2016 Feb 18;5:189. DOI:10.12688/f1000research.7931.1. PMID:26973785.</li> <li> Bolcato G, Heid E, Bostr\u00f6m J. On the Value of Using 3D Shape and Electrostatic Similarities in Deep Generative Methods. J Chem Inf Model. 2022 Mar 28;62(6):1388-1398. DOI:10.1021/acs.jcim.1c01535. Epub 2022 Mar 10. PMID:35271260.</li> <li> Ertl P, Rohde B, Selzer P. Fast calculation of molecular polar surface area as a sum of fragment-based contributions and its application to the prediction of drug transport properties. J Med Chem. 2000 Oct 5;43(20):3714-7. DOI:10.1021/jm000942e. PMID:11020286.</li> <li> ChEBI User Guide </li> </ul>","tags":["practicos"]},{"location":"practicos/TP08_Clustering_Data_Mining/","title":"Practico Ocho","text":"","tags":["practicos"]},{"location":"practicos/TP08_Clustering_Data_Mining/#tp-8-clustering-y-data-mining","title":"TP 8. Clustering y Data Mining","text":"<p> Materiales</p>","tags":["practicos"]},{"location":"practicos/TP08_Clustering_Data_Mining/#slides-mostrados-en-clase","title":"Slides mostrados en clase","text":"<ul> <li> Slides</li> </ul>","tags":["practicos"]},{"location":"practicos/TP08_Clustering_Data_Mining/#software-a-usar","title":"Software a usar","text":"<ul> <li>R (ya instalado en la VM).</li> <li>RStudio (ya instalado en la VM)</li> </ul>","tags":["practicos"]},{"location":"practicos/TP08_Clustering_Data_Mining/#recursos-online","title":"Recursos Online","text":"<ul> <li>Introducci\u00f3n a R, TPP de esta materia: Parte 1 y Parte 2</li> <li>Clustering jer\u00e1rquico en R</li> <li>Detalles del c\u00e1lculo de Silhouette (y mucho m\u00e1s)</li> <li>Curso online de R de Coursera (se puede hacer gratis) (en ese caso no da certificado)</li> <li>Data Tables: Introducci\u00f3n oficial y otra p\u00e1gina con m\u00e1s info</li> <li>ggplot2: Vistazo r\u00e1pido, detalles sobre los tipos de plots, cheatsheet e informaci\u00f3n sobre colores y daltonismo</li> <li>dendextend: Detalle del paquete</li> </ul>","tags":["practicos"]},{"location":"practicos/TP08_Clustering_Data_Mining/#objetivos","title":"Objetivos","text":"<ul> <li>Familiarizarse con el funcionamiento del clustering jer\u00e1rquico aglomerativo.</li> <li>Familiarizarse con el m\u00e9todo de clustering particional K-means.</li> <li>Explorar algunas medidas de calidad de los clusters, como la silueta o silhouette.</li> <li>Usar m\u00e9todos de clustering con herramientas de programaci\u00f3n para resolver problemas biol\u00f3gicos</li> </ul>","tags":["practicos"]},{"location":"practicos/TP08_Clustering_Data_Mining/#introduccion-al-tema","title":"Introducci\u00f3n al tema","text":"<p>Hoy vamos a retomar el trabajo con R. Recomendamos repasar o tener a mano los TPPs de esta materia por si necesitan recordar como hacer ciertos comandos (Parte 1 y Parte 2).</p> <p>Como mencionamos en los TPPs, es cada vez m\u00e1s normal que experimentos biol\u00f3gicos nos permitan analizar miles a millones de interacciones biol\u00f3gicas a la vez, lo que resulta en tablas con millones de datos. Esto hace necesario entonces saber utilizar herramientas que nos permitan extraer, o minar, informaci\u00f3n de estos enormes conjuntos de datos. A este proceso lo vamos a denominar Data Mining.</p> <p>En este TP nos vamos a enfocar en m\u00e9todos de clustering, los cuales nos permiten agrupar elementos analizados en base a datos observados sobre ellos. Esto tiene muchas utilidades, como puede ser entender mejor las diferencias entre grupos conocidos, encontrar diferentes grupos dentro del conjunto datos analizado, o remover datos redundantes, entre otros.</p> <p>Si bien este TP vamos a enfocarnos m\u00e1s que nada en aprender las t\u00e9cnicas, el objetivo final de este proceso es identificar agrupamientos naturales en los datos con alguna relevancia biol\u00f3gica.</p>","tags":["practicos"]},{"location":"practicos/TP08_Clustering_Data_Mining/#ejercicio-1-clustering-jerarquico-manual","title":"Ejercicio 1 - Clustering Jer\u00e1rquico Manual","text":"<p>Para empezar este TP vamos a realizar un peque\u00f1o clustering jer\u00e1rquico a mano para repasar el concepto.</p> <p>Supongamos que tenemos cuatro genes (A, B, C y D) para los cuales medimos el nivel de expresi\u00f3n a las 0hs, 1hs y 2hs luego de alg\u00fan tratamiento:</p> gen t_0h t_1h t_2h genA 2 4 8 genB -1 -1 -2 genC -2 0 1 genD 0 -1 -6 <p>Queremos entonces agrupar a los diferentes genes por como var\u00edan sus niveles de expresi\u00f3n cuando se aplica dicho tratamiento. Para hacer esto vamos a:</p> <p>1. Calcular la distancia euclidiana entre los diferentes genes</p> <p>2. Construir una matriz de distancias</p> <p>3. Agruparlos usando clustering jer\u00e1rquico donde el criterio de agregaci\u00f3n va a ser \"vecino m\u00e1s lejano\" o complete linkage</p> <p>4. Armar un esquema del dendograma o \u00e1rbol de similitud que resulta de este clustering</p> <p>5. Repetir todo lo anterior, pero estandarizando previamente los datos de niveles de expresi\u00f3n</p> <p>Si no entienden algunos de estos conceptos pueden leer un poco m\u00e1s sobre ellos a continuaci\u00f3n (y m\u00e1s todav\u00eda en la te\u00f3rica):</p> Distancia euclidiana <p>Es una de las varias formas de calcular una distancia entre dos vectores de datos, lo cual es necesario al momento de calcular una matriz de distancias. Por ejemplo, suponiendo que tenemos 2 vectores de forma \\(V = (x, y, z)\\) la distancia euclidiana entre ellos se calcula como:</p> \\[ distanciaEuclidiana(V_1, V_2) = \\sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2 + (z_1 - z_2)^2} \\] <p>Aplicando esto a nuestros datos, la distancia entre los genes A y B se calcula como:</p> \\[ distanciaEuclidiana(genA, genB) = \\sqrt{(2 - (-1))^2 + (4 - (-1))^2 + (8 - (-2))^2} = 11,58 \\] Matriz de distancias <p>Es una matriz donde tanto las filas como las columnas representan un mismo conjunto de elementos y en cada intersecci\u00f3n se pone la distancia (en nuestro caso euclidiana) entre dos elementos espec\u00edficos. Es la base de muchos m\u00e9todos de clustering.</p> <p>Para nuestros datos la matriz de distancias entre los cuatro genes es:</p> genA genB genC genD genA 0 genB 11,58 0 genC 9 3,32 0 genD 15 4,12 7,35 0 <p>Como el orden de los elementos es igual para las filas que para las columnas, en la diagonal se compara cada elemento contra s\u00ed mismo por lo que la distancia es 0. Por otro lado, estamos llenando solo la mitad de la matriz ya que las matrices de distancia son matrices sim\u00e9tricas, es decir, que el tri\u00e1ngulo superior derecho de la matriz va a ser un reflejo del tri\u00e1ngulo inferior izquierdo.</p> Clustering jer\u00e1rquico <p>El clustering jer\u00e1rquico es una forma de agrupar elementos dependiendo de que tan similares son entre ellos. Usa un algoritmo bastante sencillo de entender que se basa en una matriz de distancias:</p> <ol> <li> <p>Sin considerar a la diagonal, encontrar el par de elementos (fila, columna) que son m\u00e1s similares entre s\u00ed (el menor n\u00famero en la matriz de distancias). En nuestra matriz de distancias los elementos m\u00e1s parecidos son \"genB\" y \"genC\" ya que tienen la menor similitud (3,32)</p> </li> <li> <p>Dejar constancia de dicha similitud y reconstruir la matriz, reemplazando ambos elementos por uno nuevo (saco los elementos \"genB\" y \"genC\" y agrego el elemento \"genB+C\")</p> </li> <li> <p>Al momento de calcular la nueva distancia entre este nuevo elemento (\"genB+C\") y el resto de los elementos de la matriz, usar alg\u00fan criterio de agregaci\u00f3n (por ejemplo: single linkage, average linkage o complete linkage)</p> </li> <li> <p>Volver al paso 1 hasta que todos los elementos est\u00e9n unidos entre s\u00ed</p> </li> </ol> <p>Una vez hecho esto puedo dibujar el clustering jer\u00e1rquico teniendo en cuenta qu\u00e9 elementos se juntaron con qu\u00e9 elementos.</p> Criterios de agregaci\u00f3n <p>Los criterios de agregaci\u00f3n indican que operaci\u00f3n hay que hacer al momento de calcular la distancia entre un nuevo elemento creado en una matriz de distancias y los ya existentes. Cada uno tiene sus ventajas y desventajas.</p> <p>Siguiendo con nuestro ejemplo, si queremos calcular la distancia entre el nuevo elemento \"genB+C\" y el \"genA\":</p> <ul> <li>Single Linkage: la nueva distancia es la menor entre las distancias \\(dist(genA, genB)\\) y \\(dist(genA, genC)\\)</li> <li>Complete Linkage: la nueva distancia es la mayor entre las distancias \\(dist(genA, genB)\\) y \\(dist(genA, genC)\\)</li> <li>Average Linkage: la nueva distancia es el promedio de las distancias \\(dist(genA, genB)\\) y \\(dist(genA, genC)\\)</li> </ul> <p>Para simplificar las cuentas durante la clase, les dejamos ac\u00e1 la tabla con los datos estandarizados. Para estandarizar, restamos a cada dato el promedio de los tres tiempos para ese gen y dividimos el resultado por la desviaci\u00f3n est\u00e1ndar de los tres tiempos para ese gen, es decir:</p> \\[ datoEstandarizado(genA, t_0) = \\frac{dato(genA, t_0) - promedio(genA)}{desviacionEstandar(genA)} \\] gen t_0h t_1h t_2h genA -0.87 -0.22 1.09 genB 0.58 0.58 -1.15 genC -1.09 0.22 0.87 genD 0.73 0.41 -1.14 <p>6. Comparando los clusterings obtenidos con los datos estandarizados y sin estandarizar.</p> <ol> <li> <p>\u00bfQu\u00e9 diferencias observan?</p> </li> <li> <p>\u00bfCu\u00e1l de los dos clusterings les parece mejor para este escenario donde quer\u00edamos evaluar c\u00f3mo afecta un tratamiento los niveles de expresi\u00f3n de diferentes genes?</p> </li> <li> <p>\u00bfLes parece qu\u00e9 es siempre correcto estandarizar los datos de esta forma o se les ocurre escenarios donde no es as\u00ed?</p> </li> </ol>","tags":["practicos"]},{"location":"practicos/TP08_Clustering_Data_Mining/#ejercicio-2-agrupando-flores-por-especies","title":"Ejercicio 2 - Agrupando flores por especies","text":"","tags":["practicos"]},{"location":"practicos/TP08_Clustering_Data_Mining/#introduccion-al-data-set","title":"Introducci\u00f3n al data set","text":"<p>En este ejercicio vamos a trabajar una vez m\u00e1s con el data set iris, el cual es un set de datos que viene por defecto con R y est\u00e1 siempre cargado en memoria.</p> <p>Este data set contiene las medidas de ancho (width) y largo (length) de los s\u00e9palos y los p\u00e9talos para 3 especies de flores diferentes: setosa, versicolor, y virginica (todas del Genus Iris). Tiene mediciones de 150 flores, 50 por especie.</p> S\u00e9palo vs p\u00e9talo <p> </p> <p>Antes que nada vamos a familiarizarnos un poco con este data set.</p> <p>1) Corran el siguiente c\u00f3digo y vean el plot resultante:</p> <pre><code>library(data.table)\nlibrary(ggplot2)\n\n#Transformo a iris en un *Data Table* (que aca realmente no hace falta, pero para despues)\ndt_iris &lt;- as.data.table(iris)\n\n#Hago un plot comparando el largo de los sepalos y los petalos\n#Estoy cambiando la forma y el color segun la especie\np &lt;- ggplot(data = dt_iris, aes(x = Sepal.Length, y = Petal.Length, color = Species)) +\n    geom_point(size = 2) +\n    theme_bw() +\n    xlab(\"Sepal Length\") +\n    ylab(\"Petal Length\") +\n    ggtitle(\"Sepal Length vs Petal Length per Species\") +\n    theme(plot.title = element_text(size = 16, hjust = 0.5),\n          axis.title = element_text(size = 14),\n          axis.text = element_text(size = 12)) +\n    scale_colour_manual(values = c(\"#004D40\",\"#D81B60\",\"#FFC107\"))\n\nprint(p)\n</code></pre> <p>Podemos ver que con solo plotear el largo de los p\u00e9talos y los s\u00e9palos ya estamos viendo diferencias entre las especies. Es te\u00f3ricamente posible agregar una tercera dimensi\u00f3n para plotear otra de las variables, e incluso agregar la cuarta variable como \"tama\u00f1o\" de los diferentes puntos, pero dichos plots van a resultar considerablemente mas complejos al momento de leerlos.</p>","tags":["practicos"]},{"location":"practicos/TP08_Clustering_Data_Mining/#problema-a-resolver","title":"Problema a resolver","text":"<p>En este ejercicio vamos a suponer que alguien apret\u00f3 el bot\u00f3n equivocado y borr\u00f3 la columna Species de dicha tabla. Como nos acordamos de que eran tres especies y que ten\u00edan diferencias en sus largos y anchos de p\u00e9talos y s\u00e9palos, queremos entonces usar m\u00e9todos de clustering para tratar de recuperar lo mejor que podamos los tres grupos de flores.</p> <p>Dicho esto vamos a hacer un poco de trampa y vamos a comparar visualmente lo que vamos obteniendo por los m\u00e9todos de clustering con lo que nosotros sabemos es verdad.</p> <p>Por \u00faltimo, c\u00f3mo vamos a tener que hacer varios plots similares, vamos a aprovechar la oportunidad y vamos a usar por primera vez funciones de R creadas por nosotros.</p>","tags":["practicos"]},{"location":"practicos/TP08_Clustering_Data_Mining/#guardar-el-plot-en-un-pdf","title":"Guardar el plot en un PDF","text":"<p>Vamos a crear una funci\u00f3n que guarde diferentes plots como PDFs.</p> <p>2) Copien el siguiente c\u00f3digo y modifiquen las secciones que dicen <code>@@EDITAR@@</code>. Para esto vean el punto 1) y as\u00edgnenle a cada par\u00e1metro de la funci\u00f3n el valor que ten\u00eda en dicho punto, por ejemplo <code>x_colname = \"Sepal.Length\"</code> (el nombre de las columnas v\u00e1 entre comillas porque estamos usando <code>aes_string()</code> y no <code>aes()</code>). Una vez hecho esto, corran la funci\u00f3n para replicar el plot hecho en el punto 1) y guardarlo en un archivo llamado 01_Sepal_vs_Petal_Length_per_Species.pdf.</p> C\u00f3digoC\u00f3digo con comentarios <pre><code>library(data.table)\nlibrary(ggplot2)\n\n#### FUNCIONES AUXILIARES ####\nplotData2PDF_wColor &lt;- function(data_par,\n                                x_colname, y_colname, color_colname,\n                                x_label, y_label, plot_title,\n                                pdf_file) {\n    p &lt;- ggplot(data = data_par, aes_string(x = x_colname, y = y_colname, color = color_colname)) +\n        geom_point(size = 2) +\n        theme_bw() +\n        xlab(x_label) +\n        ylab(y_label) +\n        ggtitle(plot_title) +\n        theme(plot.title = element_text(size = 16, hjust = 0.5),\n              axis.title = element_text(size = 14),\n              axis.text = element_text(size = 12)) +\n        scale_colour_manual(values = c(\"#004D40\",\"#D81B60\",\"#FFC107\"))\n\n    pdf(file = pdf_file, width = 8, height = 7)\n    print(p)\n    dev.off()\n}\n\n#### CODIGO PRINCIPAL ####\ndt_iris &lt;- as.data.table(iris)\n\nplotData2PDF_wColor(data_par = dt_iris,\n                    x_colname = \"@@EDITAR@@\", \n                    y_colname = \"@@EDITAR@@\", \n                    color_colname = \"@@EDITAR@@\",\n                    x_label = \"@@EDITAR@@\", \n                    y_label = \"@@EDITAR@@\", \n                    plot_title = \"@@EDITAR@@\",                        \n                    pdf_file = \"01_Sepal_vs_Petal_Length_per_Species.pdf\")    \n</code></pre> <pre><code>library(data.table)\nlibrary(ggplot2)\n\n#Estoy usando comentarios rodeados de cuatro numerales para delimitar secciones de mi c\u00f3digo \n#Esto no es puramente est\u00e9tico, sino que tambi\u00e9n es aprovechado por *RStudio* para crear una de barra de \n#navegaci\u00f3n del c\u00f3digo (es la barra horizontal entre el script y la consola)\n#### FUNCIONES AUXILIARES ####\nplotData2PDF_wColor &lt;- function(data_par,\n                                x_colname, y_colname, color_colname,\n                                x_label, y_label, plot_title,\n                                pdf_file) {\n    #La funci\u00f3n *aes_string()* es similar a *aes()*, solo que en este caso los nombres de las columnas \n    #tienen que ser *strings* (recuerden que con *aes()* se escriben sin comillas)\n    #Esto es ideal para cuando el nombre de la columna utilizar esta guardado en una variable\n    p &lt;- ggplot(data = data_par, aes_string(x = x_colname, y = y_colname, color = color_colname)) +\n        geom_point(size = 2) +\n        theme_bw() +\n        xlab(x_label) +\n        ylab(y_label) +\n        ggtitle(plot_title) +\n        theme(plot.title = element_text(size = 16, hjust = 0.5),\n              axis.title = element_text(size = 14),\n              axis.text = element_text(size = 12)) +\n        scale_colour_manual(values = c(\"#004D40\",\"#D81B60\",\"#FFC107\"))\n\n    #*pdf()* \"abre\" un archivo pdf. Todo lo que se imprima hasta cerrarlo va a ir a \u00e9l, \n    #en vez de a la pesta\u00f1a *Plots* de *RStudio*\n    #8 y 7 indican el ancho y el alto del pdf en pulgadas\n    pdf(file = pdf_file, width = 8, height = 7)\n    print(p)\n    #La funci\u00f3n *dev.off()* cierra el plot abierto, en este caso el pdf.\n    dev.off()\n}\n\n#### CODIGO PRINCIPAL ####\ndt_iris &lt;- as.data.table(iris)\n\nplotData2PDF_wColor(data_par = dt_iris,\n                    x_colname = \"@@EDITAR@@\", \n                    y_colname = \"@@EDITAR@@\", \n                    color_colname = \"@@EDITAR@@\",\n                    x_label = \"@@EDITAR@@\", \n                    y_label = \"@@EDITAR@@\", \n                    plot_title = \"@@EDITAR@@\",      \n                    pdf_file = \"01_Sepal_vs_Petal_Length_per_Species.pdf\") \n</code></pre> <p>3) Usando la funci\u00f3n que acabamos de crear, vean como se distribuyen los puntos al comparar Sepal.Width contra Petal.Width. Guarden este plot en un archivo llamado 02_Sepal_vs_Petal_Width_per_Species.pdf.</p>","tags":["practicos"]},{"location":"practicos/TP08_Clustering_Data_Mining/#clustering-jerarquico","title":"Clustering jer\u00e1rquico","text":"<p>Lo primero que vamos a hacer entonces es usar un clustering jer\u00e1rquico para agrupar a las 150 filas en 3 grupos seg\u00fan los valores de las 4 medidas. Un problema que tenemos es que por ahora no hay ninguna forma de identificar a una fila espec\u00edfica, as\u00ed que le vamos a agregar un ID num\u00e9rico a cada fila. Debido al orden que tienen las filas de dt_iris, los primeros 50 IDs van a corresponder a flores de la especie setosa, los segundos 50 a versicolor y los \u00faltimos a virginica (aunque supuestamente esto no lo sabemos).</p> <p>4) Corran el siguiente c\u00f3digo para crear la matriz de datos que vamos a usar al momento de clusterizar. Lean los comentarios en la segunda pesta\u00f1a para entender que estamos haciendo.</p> C\u00f3digoC\u00f3digo con comentarios <pre><code>dt_iris$row_id &lt;- c(1:dt_iris[, .N])\n\nsetcolorder(dt_iris, c(\"row_id\"))\n\nmatriz_datos &lt;- as.matrix(dt_iris[, -c(\"Species\")], rownames = 1)\n</code></pre> <pre><code>#Agregamos una nueva columna denominada row_id que tiene un numero entre 1 y 150\n#dt_iris[, .N] es una funci\u00f3n de *Data Tables* que me devuelve el numero de filas en la tabla\n#El numero de filas tambien se puede conseguir haciendo nrow(dt_iris)\ndt_iris$row_id &lt;- c(1:dt_iris[, .N])\n\n#Aca estamos cambiando el orden de las columnas a *dt_iris*.\n#No hace falta asignar esto a *dt_iris* ya que *setcolorder* modifica la variable misma \n#Como solo le estamos pasando 1 columna, lo que estamos haciendo es mover esa columna al principio\n#(al usar as\u00ed *setcolorder* las otras se quedan donde estan)\nsetcolorder(dt_iris, c(\"row_id\"))\n\n#Similar a lo que hicimos en el TP anterior, estamos transformando nuestros datos a una matriz\n#donde la primer columna (en este caso *row_id*) va a transformarse en los nombres de las filas\n#Estamos sacando a la columna *Species* ya que queremos simular que no tenemos esta informacion\n#(la columna *Species* va a estar todavia en *dt_iris*, pero no en *matriz_datos*)\nmatriz_datos &lt;- as.matrix(dt_iris[, -c(\"Species\")], rownames = 1)\n</code></pre> <p>5) Usando la matriz de datos reci\u00e9n creada:</p> <p>5.1) Usen la funci\u00f3n <code>dist()</code> para crear una matriz de distancias euclidianas que muestre tambi\u00e9n la diagonal.</p> <pre><code>matriz_distancias &lt;- dist(matriz_datos, method = \"euclidean\", diag = T)\n</code></pre> <p>Donde method = \"euclidean\" le est\u00e1 diciendo a la funci\u00f3n dist que tiene que calcular las distancias euclidianas entre filas y diag = T hace que deje la diagonal de ceros en el output.</p> <p>5.2) Creen un clustering jer\u00e1rquico basado en la matriz de distancias usando el criterio de agregaci\u00f3n complete linkage. El clustering jer\u00e1rquico se hace con la funci\u00f3n <code>hclust</code>, la cual se usa:</p> <pre><code>clustering_jerarquico &lt;- hclust(matriz_distancias, method = \"complete\")\n</code></pre> <p>Donde <code>method = \"complete\"</code> est\u00e1 indic\u00e1ndole a la funci\u00f3n que criterio de agregaci\u00f3n usar al momento de combinar elementos. Pueden usar <code>help(hclust)</code> para ver otros posibles criterios.</p> <p>5.3) Usen la funci\u00f3n <code>plot</code> para plotear <code>clustering_jerarquico</code>. Usen el par\u00e1metro <code>main</code> para cambiarle el t\u00edtulo al plot indicando que es un clustering jer\u00e1rquico, que usa complete linkage.</p> <p>5.4) Mirando el plot reci\u00e9n creado, \u00bfles es f\u00e1cil distinguir a simple vista los tres grupos de especies en el clustering jer\u00e1rquico? (recuerden que pueden usar el bot\u00f3n Zoom para agrandar el plot).</p>","tags":["practicos"]},{"location":"practicos/TP08_Clustering_Data_Mining/#mejorar-el-plot-del-clustering-jerarquico","title":"Mejorar el plot del clustering jer\u00e1rquico","text":"<p>6) Una cosa que vendr\u00eda bien al momento de leer el plot reci\u00e9n creado ser\u00eda colorear cada flor dependiendo de su especie. Si bien esto no es posible en este caso usando solo la funci\u00f3n <code>plot()</code>, hay paquetes de R que nos van a permitir hacer esto:</p> <p>6.1) Usen la funci\u00f3n <code>install.packages()</code> e instalen la librer\u00eda dendextend (recuerden que al usar <code>install.packages()</code> el nombre del paquete va entre comillas). Luego corran el siguiente c\u00f3digo:</p> C\u00f3digoC\u00f3digo con comentarios <pre><code>library(dendextend)\n\n#Estoy asumiendo que guardaron la salida de *hclust()* en una variable llamada clustering_jerarquico\n#De no ser asi, cambien el nombre de la variable a continuacion por lo que corresponda\ndend &lt;- as.dendrogram(clustering_jerarquico)\n\ncolores_especies &lt;- c(\"#004D40\",\"#D81B60\",\"#FFC107\")\ncolors_aux &lt;- rep(colores_especies, each = 50)\nlabels_colors(dend) &lt;- colors_aux[order.dendrogram(dend)]\n\ndend &lt;- dend %&gt;% set(\"labels_cex\", 0.6)\n\npdf_file &lt;- \"11_Clustering_jerarquico_complete_linkage.pdf\"\npdf(file = pdf_file, width = 18, height = 6)\n\nplot(x = dend, main = \"Clustering Jer\u00e1rquico - Complete Linkage - Color per Species\")\n\ndev.off()\n</code></pre> <pre><code>library(dendextend)\n\n#Estoy asumiendo que guardaron la salida de *hclust()* en una variable llamada clustering_jerarquico\n#De no ser asi, cambien el nombre de la variable a continuacion por lo que corresponda\n#Aca estoy transformando la variable *clustering_jerarquico* que es de tipo *hclust* a un *dendrogram*, \n#que es una variable usada por el paquete *dendextend*\ndend &lt;- as.dendrogram(clustering_jerarquico)\n\n#La funcion *labels_colors()* me permite asignar a mano los colores para los 150 labels del dendrograma\n#Ahora bien, yo se que originalmente en la tabla las primera 50 filas corresponden al color 1 y asi\n#Lo que estoy haciendo aca es armar una lista de 150 colores ordenada como esta en la tabla original y luego\n#reordenarlas para que coincidan con el orden de los IDs en el dendrograma\ncolores_especies &lt;- c(\"#004D40\",\"#D81B60\",\"#FFC107\")\ncolors_aux &lt;- rep(colores_especies, each = 50)\nlabels_colors(dend) &lt;- colors_aux[order.dendrogram(dend)]\n\n#Esto simplemente es para achicar un poco el texto de los labels para que no choquen entre si\n#El simbolo %&gt;% cumple una funcion similar al + en ggplot\ndend &lt;- dend %&gt;% set(\"labels_cex\", 0.6)\n\n#Creo el pdf de salida y guardo el clustering jer\u00e1rquico\npdf_file &lt;- \"11_Clustering_jerarquico_complete_linkage.pdf\"\npdf(file = pdf_file, width = 18, height = 6)\n\nplot(x = dend, main = \"Clustering Jer\u00e1rquico - Complete Linkage - Color per Species\")\n\ndev.off()\n</code></pre> <p>6.2) Abran el archivo 11_Clustering_jerarquico_complete_linkage.pdf. \u00bfPueden ahora distinguir los tres grupos de especies en el clustering jer\u00e1rquico? \u00bfCu\u00e1les especies les parecen mejor agrupadas? (los colores de las especies corresponden al color usado en el plot creado en los puntos 1) y 2))</p>","tags":["practicos"]},{"location":"practicos/TP08_Clustering_Data_Mining/#single-linkage","title":"Single Linkage","text":"<p>7) Hasta el momento s\u00f3lo utilizamos complete linkage al momento de hacer nuestros clustering jer\u00e1rquicos, pero ser\u00eda interesante ver como es el dendrograma resultante de hacer el clustering usando otro criterio de agregaci\u00f3n, por ejemplo el single linkage. Para esto:</p> <p>7.1) Vuelvan a correr la funci\u00f3n <code>hclust()</code> como en 5.2), pero ahora usen <code>method = \"single\"</code> y guarden el clustering resultante en una nueva variable. Luego usen el c\u00f3digo de 6.1) editando lo que sea necesario para crear un archivo que contenga al dendrograma hecho a partir del clustering jer\u00e1rquico que usa single linkage como criterio de agregaci\u00f3n. Nombren a este archivo 12_Clustering_jerarquico_single_linkage.pdf.</p> <p>7.2) \u00bfQu\u00e9 diferencias ven entre este dendrograma y el creado en 6.2)? \u00bfPueden relacionar estas diferencias con lo que saben de single linkage y complete linkage?</p> <p>7.3) Ignorando los colores, \u00bfcu\u00e1l les parece el mejor criterio de agregaci\u00f3n para este caso donde queremos recuperar tres clusters?</p>","tags":["practicos"]},{"location":"practicos/TP08_Clustering_Data_Mining/#asignando-clusters","title":"Asignando clusters","text":"<p>Cuando uno mira el \u00e1rbol creado en el punto 6) es com\u00fan detectar que ciertas flores son m\u00e1s similares entre s\u00ed que otras, y suponer que entonces pertenecen a un mismo grupo. Esto se puede calcular computacionalmente \"cortando\" el \u00e1rbol usando un cierto umbral de similitud y agrupando en un mismo cluster a aquellos elementos que queden por debajo de ese umbral.</p> <p>Esto se puede hacer de dos formas, o determinando el umbral de similitud o determinando la cantidad de clusters a crear.</p> <pre><code>clusters_porAltura &lt;- cutree(clustering_jerarquico, h = @@EDITAR@@)\nclusters_porCantidad &lt;- cutree(clustering_jerarquico, k = @@EDITAR@@)\n</code></pre> <p>Donde <code>h</code> es el par\u00e1metro que recibe la altura de similitud a la cual cortar (eje y en el plot anterior) y <code>k</code> es el par\u00e1metro que recibe la cantidad de clusters a crear. Hay que usar uno o el otro.</p>","tags":["practicos"]},{"location":"practicos/TP08_Clustering_Data_Mining/#hacer-clusters-y-plots","title":"Hacer clusters y plots","text":"<p>Por \u00faltimo vamos a querer recrear el plot generado en los puntos 1) y 2), pero ahora mostrando informaci\u00f3n tanto de las especies originales (con el color) como de la agrupaci\u00f3n resultante del clustering jer\u00e1rquico (con la forma). Vamos a utilizar los datos del clustering jer\u00e1rquico que usa el criterio de agregaci\u00f3n complete linkage.</p> <p>8) Lo primero es entonces agregar la informaci\u00f3n del clustering jer\u00e1rquico a nuestro dt_iris; para ello:</p> <p>8.1) Usen la <code>cutree</code> para dividir a los datos obtenidos en 5.2) en 3 clusters.</p> <p>8.2) Asignen esa informaci\u00f3n a una nueva columna en la tabla dt_iris llamada CJ_cluster (como en este caso <code>cutree()</code> devuelve los datos en el mismo orden que est\u00e1n en la tabla se puede hacer directamente con <code>&lt;-</code>, no hace falta usar <code>merge()</code>).</p> <p>8.3) Por el momento la variable es num\u00e9rica, pero para nosotros los n\u00fameros 1, 2 y 3 son categor\u00edas que te\u00f3ricamente corresponden a las especies (aunque no sabemos qu\u00e9 categor\u00eda corresponde a que especie). Corran el siguiente c\u00f3digo para convertir la columna reci\u00e9n creada en un factor:</p> <pre><code>#En este caso poner los levels a mano no es 100% necesario, pero no viene mal\n#Recuerden que no sabemos que numero corresponde a que especie\n#(porque ademas ya vimos que no hay un match perfecto 1 a 1)\ndt_iris$CJ_cluster &lt;- factor(dt_iris$CJ_cluster, levels = c(1, 2, 3))\n</code></pre> <p>9) Ahora queremos hacer un plot similar al creado en el punto 2), pero donde la columna Species determine el color y la columna CJ_cluster determine la forma de los diferentes puntos del plot; para ello:</p> <p>9.1) Copien la funci\u00f3n <code>plotData2PDF_wColor()</code> y c\u00e1mbienle en nombre a <code>plotData2PDF_wColorAndShape()</code>. Modifiquen esta nueva funci\u00f3n considerando lo siguiente:</p> <ul> <li>Agreguen un par\u00e1metro a la funci\u00f3n el cual va a recibir el nombre de la columna que determina la forma, o shape, de los puntos.</li> <li>Modifiquen la funci\u00f3n <code>aes_string()</code>, agregando la caracter\u00edstica <code>shape</code> y asign\u00e1ndole el valor del par\u00e1metro agregado.</li> <li>Agreguen la funci\u00f3n <code>scale_shape_manual()</code> a <code>ggplot</code> para definir a mano las tres formas. Usen los valores <code>c(2, 4, 1)</code>.</li> </ul> <p>9.2) Usando la funci\u00f3n que acabamos de crear, vean como se distribuyen los puntos al comparar Sepal.Length contra Petal.Length usando la columna Species para determinar el color y la columna CJ_cluster para determinar la forma de los diferentes puntos. Guarden este plot en un archivo llamado 21_Sepal_vs_Petal_Length_per_Species_CJ3.pdf.</p> <p>9.3) Abran el archivo reci\u00e9n creado. \u00bfCu\u00e1les especies les parecen mejor agrupadas? Entre este plot y el dendrograma creado en 11_Clustering_jerarquico_complete_linkage.pdf \u00bfCu\u00e1l les parece la mejor manera de representar este clustering? \u00bfPor qu\u00e9?</p> <p>Importante - Clustering vs Plot</p> <p>Tengan en cuenta que al momento de clusterizar estamos usando los datos de las cuatro columnas de la tabla. Sin embargo, en este \u00faltimo plot estamos viendo solo la relaci\u00f3n entre dos. Por esta raz\u00f3n, este plot no es realmente representativo del clustering que estamos haciendo.</p> <p>Dicho todo esto, este plot es \u00fatil ya que es mucho m\u00e1s f\u00e1cil de leer que otros plots m\u00e1s complejos, pero debe tomarse como un an\u00e1lisis exploratorio.</p>","tags":["practicos"]},{"location":"practicos/TP08_Clustering_Data_Mining/#k-means","title":"K-means","text":"<p>Otro m\u00e9todo muy popular para agrupar elementos es el K-means. A diferencia del clustering jer\u00e1rquico, \u00e9ste no crea un \u00e1rbol de similitud, sino que utiliza un m\u00e9todo iterativo para asignar directamente cada elemento a diferentes grupos. Otra caracter\u00edstica del K-means es que hay que pasarle el n\u00famero de clusters a crear.</p> <p>La funci\u00f3n <code>kmeans</code> viene con R y se usa:</p> <p></p><pre><code>#Esta funcion controla el aspecto azaroso de kmeans para que nos de igual a todos\nset.seed(1)\n\n#Corro la funcion kmeans para la matriz de datos pidiendole 3 clusters\nclustering_kmeans_k3 &lt;- kmeans(matriz_datos, centers = 3)\n\n#Extraigo los clusters calculados\nclusters_kmeans_k3 &lt;- clustering_kmeans_k3$cluster\n</code></pre> Donde <code>centers = 3</code> le est\u00e1 diciendo a la funci\u00f3n que cree 3 clusters (lo que estoy indicando en el nombre de la variable con _k3 para que el nombre de la variable sea descriptivo).  <p>Tip - Predeterminar el azar</p> <p>La funci\u00f3n <code>kmeans()</code> genera la primera posici\u00f3n de sus centros al azar. Esto hace que si la corren varias veces o en diferentes computadoras va a dar diferentes resultados cada vez. Esto se puede controlar con una funci\u00f3n de R que asigna a mano el valor de la seed, que es el n\u00famero base que usa R al momento de generar azar. Si les interesa hacer esto tienen que ejecutar la siguiente l\u00ednea antes de usar la funci\u00f3n <code>kmeans()</code>:</p> <pre><code>set.seed(1)\n</code></pre> <p>P.D.: El azar en las computadoras no existe realmente. Muchos programas usan lista pre-generadas de \"n\u00fameros creados al azar\" y otras usan cosas como \"el quinto decimal de la temperatura del procesador en este momento\", lo que se aproxima suficientemente al azar para funcionar bien.</p> <p>10) Comparen los clusters obtenidos utilizando <code>kmeans()</code> contra los clusters a los obtenidos previamente usando clustering jer\u00e1rquico. Para eso:</p> <ul> <li>Usen la funci\u00f3n <code>kmeans()</code> para crear un nuevo clustering. Usen la cantidad de <code>centers</code> que consideren necesarios.</li> <li>Extraigan los clusters del clustering reci\u00e9n creado y as\u00edgnenlos a una nueva columna en dt_iris llamada K3_cluster (como en este caso <code>kmeans()</code> devuelve los datos en el mismo orden que est\u00e1n en la tabla se puede hacer directamente con <code>&lt;-</code>, no hace falta usar <code>merge()</code>).</li> <li>Transformen dicha columna en un factor.</li> <li>Usando la funci\u00f3n creada en el punto 9), vean como se distribuyen los puntos al comparar Sepal.Length contra Petal.Length usando la columna Species para determinar el color y la columna K3_cluster para determinar la forma de los diferentes puntos. Guarden este plot en un archivo llamado 22_Sepal_vs_Petal_Length_per_Species_K3.pdf.</li> </ul> <p>10.2) Abran el archivo reci\u00e9n creado. Bas\u00e1ndose solo en lo que pueden observar en este plot, \u00bfpueden decir algo de si este agrupamiento es mejor, peor o similar al obtenido con el clustering jer\u00e1rquico? (recuerden que \"no\" tambi\u00e9n es una respuesta v\u00e1lida)</p>","tags":["practicos"]},{"location":"practicos/TP08_Clustering_Data_Mining/#silhouette","title":"Silhouette","text":"<p>Para cada elemento presente en un agrupamiento se puede calcular un Silhouette coeficient, el cual es un n\u00famero entre -1 y 1 que indica que tan similar es dicho elemento a otros elementos de su mismo cluster y que tan diferente es dicho elemento a los elementos de otros clusters. Cuanto m\u00e1s cerca de 1, mejor asignado esta dicho elemento en su cluster.</p> <p>Es posible entonces calcular el promedio de los Silhouette coefficients de todos los elementos presentes en un agrupamiento, donde promedios m\u00e1s cercanos a 1 van a indicar que el agrupamiento general es mejor.</p> <p>Este m\u00e9todo tiene bastantes usos, pero uno de los m\u00e1s comunes es definir cu\u00e1l es el n\u00famero ideal de clusters a crear con K-means. </p> <p>En R Esta funci\u00f3n se usa:</p> <p></p><pre><code>library(cluster) #paquete que contiene la funcion silhouette()\n\n#Calculo los silhouette coefficients para los datos agrupados en 3 clusters usando kmeans \n#Tengo que pasarle tambien la matriz de distancias correspondiente para que pueda calcular similitud entre elementos\nsilhouette_kmeans_k3 &lt;- silhouette(clusters_kmeans_k3, dist = matriz_distancias)\n\n#La funcion *silhouette* saca los nombres de las filas.\n#Para recuperar los nombres de las filas (o *rownames*) hago lo siguiente\nrownames(silhouette_kmeans_k3) &lt;- rownames(matriz_datos)\n\n#Podemos plotear los silhouette coefficients con plot\nplot(silhouette_kmeans_k3, main = \"Kmeans - centers = 2\")\n\n#Y podemos extraer el promedio de los *Silhouette coefficients*\npromedio_silhouette_kmeans_k3 &lt;- summary(silhouette_kmeans_k3)[[1]][[\"Mean\"]]\n</code></pre> 11) Corran el c\u00f3digo anterior y vean su salida. <p>11.1) Supongamos ahora que estamos en un escenario real, por lo que no tenemos informaci\u00f3n de a que especie corresponde cada punto. Eval\u00faen objetivamente cual es el mejor clustering de los realizados</p>","tags":["practicos"]},{"location":"practicos/TP08_Clustering_Data_Mining/#ejercicios-adicionales","title":"Ejercicios adicionales","text":"<p>Sobre los ejercicios adicionales</p> <p>Recomendamos hacer los ejercicios extra de este TP!</p> <p>El primero les ense\u00f1a a realizar gr\u00e1ficos usando <code>ggplot2</code> y a personalizarlos, por lo que van a aprender un poco mas sobre como mostrar sus datos. </p> <p>El segundo, es la continuaci\u00f3n del TPP 2, donde van a poder aplicar los conceptos de clustering en un estudio de transcript\u00f3mica. Es un ejercicio integrador, similar a lo que se har\u00eda trabajando en un laboratorio. En este punto pueden que les surjan dudas conceptuales sobre que est\u00e1n haciendo en cada paso, no duden en usar discord!</p>","tags":["practicos"]},{"location":"practicos/TP08_Clustering_Data_Mining/#ejercicio-adicional-1-mejores-plots-ggplot2","title":"Ejercicio adicional 1 - Mejores plots: ggplot2","text":"<p>En el TPP 1 mencionamos r\u00e1pidamente al paquete <code>ggplot2</code>, el cual es uno de las formas m\u00e1s populares de hacer plots en R. Este paquete es bastante complicado y tiene un sinf\u00edn de funcionalidades, pero hoy vamos a darle un vistazo a su funcionalidad b\u00e1sica (el cheatsheet es una forma r\u00e1pida de ver todas las posibilidades que tiene).</p> <p>Un ejemplo muy simple de hacer un plot con la funci\u00f3n <code>ggplot</code> ser\u00eda:</p> <pre><code>library(ggplot2)\n\n#Recuerden que *iris* es un *Data Frame* para hacer pruebas que esta siempre cargado en la memoria de R\np &lt;- ggplot(data = iris, aes(x = Petal.Length, y = Sepal.Length)) +\n    geom_point()\n\nprint(p)\n</code></pre> <ul> <li>p es una variable en la que estoy guardando el plot. Cuando la imprimo (usando <code>print</code>) el plot va a aparecer en la pesta\u00f1a Plots en RStudio (en el panel de abajo a la derecha).</li> <li><code>data = iris</code> le est\u00e1 indicando a la funci\u00f3n <code>ggplot</code> de que tabla va a sacar la informaci\u00f3n a plotear. En <code>ggplot</code> se pueden usar Data Frames o Data Tables indistintamente.</li> <li><code>aes()</code> es una funci\u00f3n que se encuentra dentro de la funci\u00f3n principal de <code>ggplot</code>. Se va a encargar de relacionar las diferentes columnas de la tabla con las diferentes variables del plot.</li> <li><code>x = Petal.Length</code> est\u00e1 indicando que la variable X en el plot va a ser los datos de la columna Petal.Length.</li> <li><code>y = Sepal.Length</code> est\u00e1 indicando que la variable Y en el plot va a ser los datos de la columna Sepal.Length.</li> <li><code>geom_point()</code> est\u00e1 indicando el tipo de plot a realizar. Si leen el cheatsheet van a ver que en este caso estamos haciendo un scatter plot.</li> <li>Ambas funciones del plot est\u00e1n separadas por el s\u00edmbolo <code>+</code>, lo que les puede resultar un poco extra\u00f1o (porque lo es), pero as\u00ed es como funciona <code>ggplot</code>.</li> </ul> <p>1) Corran el c\u00f3digo anterior y vean el plot resultante.</p>","tags":["practicos"]},{"location":"practicos/TP08_Clustering_Data_Mining/#cambiar-la-estetica-del-plot-segun-variables","title":"Cambiar la est\u00e9tica del plot seg\u00fan variables","text":"<p>La funci\u00f3n <code>aes()</code> recibe su nombre de la palabra en ingl\u00e9s aesthetics, o est\u00e9tica. No es de extra\u00f1ar entonces que dentro de dicha funci\u00f3n es donde podemos poner otras variables que determinen los colores, formas o tama\u00f1os de cada punto del plot (entre otras caracter\u00edsticas).</p> <p>2) Corran el siguiente c\u00f3digo y vean el plot resultante:</p> <pre><code>p &lt;- ggplot(data = iris, aes(x = Petal.Length, y = Sepal.Length, color = Species)) +\n    geom_point()\n\nprint(p)\n</code></pre> <p>En este c\u00f3digo, <code>color = Species</code> le est\u00e1 diciendo a <code>ggplot</code> que modifique el color de los puntos dependiendo del valor de la columna Species. Si recuerdan a iris, esta columna era una columna categ\u00f3rica (o factor) con 3 valores que podemos ver en el plot. Como le pasamos a <code>color</code> una variable categ\u00f3rica, nos devolvi\u00f3 una escala de colores categ\u00f3rica.</p> <p>3) Corran el c\u00f3digo anterior, pero ahora reemplacen a Species por Petal.Width, \u00bfqu\u00e9 cambios observan?</p> <p>4) Es posible tambi\u00e9n modificar varias de estas caracter\u00edsticas a la vez. Corran el siguiente c\u00f3digo y vean el plot resultante:</p> <pre><code>p &lt;- ggplot(data = iris, aes(x = Petal.Length, y = Sepal.Length, color = Species, shape = Species, size = Petal.Width)) +\n    geom_point()\n\nprint(p)\n</code></pre> <p>En este caso agregamos 2 caracter\u00edsticas nuevas, <code>shape</code> (la forma de los puntos) y <code>size</code> (el tama\u00f1o de los puntos) y le asignamos cada uno de ellos a una variable de la tabla. Noten que no hay problema con que una columna modifique m\u00e1s de una caracter\u00edstica a la vez.</p> <p>5) Tal vez ya lo notaron, pero por el momento no tenemos ning\u00fan control sobre que colores o formas le asigna <code>ggplot</code> a mis tres categor\u00edas. Vamos a mostrarles como hacerlo para este caso espec\u00edfico, pero sepan que las funciones a usar son ligeramente diferentes dependiendo si la variable pasada es discreta o continua. </p> <p>Corran el siguiente c\u00f3digo y vean el plot resultante:</p> <pre><code>#Los colores se pueden escribir en ingles o en hexadecimal\n#\"#FF0000\" es el color rojo (se podr\u00eda haber puesto \"red\")\np &lt;- ggplot(data = iris, aes(x = Sepal.Length, y = Petal.Length, color = Species, shape = Species)) +\n    geom_point() +\n    scale_colour_manual(values = c(\"#FF0000\", \"blue\", \"green\")) +\n    scale_shape_manual(values =  c(2, 4, 1))\n\nprint(p)\n</code></pre> <ul> <li><code>scale_colour_manual()</code>: me permite modificar a mano una escala discreta de colores. El par\u00e1metro <code>values</code> modifica los colores en s\u00ed.</li> <li><code>scale_shape_manual()</code>: me permite modificar a mano una escala discreta de formas. El par\u00e1metro <code>values</code> modifica las formas, las cuales corresponden a un n\u00famero entero (en el tip a continuaci\u00f3n se muestran las m\u00e1s comunes).</li> </ul> <p>Un detalle importante a destacar es que el orden en que se asign\u00f3 cada color a cada categor\u00eda depende del orden en el que aparecen los Levels de la columna Species, la cual es un factor (pueden imprimir <code>iris$Species</code> para ver a lo que nos referimos). </p> Tip - Posibles valores para <code>shape</code> <p> </p> <p>El color interior las formas 21 a 25 depende de la variable <code>fill</code> que no mencionamos todav\u00eda, pero se usa igual que el resto.</p> Tip - Colores y daltonismo <p>El daltonismo ocurre cuando hay un problema con los pigmentos en ciertas c\u00e9lulas nerviosas del ojo que perciben el color. Estas c\u00e9lulas se llaman conos y los hay de tres tipos, los cuales son responsables de ver principalmente al rojo, al verde y al azul respectivamente. </p> <p> </p> <p>La frecuencia del daltonismo es bastante alta, con un 8% de los hombres cauc\u00e1sicos, 5% de los asi\u00e1ticos y 4% de los africanos presentando problemas para distinguir el color rojo del verde. Como la mayor\u00eda de los casos de daltonismo provienen de una mutaci\u00f3n de un gen recesivo ligado al cromosoma X, muy pocas mujeres son dalt\u00f3nicas.</p> <p>Debido al considerable n\u00famero de personas con daltonismo, es buena \u00eddea tener en cuenta esto al momento de elegir colores para cualquier figura que vaya a ser vistas por el p\u00fablico general. Se pueden encontrar decenas de herramientas online que nos ayudan a crear esto, as\u00ed como paquetes de R o paletas de colores. Un ejemplo de una paleta de colores ser\u00eda:</p> <p> </p> <p>Pueden leer m\u00e1s informaci\u00f3n sobre este tema aca.</p> Tip - Asignar colores espec\u00edficos a cada caracter\u00edstica sin depender del orden de los Levels <p>Si bien el c\u00f3digo anterior funciona perfecto, depender del orden de los Levels de un factor al momento de matchear color con un valor dado puede ser peligroso. Una forma de estar seguros que le estamos asignando el color correcto a cada valor es usando vectores con nombres (o named vectors). Algo mencionamos de estos vectores en el pasado, pero b\u00e1sicamente son vectores donde cada posici\u00f3n tiene un nombre (adem\u00e1s del \u00edndice). En este caso ser\u00eda:</p> <pre><code>categorias &lt;- c(\"setosa\", \"versicolor\", \"virginica\")\ncolores &lt;- c(\"#FF0000\", \"blue\", \"green\")\nnames(colores) &lt;- categorias\n\n#Puedo acceder a \"blue\" haciendo `colores[2]` o `colores[\"versicolor\"]`\n</code></pre> <p>De hacer <code>scale_colour_manual(values = colores)</code> en la funci\u00f3n <code>ggplot</code> nos asegurar\u00edamos que el primer elemento de <code>categorias</code> va a tener el primer color de <code>colores</code> y as\u00ed.</p> <p>6) Por \u00faltimo, \u00bfqu\u00e9 pasa si no queremos cambiar la est\u00e9tica del plot dependiendo del valor de una variable, sino que simplemente queremos cambiarla y que afecte a todos los puntos por igual? En estos casos hay que modificar dicha caracter\u00edstica dentro de la funci\u00f3n espec\u00edfica del plot.</p> <p>Corran el siguiente c\u00f3digo y vean el plot resultante:</p> <pre><code>p &lt;- ggplot(data = iris, aes(x = Sepal.Length, y = Petal.Length, color = Species)) +\n    geom_point(size = 2, shape = 4) +\n    scale_colour_manual(values = c(\"#FF0000\", \"blue\", \"green\"))\n\nprint(p)\n</code></pre>","tags":["practicos"]},{"location":"practicos/TP08_Clustering_Data_Mining/#nombres-y-estilo-de-los-ejes-y-el-plot","title":"Nombres y estilo de los ejes y el plot","text":"<p>7) Ahora que ya modificamos bastante el estilo de los datos, vamos a modificar el resto del plot. Lo primero que vamos a hacer es cambiar el nombre del eje X, el eje Y y el t\u00edtulo del plot.</p> <p>Corran el siguiente c\u00f3digo y vean el plot resultante:</p> <pre><code>p &lt;- ggplot(data = iris, aes(x = Sepal.Length, y = Petal.Length, color = Species, shape = Species)) +\n    geom_point(size = 2) +\n    xlab(\"Sepal Length\") +\n    ylab(\"Petal Length\") +\n    ggtitle(\"Sepal Length vs Petal Length per Species\") +\n    scale_colour_manual(values = c(\"#FF0000\", \"blue\", \"green\")) +\n    scale_shape_manual(values =  c(2, 4, 1))\n\nprint(p)\n</code></pre> <ul> <li><code>xlab()</code>: indica el nombre del eje X</li> <li><code>ylab()</code>: indica el nombre del eje Y</li> <li><code>ggtitle()</code>: indica el t\u00edtulo del plot</li> </ul> <p>8) Si bien obtuvimos lo deseado, puede ser que queramos cambiar el tama\u00f1o de los ejes o centrar el t\u00edtulo. Esto lo hacemos con la funci\u00f3n <code>theme()</code>:</p> <p>Corran el siguiente c\u00f3digo y vean el plot resultante:</p> <pre><code>p &lt;- ggplot(data = iris, aes(x = Sepal.Length, y = Petal.Length, color = Species, shape = Species)) +\n    geom_point(size = 2) +\n    xlab(\"Sepal Length\") +\n    ylab(\"Petal Length\") +\n    ggtitle(\"Sepal Length vs Petal Length per Species\") +\n    theme(plot.title = element_text(size = 16, hjust = 0.5),\n          axis.title = element_text(size = 14),\n          axis.text = element_text(size = 12)) +\n    scale_colour_manual(values = c(\"#FF0000\", \"blue\", \"green\")) +\n    scale_shape_manual(values =  c(2, 4, 1))\n\nprint(p)\n</code></pre> <ul> <li><code>theme()</code>: es la funci\u00f3n que contiene el estilo del texto de los ejes y del t\u00edtulo de un plot.</li> <li><code>plot.title = element_text(size = 16, hjust = 0.5)</code>: estamos modificando el titulo del plot, donde <code>size</code> modifica el tama\u00f1o de letra y <code>hjust = 0.5</code> lo centra horizontalmente.</li> <li><code>axis.title = element_text(size = 14)</code>: estamos modificando los t\u00edtulos de los ejes (es decir, los nombre de los ejes).</li> <li><code>axis.text = element_text(size = 12)</code>: estamos modificando el tama\u00f1o de los n\u00fameros de los ejes.</li> </ul> <p>Noten que dentro de <code>theme()</code> cada l\u00ednea se separa con comas, y reci\u00e9n una vez que termina volvemos a usar el s\u00edmbolo <code>+</code>.</p>","tags":["practicos"]},{"location":"practicos/TP08_Clustering_Data_Mining/#fondo-del-plot","title":"Fondo del plot","text":"<p>9) Lo \u00faltimo que nos queda por modificar es el \"fondo\" del plot, es decir, el color de fondo, las l\u00edneas que corresponden a las divisiones de los ejes y el recuadro general del plot. Si bien esto se puede hacer a mano, ggplot viene con algunas opciones ya armadas.</p> <p>Corran el siguiente c\u00f3digo y vean el plot resultante:</p> <pre><code>p &lt;- ggplot(data = iris, aes(x = Sepal.Length, y = Petal.Length, color = Species, shape = Species)) +\n    geom_point(size = 2) +    \n    xlab(\"Sepal Length\") +\n    ylab(\"Petal Length\") +\n    ggtitle(\"Sepal Length vs Petal Length per Species\") +\n    theme_bw() +\n    theme(plot.title = element_text(size = 16, hjust = 0.5),\n          axis.title = element_text(size = 14),\n          axis.text = element_text(size = 12)) +\n    scale_colour_manual(values = c(\"#FF0000\", \"blue\", \"green\")) +\n    scale_shape_manual(values =  c(2, 4, 1))\nprint(p)\n</code></pre> <ul> <li><code>theme_bw()</code> es una funci\u00f3n que setea varias opciones de <code>theme()</code> a un estilo espec\u00edfico (en este caso un estilo simple en blanco y negro). La tenemos que usar antes de <code>theme()</code> para asegurarnos que cualquier cambio que hagamos a mano en <code>theme()</code> sobrescriba los de <code>theme_bw()</code>.</li> </ul>","tags":["practicos"]},{"location":"practicos/TP08_Clustering_Data_Mining/#otros-tipos-de-plots","title":"Otros tipos de plots","text":"<p>Si bien la mayor\u00eda de lo que les mencionamos hasta ahora es aplicable al uso general de ggplot, hasta el momento nos enfocamos en un solo tipo de plot, el scatter plot, hecho mediante <code>geom_point()</code>.</p> <p>Debido a que esto es suficiente para lo que necesitamos hacer hoy,no vamos a hablar hoy de otros tipos de plots, pero si les interesa pueden verlo con mucho detalle en esta p\u00e1gina o ver un vistazo r\u00e1pido en la cheatsheet.</p>","tags":["practicos"]},{"location":"practicos/TP08_Clustering_Data_Mining/#ejercicio-adicional-2-analizando-el-efecto-de-dos-inhibidores","title":"Ejercicio adicional 2 - Analizando el efecto de dos inhibidores","text":"<p>En el TPP 2 hicimos un ejercicio donde us\u00e1bamos el equipo FilterMax F5 para analizar 22 inhibidores de una llamada Enzima Z, la cual resulta que era la cruzipa\u00edna, es decir, la ciste\u00edn proteasa principal de Trypanosoma cruzi, el par\u00e1sito causante de la enfermedad de Chagas.</p> <p>En esta segunda fase del experimento se eligieron 2 inhibidores y se realiz\u00f3 un an\u00e1lisis m\u00e1s detallado, estudiando como var\u00eda la expresi\u00f3n de miles de genes en presencia o ausencia de dichos inhibidores. Para esto se hizo un estudio de transcript\u00f3mica (RNA-seq) donde se extrajo el ARN y se lo analiz\u00f3 con Illumina. Luego, cada read encontrado se mape\u00f3 contra el genoma de referencia y se lleg\u00f3 a una tabla de conteo para cada uno de las transcriptos del genoma.</p> <p>Para cada caso (control, droga 1 y droga 2) se realizaron 3 r\u00e9plicas t\u00e9cnicas para obtener resultados m\u00e1s robustos.</p> <p>Nuestro objetivo va a ser entonces obtener una lista de los genes que son m\u00e1s afectados por cada droga.</p>","tags":["practicos"]},{"location":"practicos/TP08_Clustering_Data_Mining/#leer-los-datos","title":"Leer los datos","text":"<p>1) Lean los archivos control_data.tsv, drug1_data.tsv y drug2_data.tsv que se encuentran en sus materiales de trabajo y gu\u00e1rdenlos en diferentes variables llamadas control_data, drug1_data y drug2_data respectivamente. Asegurense que las variables son del tipo Data Table</p>","tags":["practicos"]},{"location":"practicos/TP08_Clustering_Data_Mining/#estandarizar-los-datos","title":"Estandarizar los datos","text":"<p>El conteo de reads no se puede comparar entre genes puesto que la expresi\u00f3n basal de cada uno es distinto, por lo cual encontrar 10 reads de un gen puede ser mucho, y encontrar 1000 de otro puede ser poco. Adem\u00e1s cada ensayo de secuenciaci\u00f3n puede tener distinta profundidad con lo que tampoco ser\u00eda viable comparar 10 reads de un ensayo donde en total se mapearon \\(2\\text{x}10^8\\) reads con los mismos 10 de otro ensayo donde se mapearon \\(1\\text{x}10^8\\) (es decir, la mitad).</p> <p>Por esta raz\u00f3n vamos a querer modificar las nueve columnas y transformar el valor a \"conteo por mill\u00f3n\", cuya f\u00f3rmula es:</p> \\[ \\text{RPM or CPM} = \\frac{ReadsDelGen * 10^6}{ReadsTotales} \\]","tags":["practicos"]},{"location":"practicos/TP08_Clustering_Data_Mining/#combinar-las-replicas","title":"Combinar las r\u00e9plicas","text":"<p>Otra cosa que vamos a querer hacer es combinar las tres r\u00e9plicas para cada caso. Esto lo vamos a hacer simplemente promediando los 3 valores de CPM para cada gen en cada tratamiento.</p> <p>2) En base a los TPs anteriores ya tienen los conocimientos para hacer el estandarizado de datos y la combinaci\u00f3n de r\u00e9plicas usando fors, pero para hacerla un poco m\u00e1s f\u00e1cil les vamos a dar un par de funciones que les van a simplificar bastante este paso (y ya que estamos les mostramos la funci\u00f3n <code>apply()</code> en acci\u00f3n):</p> C\u00f3digoC\u00f3digo con comentarios <pre><code>calcularConteoPorMillon &lt;- function(vector_cuentas) {\n    #Dado un vector de *reads*, esta funcion lo transforma en CPM y devuelve el vector\n\n    vector_cuentas &lt;- vector_cuentas * 1000000 / sum(vector_cuentas) \n\n    return(vector_cuentas)\n}\n\nparsearDatos &lt;- function(dt_par, columnas_a_parsear, nombre_columna_nueva) {\n    #Dado un *Data Table*, un vector de *strings* con los nombres de las columnas con *reads* a parsear y\n    #un nombre de una columna a crear, esta funcion:\n    # - Transforma los *reads* de las columnas a parsear en CPM\n    # - Calcula el promedio de los CPM por cada fila y lo guarda en una columna nueva con el nombre dado\n    # - Saca las columnas a parsear del *Data Table*\n    # - Devuelve el *Data Table* con los cambios\n\n    dt_aux &lt;- dt_par[, columnas_a_parsear, with = F]\n\n    matrix_aux &lt;- apply(dt_aux, 2, calcularConteoPorMillon)\n\n    dt_par[[nombre_columna_nueva]] &lt;- apply(matrix_aux, 1, mean)\n    dt_par[[nombre_columna_nueva]] &lt;- round(dt_par[[nombre_columna_nueva]], 4)\n\n    dt_par &lt;- dt_par[, -columnas_a_parsear, with = F]\n\n    return(dt_par)\n}\n</code></pre> <pre><code>calcularConteoPorMillon &lt;- function(vector_cuentas) {\n    #Dado un vector de *reads*, esta funcion lo transforma en CPM y devuelve el vector\n\n    #Aca estoy asumiendo que sum(vector_cuentas) nunca es 0 (lo que tiene un poco\n    #de sentido ya que si es 0 entonces todas los counts son 0)\n    vector_cuentas &lt;- vector_cuentas * 1000000 / sum(vector_cuentas) \n\n    return(vector_cuentas)\n}\n\nparsearDatos &lt;- function(dt_par, columnas_a_parsear, nombre_columna_nueva) {\n    #Dado un *Data Table*, un vector de *strings* con los nombres de las columnas con *reads* a parsear y\n    #un nombre de una columna a crear, esta funcion:\n    # - Transforma los *reads* de las columnas a parsear en CPM\n    # - Calcula el promedio de los CPM por cada fila y lo guarda en una columna nueva con el nombre dado\n    # - Saca las columnas a parsear del *Data Table*\n    # - Devuelve el *Data Table* con los cambios\n\n    #Creo un nuevo *Data Table* que solo contenga las columnas a parsear (y no el ID del gen)\n    dt_aux &lt;- dt_par[, columnas_a_parsear, with = F]\n\n    #La funcion *apply* con el parametro 2 va a ejecutar la funcion *calcularConteoPorMillon* para \n    #cada COLUMNA de dt_aux (las tres replicas, en este caso)\n    matrix_aux &lt;- apply(dt_aux, 2, calcularConteoPorMillon)\n\n    #La funcion *apply* con el parametro 1 va a ejecutar la funcion *mean* para \n    #cada FILA de matrix_aux (cada uno de los genes estudiados)\n    dt_par[[nombre_columna_nueva]] &lt;- apply(matrix_aux, 1, mean)\n    dt_par[[nombre_columna_nueva]] &lt;- round(dt_par[[nombre_columna_nueva]], 4)\n\n    #Saco las columnas que ya no me interesan de *dt_par*\n    dt_par &lt;- dt_par[, -columnas_a_parsear, with = F]\n\n    return(dt_par)\n}\n</code></pre> <p>2.1) Corran las funciones anteriores para cargarlas en memoria, luego \u00fasenlas para estandarizar y combinar las r\u00e9plicas del control y las drogas 1 y 2. Un ejemplo de correr esta funci\u00f3n para el caso de control ser\u00eda:</p> <pre><code>control_data &lt;- parsearDatos(dt_par = control_data,\n                             columnas_a_parsear = c(\"control1\", \"control2\", \"control3\"),\n                             nombre_columna_nueva = \"control\")\n</code></pre> <p>2.2) Ahora que ya tenemos los datos parseados, usen la funci\u00f3n <code>merge()</code> dos veces para combinar los 3 Data Tables en uno solo llamado full_data (si todo sali\u00f3 bien deber\u00eda tener 11.106 filas y 4 columnas).</p>","tags":["practicos"]},{"location":"practicos/TP08_Clustering_Data_Mining/#calcular-el-fold-change","title":"Calcular el Fold Change","text":"<p>3) Algo mencionamos antes, pero concluir que \"hay 10 CPM m\u00e1s al agregarle la droga\" no significa nada en el vac\u00edo. Si en el control era solo 1 CPM, entonces 10 m\u00e1s es mucho. Si en el control eran 10.000 CPM, 10 m\u00e1s es insignificante.</p> <p>Vamos entonces a calcular el fold change, es decir, cuantas veces m\u00e1s (o menos) de CPM fueron observados al agregarle la droga frente a cuando estaba solo el control. Esto lo calculamos como:</p> \\[ \\text{Fold Change} = \\frac{\\text{CPM Droga}}{\\text{CPM Control}} \\] <p>3.1) Antes de seguir leyendo \u00bfSe les ocurre alg\u00fan caso donde la f\u00f3rmula anterior nos de problemas?</p> Respuesta <p>B\u00e1sicamente hay 2 casos donde el c\u00e1lculo del Fold Change va a dar problemas:</p> <ul> <li>Cuando CPM Control = 0: La divisi\u00f3n no se puede hacer (y de hacerla en R va a dar infinito)</li> <li>Cuando CPM Control ~ 0: En este caso la divisi\u00f3n se hace, pero el Fold Change va a dar un n\u00famero muy grande (y probablemente varios \u00f3rdenes de magnitud m\u00e1s grande que el resto de los Fold Change calculados). Este Fold Change no se debe a que CPM Droga es realmente mayor, sino a que CPM Control es muy chico, por lo que no es realmente informativo.</li> </ul> <p>Estos dos problemas se pueden arreglar agregando un n\u00famero buffer, es decir, un n\u00famero peque\u00f1o que se adiciona al numerador y al denominador. En este caso vamos a usar 0,125 con lo que la f\u00f3rmula quedar\u00eda:</p> \\[ \\text{Fold Change} = \\frac{\\text{CPM Droga} + 0.125}{\\text{CPM Control} + 0.125} \\] <p>3.2) \u00bfQu\u00e9 pasa ahora en los dos casos problem\u00e1ticos que estamos tratando resolver? \u00bfC\u00f3mo afecta este buffer a los casos \"normales\"? (es decir, cuando tanto el numerador como el denominador son n\u00fameros mayores a 1)</p> <p>3.3) Usando la f\u00f3rmula con buffer, calculen el Fold Change para ambas drogas y gu\u00e1rdenlos en nuevas columnas de la tabla full_data (p\u00f3nganles nombres que representen la informaci\u00f3n que contienen).</p>","tags":["practicos"]},{"location":"practicos/TP08_Clustering_Data_Mining/#transformar-el-fold-change","title":"Transformar el Fold Change","text":"<p>Ahora bien, vamos a analizar como se distribuyen los valores del Fold Change para todas las prote\u00ednas (primera pesta\u00f1a del plot que est\u00e1 abajo). Podemos ver que si bien el Fold Change llega hasta 20 en algunos casos, la gran mayor\u00eda de ellas tienen Fold Changes menores a 4.</p> <p>En el paso siguiente vamos a querer agrupar nuestros genes por como se comportan frente a las drogas 1 y 2 clusterizando con <code>kmeans()</code> y luego plotearlo en un heatmap. En este momento la mayor\u00eda de los datos se encuentran en un peque\u00f1o rango del \"espectro\" de Fold Change, por lo que al momento de agrupar por similitud b\u00e1sicamente van a formar un \u00fanico gran cluster, lo que no da informaci\u00f3n.</p> <p>Por esta raz\u00f3n queremos convertir nuestros datos a una escala logar\u00edtmica. Como Fold Change solo llega hasta 20 vamos a usar una escala logar\u00edtmica en base 2. En R esto se hace usando la funci\u00f3n <code>log()</code>. Por defecto esta funci\u00f3n usa como base a \\(e\\), es decir, es el logaritmo natural. Sin embargo, se le puede cambiar la base a 2 pas\u00e1ndole el par\u00e1metro <code>base = 2</code> (ver la segunda pesta\u00f1a en el siguiente plot).</p> <p>4) Usando la funci\u00f3n <code>log()</code> con el par\u00e1metro necesario, calculen el logaritmo en base 2 de los Fold Change para ambas drogas y gu\u00e1rdenlos en nuevas columnas de la tabla full_data.</p> Fold Change para la Droga 1Log2(Fold Change) para la Droga 1 <p> </p> <p> </p>","tags":["practicos"]},{"location":"practicos/TP08_Clustering_Data_Mining/#plotear-el-heatmap","title":"Plotear el Heatmap","text":"<p>El heatmap es un tipo de plot que no vimos hasta el momento, pero que tal vez conozcan. La versi\u00f3n b\u00e1sica del heatmap nos permite graficar valores num\u00e9ricos como una escala de colores lo que nos permite ver diferencias entre filas r\u00e1pidamente e incluso encontrar filas similares o patrones.</p> <p>A continuaci\u00f3n mostramos un ejemplo que usa los datos estandarizados del Ejercicio 2 del TP 10a (la tabla ejemplo con los 4 genes, matriz_datos_ST):</p> <p></p> <p>No solo nos permite ver r\u00e1pidamente que hay 2 grupos de genes, sino que este paquete de heatmap tambi\u00e9n va a agrupar las filas por similitud y mostrar un dendrograma de similitud (todo esto se puede poner o sacar con par\u00e1metros).</p> <p>5) En nuestro caso tenemos miles de genes, por lo que es complicado usar un heatmap que los muestre a todos por separado. Vamos entonces a clusterizarlos por similitud usando <code>kmeans</code>, lo cual en este caso se puede hacer desde el mismo paquete que hace el heatmap. Al momento de definir clusters no sabemos cu\u00e1ntos son, por lo que vamos a elegir un n\u00famero relativamente grande, sabiendo que eso puede resultar en varios clusters que son muy similares.</p> <p>5.1) Instalen en R el paquete pheatmap.</p> <p>5.2) Corran el siguiente c\u00f3digo reemplazando log2_fold_change_drug1_wBuffer y log2_fold_change_drug2_wBuffer por el nombre de las columnas que contienen el logaritmo en base 2 de los Fold Change:</p> <pre><code>library(pheatmap)\n\n#Como *pheatmap* usa kmeans adentro inicializo la seed para que el plot de igual en todos lados siempre\nset.seed(1)\n\n#Me quedo solo con las columnas a plotear (en este caso el log 2 de los Fold Change para ambas drogas)\nplot_data &lt;- full_data[, .(log2_fold_change_drug1_wBuffer, log2_fold_change_drug2_wBuffer)]\n\n#Uso la funcion *pheatmap* para hacer un heatmap mas lindo\npheatmap(mat = plot_data, kmeans_k = 10, cluster_cols = F)\n</code></pre> <ul> <li><code>kmeans_k = 10</code> le est\u00e1 diciendo que agrupe los datos en 10 clusters, similar a correr <code>kmeans(plot_data, centers = 10)</code></li> <li><code>cluster_col = F</code> le est\u00e1 diciendo que no trate de agrupar las columnas por similitud y que no haga un dendrograma asociado</li> </ul> <p>5.3) Mirando los 10 clusters que acabamos de crear, para que clusters de genes se observa:</p> <ul> <li>Fold change alto para ambas drogas</li> <li>Fold change bajo para ambas drogas</li> <li>Fold change alto para la droga 1 y bajo la droga 2</li> <li>Fold change bajo para la droga 1 y alto la droga 2</li> </ul>","tags":["practicos"]},{"location":"practicos/TP08_Clustering_Data_Mining/#calcular-genes-mas-afectados","title":"Calcular genes m\u00e1s afectados","text":"<p>6) Si bien el heatmap nos da una idea global de como actuaron las drogas, nuestro objetivo es entender un poco m\u00e1s de su funcionamiento. Para esto, vamos a analizar la lista de genes que se vieron afectados por ellas.</p> <p>Para obtener esta lista es necesario entonces definir un umbral num\u00e9rico de Fold Change a partir del cual consideramos que el cambio fue \"significativo\" para nosotros. Estos umbrales se pueden elegir en base a conocimientos previos, en base a controles positivos y negativos, o mediante prueba y error (analizando qu\u00e9 y cu\u00e1ntos genes quedan por encima del umbral).</p> <p>Otra cosa a considerar es que en este caso estamos analizando drogas que funcionan como inhibidores, por lo que no nos interesa solo los genes con Fold Change alto, sino que incluso nos interesan m\u00e1s los genes con Fold Change bajo (que debido a como se calcul\u00f3 quiere decir cercanos a 0).</p> <p>En este caso vamos a quedarnos con aquellos genes que cumplan alguna de las siguientes condiciones:</p> <ul> <li>\\(log_2(FoldChange) \\geq 1.5\\) (es decir \\(FoldChange \\geq 2.83 = 2^{1.5}\\))</li> <li>\\(log_2(FoldChange) \\leq -1.5\\) (es decir \\(FoldChange \\leq \\frac{1}{2.83} = 2^{-1.5}\\))</li> </ul> <p>O sea, que nos vamos a quedar con aquellos genes que tienen un CPM 2.83 veces m\u00e1s grande o m\u00e1s chico que el control.</p> <p>6.1) Filtren full_data para quedarnos con aquellas filas donde el logaritmo en base 2 del Fold Change de la droga 1 sea mayor a 1.5 o menor a -1.5. Guarden la lista de los IDs de las prote\u00ednas que cumplen esa condici\u00f3n en una nueva variable. Hagan lo mismo para la droga 2.</p> <p>Tip - Calcular el valor absoluto</p> <p>La funci\u00f3n <code>abs()</code> nos devuelve el valor absoluto de un n\u00famero. Si bien es posible filtrar estos datos usando simplemente un OR, tambi\u00e9n lo pueden hacer usando <code>abs()</code>, lo que prefieran.</p> <p>6.2) Usen <code>write.table()</code> para generar un nuevo archivo llamado affected_genes_drug1 y guarden en \u00e9l los IDs reci\u00e9n calculados para la droga 1. Tengan en cuenta que queremos solo los IDs, por lo que tienen que cambiar los par\u00e1metros de la funci\u00f3n para que no haya nombres de las filas, nombres de las columnas ni comillas. Hagan lo mismo para la droga 2.</p>","tags":["practicos"]},{"location":"practicos/TP08_Clustering_Data_Mining/#buscar-nuestros-genes-en-bases-de-datos","title":"Buscar nuestros genes en bases de datos","text":"<p>Importante</p> <p>La base de datos TriTrypDB se encuentra discontinuada en este momento (septiembre 2024). Dejamos el ejercicio planteado para cuando la p\u00e1gina vuelva a estar activa, y para que vean como era el paso de data mining. Cuando haya una alternativa, vamos a reemplazar este punto con la nueva informaci\u00f3n.</p> <p>7) Lo \u00faltimo que vamos a hacer con esta informaci\u00f3n es investigar en bases de datos para tratar de entender un poco m\u00e1s que procesos biol\u00f3gicos est\u00e1n siendo afectados por nuestras drogas. Como estamos trabajando con Trypanosoma cruzi vamos a ir a una p\u00e1gina que se especializa en tripanosom\u00e1tidos llamada TriTrypDB.</p> <p>7.1) Entren a este link y copien la lista de IDs que acabamos de crear para la droga 1. Hagan click en Get Answer.</p> <p>7.2) Una vez que se hayan cargados los datos vayan a Analyze Results Gene Onthology Enrichment, aseg\u00farense que este checkeado Biological Process y aprieten Submit (disclaimer: esta parte a veces no anda y hay que probar otro d\u00eda).</p> Tip - Ubicaci\u00f3n del bot\u00f3n Analyze Results <p> </p> <p>7.3) Esta tabla muestra procesos biol\u00f3gicos relacionados con nuestra lista de genes. A grandes rasgos, \u00bfqu\u00e9 procesos biol\u00f3gicos parecen estar afectados directa o indirectamente por la droga 1? Para responder esto pueden ordenar la tabla obtenida por la columna P-value en forma ascendente o pueden presionar el bot\u00f3n Show Word Cloud que se encuentra arriba de la tabla para ver un Word Cloud de los diferentes procesos biol\u00f3gicos.</p> <p>7.4) Hagan 7.1), 7.2) y 7.3) para la droga 2.</p> <p>7.5) \u00bfQue habr\u00eda que cambiar en lo que hicimos en el punto 6) si s\u00f3lo nos interesaran los procesos biol\u00f3gicos que son inhibidos por nuestras drogas?</p>","tags":["practicos"]},{"location":"practicos/TP08_Clustering_Data_Mining/#bibliografia","title":"Bibliograf\u00eda","text":"","tags":["practicos"]},{"location":"practicos/TP08_Clustering_Data_Mining/#consola-de-r","title":"Consola de R","text":"<ul> <li>Comando <code>help()</code></li> </ul>","tags":["practicos"]},{"location":"practicos/TP08a_Clustering/","title":"Practico Ocho B","text":"","tags":["practicos"]},{"location":"practicos/TP08a_Clustering/#tp-8a-data-mining-clustering","title":"TP 8a. Data Mining - Clustering","text":"<p> Materiales</p>","tags":["practicos"]},{"location":"practicos/TP08a_Clustering/#slides-mostrados-en-la-clase","title":"Slides mostrados en la clase","text":"<ul> <li> Slides</li> </ul>","tags":["practicos"]},{"location":"practicos/TP08a_Clustering/#videos-de-la-clase-grabada","title":"Videos de la clase grabada","text":"<ul> <li> Cierre TP</li> </ul>","tags":["practicos"]},{"location":"practicos/TP08a_Clustering/#software-a-usar","title":"Software a usar","text":"<ul> <li>R (ya instalado en la VM).</li> <li>RStudio (ya instalado en la VM)</li> </ul>","tags":["practicos"]},{"location":"practicos/TP08a_Clustering/#recursos-online","title":"Recursos Online","text":"<ul> <li>Introducci\u00f3n a R, TPP de esta materia: Parte 1 y Parte 2</li> <li>Clustering jer\u00e1rquico en R</li> <li>Detalles del c\u00e1lculo de Silhouette (y mucho m\u00e1s)</li> </ul>","tags":["practicos"]},{"location":"practicos/TP08a_Clustering/#objetivos","title":"Objetivos","text":"<ul> <li>Familiarizarse con el funcionamiento del clustering jer\u00e1rquico aglomerativo.</li> <li>Familiarizarse con el m\u00e9todo de clustering particional K-means.</li> <li>Explorar algunas medidas de calidad de los clusters, como la silueta o silhouette.</li> </ul>","tags":["practicos"]},{"location":"practicos/TP08a_Clustering/#introduccion-al-tema","title":"Introducci\u00f3n al Tema","text":"<p>Hoy vamos a retomar el trabajo con R. Recomendamos repasar o tener a mano el TP 5 de esta materia por si necesitan recordar como hacer ciertos comandos (Parte 1 y Parte 2).</p> <p>Como mencionamos en el TP 5, es cada vez m\u00e1s normal que experimentos biol\u00f3gicos nos permitan analizar miles a millones de interacciones biol\u00f3gicas a la vez, lo que resulta en tablas con millones de datos. Esto hace necesario entonces saber utilizar herramientas que nos permitan extraer, o minar, informaci\u00f3n de estos enormes conjuntos de datos. A este proceso lo vamos a denominar Data Mining.</p> <p>En este TP nos vamos a enfocar en m\u00e9todos de clustering, los cuales nos permiten agrupar elementos analizados en base a datos observados sobre ellos. Esto tiene muchas utilidades, como puede ser entender mejor las diferencias entre grupos conocidos, encontrar diferentes grupos dentro del conjunto datos analizado, o remover datos redundantes, entre otros.</p> <p>Si bien este TP vamos a enfocarnos m\u00e1s que nada en aprender las t\u00e9cnicas, el objetivo final de este proceso es identificar agrupamientos naturales en los datos con alguna relevancia biol\u00f3gica.</p>","tags":["practicos"]},{"location":"practicos/TP08a_Clustering/#ejercicio-1-clustering-jerarquico-manual","title":"Ejercicio 1 - Clustering Jer\u00e1rquico Manual","text":"<p>Para empezar este TP vamos a realizar un peque\u00f1o clustering jer\u00e1rquico a mano para repasar el concepto.</p> <p>Supongamos que tenemos cuatro genes (A, B, C y D) para los cuales medimos el nivel de expresi\u00f3n a las 0hs, 1hs y 2hs luego de alg\u00fan tratamiento:</p> gen t_0h t_1h t_2h genA 2 4 8 genB -1 -1 -2 genC -2 0 1 genD 0 -1 -6 <p>Queremos entonces agrupar a los diferentes genes por como var\u00edan sus niveles de expresi\u00f3n cuando se aplica dicho tratamiento. Para hacer esto vamos a:</p> <ul> <li>Calcular la distancia euclidiana entre los diferentes genes</li> <li>Construir una matriz de distancias</li> <li>Agruparlos usando clustering jer\u00e1rquico donde el criterio de agregaci\u00f3n va a ser \"vecino m\u00e1s lejano\" o complete linkage</li> <li>Repetir todo lo anterior, pero estandarizando previamente los datos de niveles de expresi\u00f3n</li> </ul> <p>Si no entienden algunos de estos conceptos pueden leer un poco m\u00e1s sobre ellos a continuaci\u00f3n (y m\u00e1s todav\u00eda en la te\u00f3rica):</p> Distancia euclidiana <p>Es una de las varias formas de calcular una distancia entre dos vectores de datos, lo cual es necesario al momento de calcular una matriz de distancias. Por ejemplo, suponiendo que tenemos 2 vectores de forma \\(V = (x, y, z)\\) la distancia euclidiana entre ellos se calcula como:</p> \\[ distanciaEuclidiana(V_1, V_2) = \\sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2 + (z_1 - z_2)^2} \\] <p>Aplicando esto a nuestros datos, la distancia entre los genes A y B se calcula como:</p> \\[ distanciaEuclidiana(genA, genB) = \\sqrt{(2 - (-1))^2 + (4 - (-1))^2 + (8 - (-2))^2} = 11,58 \\] Matriz de distancias <p>Es una matriz donde tanto las filas como las columnas representan un mismo conjunto de elementos y en cada intersecci\u00f3n se pone la distancia (en nuestro caso euclidiana) entre dos elementos espec\u00edficos. Es la base de muchos m\u00e9todos de clustering.</p> <p>Para nuestros datos la matriz de distancias entre los cuatro genes es:</p> genA genB genC genD genA 0 genB 11,58 0 genC 9 3,32 0 genD 15 4,12 7,35 0 <p>Como el orden de los elementos es igual para las filas que para las columnas, en la diagonal se compara cada elemento contra s\u00ed mismo por lo que la distancia es 0. Por otro lado, estamos llenando solo la mitad de la matriz ya que las matrices de distancia son matrices sim\u00e9tricas, es decir, que el tri\u00e1ngulo superior derecho de la matriz va a ser un reflejo del tri\u00e1ngulo inferior izquierdo.</p> Clustering jer\u00e1rquico <p>El clustering jer\u00e1rquico es una forma de agrupar elementos dependiendo de que tan similares son entre ellos. Usa un algoritmo bastante sencillo de entender que se basa en una matriz de distancias:</p> <ol> <li> <p>Sin considerar a la diagonal, encontrar el par de elementos (fila, columna) que son m\u00e1s similares entre s\u00ed (el menor n\u00famero en la matriz de distancias). En nuestra matriz de distancias los elementos m\u00e1s parecidos son \"genB\" y \"genC\" ya que tienen la menor similitud (3,32)</p> </li> <li> <p>Dejar constancia de dicha similitud y reconstruir la matriz, reemplazando ambos elementos por uno nuevo (saco los elementos \"genB\" y \"genC\" y agrego el elemento \"genB+C\")</p> </li> <li> <p>Al momento de calcular la nueva distancia entre este nuevo elemento (\"genB+C\") y el resto de los elementos de la matriz, usar alg\u00fan criterio de agregaci\u00f3n (por ejemplo: single linkage, average linkage o complete linkage)</p> </li> <li> <p>Volver al paso 1 hasta que todos los elementos est\u00e9n unidos entre s\u00ed</p> </li> </ol> <p>Una vez hecho esto puedo dibujar el clustering jer\u00e1rquico teniendo en cuenta qu\u00e9 elementos se juntaron con qu\u00e9 elementos.</p> Criterios de agregaci\u00f3n <p>Los criterios de agregaci\u00f3n indican que operaci\u00f3n hay que hacer al momento de calcular la distancia entre un nuevo elemento creado en una matriz de distancias y los ya existentes. Cada uno tiene sus ventajas y desventajas.</p> <p>Siguiendo con nuestro ejemplo, si queremos calcular la distancia entre el nuevo elemento \"genB+C\" y el \"genA\":</p> <ul> <li>Single Linkage: la nueva distancia es la menor entre las distancias \\(dist(genA, genB)\\) y \\(dist(genA, genC)\\)</li> <li>Complete Linkage: la nueva distancia es la mayor entre las distancias \\(dist(genA, genB)\\) y \\(dist(genA, genC)\\)</li> <li>Average Linkage: la nueva distancia es el promedio de las distancias \\(dist(genA, genB)\\) y \\(dist(genA, genC)\\)</li> </ul> <ol> <li> <p>Para agilizar un poco este Ejercicio les vamos a dar una planilla de Google Sheets que contiene la base de lo que vamos a necesitar. Abran esta planilla de Google Sheets y hagan una copia. Leyendo la siguiente informaci\u00f3n, traten de entender que hacen las diferentes partes de dicha planilla (desde ya, hay partes vac\u00edas que vamos a completar).</p> <ul> <li> <p>Pesta\u00f1a Plot Se\u00f1al</p> <ul> <li>Columnas A - D: contienen nuestros datos</li> <li>Columnas F y G: contienen el promedio y la desviaci\u00f3n est\u00e1ndar de cada gen (vac\u00edo, ahora lo hacemos)</li> <li>Columnas I - L: contienen nuestros datos estandarizados (vac\u00edo, ahora lo hacemos)</li> <li>Plot izquierdo: plot de la evoluci\u00f3n de los niveles de expresi\u00f3n a los 3 tiempos para los 4 genes</li> <li>Plot derecho: plot de la evoluci\u00f3n de los niveles de expresi\u00f3n estandarizados a los 3 tiempos para los 4 genes (se hace solo al llenar datos)</li> </ul> </li> <li> <p>Pesta\u00f1a Clustering</p> <ul> <li>Columnas A - D: contienen nuestros datos</li> <li>Columnas F - J: contienen el c\u00e1lculo de las distancias euclidianas entre las filas</li> <li>Columnas L - P: contienen la matriz de distancias para nuestros datos (y matrices m\u00e1s chicas donde se van a ir escribiendo los varios pasos al hacer el clustering a mano)</li> </ul> </li> <li> <p>Pesta\u00f1a Clustering Estandarizado</p> <ul> <li>Igual que Clustering, pero para datos estandarizados (vac\u00edo, ahora lo hacemos)</li> </ul> </li> </ul> </li> <li> <p>Mirando el Plot izquierdo de la pesta\u00f1a Plot Se\u00f1al, \u00bfde qu\u00e9 forma les parece que se van a agrupar los cuatro genes en el clustering jer\u00e1rquico?</p> </li> <li> <p>Ahora vamos a calcular el clustering jer\u00e1rquico:</p> <ol> <li> <p>Vayan a la pesta\u00f1a Clustering. Usando la matriz de distancias ubicada en las Columnas L - P, calculen a mano el clustering jer\u00e1rquico para nuestros datos usando complete linkage.</p> </li> <li> <p>Hagan un esquema del dendrograma o \u00e1rbol de similitud que resulta de este clustering. Pueden usar la herramienta Dibujo de Google Sheets (no se preocupen por el largo de las ramas, solo nos importa c\u00f3mo se unen los genes).</p> </li> <li> <p>\u00bfDio similar a lo que hab\u00edan propuesto en el punto 2?</p> </li> </ol> </li> <li> <p>Queremos ahora calcular nuestros datos estandarizados donde vamos a estandarizar por gen, rest\u00e1ndole a cada dato el promedio de los tres tiempos para ese gen y dividiendo el resultado por la desviaci\u00f3n est\u00e1ndar de los tres tiempos para ese gen. Es decir:</p> \\[ datoEstandarizado(genA, t_0) = \\frac{dato(genA, t_0) - promedio(genA)}{desviacionEstandar(genA)} \\] <p>Para hacer esto:</p> <ol> <li> <p>En la pesta\u00f1a Plot Se\u00f1al, completen las columnas F y G para que calculen el promedio y la desviaci\u00f3n est\u00e1ndar para los tres tiempos de cada uno de los cuatro genes.</p> </li> <li> <p>En la pesta\u00f1a Plot Se\u00f1al, completen las columnas J a L para que calculen los valores estandarizados de los datos en base a la f\u00f3rmula anterior.</p> Tip - Copiar y pegar una f\u00f3rmula en Google Sheets manteniendo una parte constante <p>En Google Sheets, as\u00ed como en Excell y otras hojas de c\u00e1lculo, es posible \"arrastrar\" una f\u00f3rmula, por lo que podr\u00edan calcular el dato estandarizado para un solo n\u00famero (por ejemplo celda J2) y luego copiar dicha f\u00f3rmula al resto de las celdas.</p> <p>Sin embargo, de usar este m\u00e9todo para calcular los valores estandarizados tendr\u00edamos problemas, ya que se mover\u00eda tambi\u00e9n la referencia en la f\u00f3rmula a las celdas del promedio y la desviaci\u00f3n est\u00e1ndar (las cuales queremos que se muevan con la f\u00f3rmula para abajo, pero no para la derecha).</p> <p>Por suerte es posible controlar esto agreg\u00e1ndole el s\u00edmbolo $ adelante de la fila o columna. Es decir, si la f\u00f3rmula apunta a F2 y no queremos que se mueva horizontalmente (es decir, no queremos que cambie la F), podemos agregar el s\u00edmbolo $ en la f\u00f3rmula con lo que quedar\u00eda $F2. Si ahora arrastramos (o copiamos y pegamos) dicha f\u00f3rmula, el 2 puede cambiar, pero la F se va a mantener siempre como F.</p> </li> <li> <p>Una vez calculados los datos estandarizados deber\u00eda aparecerles el plot en el Plot derecho. \u00bfDe qu\u00e9 forma les parece que se van a agrupar los cuatro genes en el clustering jer\u00e1rquico usando los datos estandarizados?</p> </li> </ol> </li> <li> <p>El pr\u00f3ximo paso es calcular la matriz de distancias para nuestros datos estandarizados:</p> <ol> <li> <p>Copien los datos reci\u00e9n calculados a la pesta\u00f1a Clustering Estandarizado (tengan en cuenta al copiar y pegar los datos que queremos los valores, no las f\u00f3rmulas).</p> </li> <li> <p>En la columna J, calculen las distancias euclidianas entre los diferentes genes.</p> </li> <li> <p>Copien a mano las distancias reci\u00e9n calculadas a las posiciones correspondientes de la matriz de distancias en las Columnas L - P.</p> </li> </ol> </li> <li> <p>Por \u00faltimo vamos a calcular el clustering jer\u00e1rquico para nuestros datos estandarizados:</p> <ol> <li> <p>Aseg\u00farense que est\u00e1n en la pesta\u00f1a Clustering Estandarizado. Usando la matriz de distancias ubicada en las Columnas L - P, calculen a mano el clustering jer\u00e1rquico para nuestros datos estandarizados usando complete linkage.</p> </li> <li> <p>Hagan un esquema del dendrograma o \u00e1rbol de similitud que resulta de este clustering. Pueden usar la herramienta Dibujo de Google Sheets (no se preocupen por el largo de las ramas, solo nos importa c\u00f3mo se unen los genes).</p> </li> <li> <p>\u00bfDio similar a lo que hab\u00edan propuesto en el punto 4.c?</p> </li> </ol> </li> <li> <p>Comparando los clusterings obtenidos con los datos estandarizados y sin estandarizar.</p> <ol> <li>\u00bfQu\u00e9 diferencias observan?</li> <li>\u00bfCu\u00e1l de los dos clusterings les parece mejor para este escenario donde quer\u00edamos evaluar c\u00f3mo afecta un tratamiento los niveles de expresi\u00f3n de diferentes genes?</li> <li>\u00bfLes parece qu\u00e9 es siempre correcto estandarizar los datos de esta forma o se les ocurre escenarios donde no es as\u00ed?</li> </ol> </li> </ol>","tags":["practicos"]},{"location":"practicos/TP08a_Clustering/#ejercicio-2-clustering-jerarquico-con-r","title":"Ejercicio 2 - Clustering Jer\u00e1rquico con R","text":"<p>En este Ejercicio vamos a hacer lo mismo que hicimos en el Ejercicio 1, pero ahora lo vamos a hacer usando R. Les recomendamos que creen un script nuevo donde vayan poniendo las diferentes l\u00edneas de c\u00f3digo que van ejecutando.</p>","tags":["practicos"]},{"location":"practicos/TP08a_Clustering/#datos-sin-estandarizar","title":"Datos sin estandarizar","text":"","tags":["practicos"]},{"location":"practicos/TP08a_Clustering/#leer-los-datos","title":"Leer los datos","text":"<p>Los datos originales los tienen en el archivo tabla_ejemplo.tsv que se encuentra en sus materiales de trabajo.</p> <p>1) Usen la funci\u00f3n <code>fread</code> para cargar los datos de tabla_ejemplo.tsv en una nueva variable llamada <code>dt_tabla_ejemplo</code> (recuerden que van a tener que cargar el paquete <code>data.table</code> y setear el working directory)</p>","tags":["practicos"]},{"location":"practicos/TP08a_Clustering/#pasar-los-datos-a-una-matriz","title":"Pasar los datos a una matriz","text":"<p>Queremos crear una matriz de distancias, las cuales se calculan usando la funci\u00f3n <code>dist</code>. Para que la matriz de distancias tenga los nombres de los genes en las filas y columnas necesitamos que la tabla que le pasemos tambi\u00e9n cumpla esta condici\u00f3n, cosa que los Data Tables no hacen (ya que no pueden tener nombres en las filas).</p> <p>Por esta raz\u00f3n vamos a transformar nuestro Data Table en una matriz. En R las matrices son un tipo de variable (matrix) y son b\u00e1sicamente vectores de dos dimensiones. Hay varias formas de crear una matriz, por ejemplo:</p> <pre><code>matriz_ejemplo &lt;- matrix(c(1:9), nrow = 3, ncol = 3, byrow = T)\n\n#Si quisieramos ver por consola algun dato de la matriz podemos hacer:\nmatriz_ejemplo #imprimo toda la matriz\nmatriz_ejemplo[1, ] #imprimo la primera fila\nmatriz_ejemplo[, 1] #imprimo la primera columna\nmatriz_ejemplo[2, 3] #imprimo el elemento ubicado en la fila 2 y la columna 3\n</code></pre> <p>Ahora bien, en nuestro caso no queremos crear una matriz de 0, sino que queremos transformar nuestro Data Table en una matriz, para lo cual tenemos que hacer:</p> <pre><code>matriz_datos &lt;- as.matrix(dt_tabla_ejemplo, rownames = 1)\n</code></pre> <p>Donde <code>rownames = 1</code> le est\u00e1 indicando a R que los valores de la primera columna de <code>dt_tabla_ejemplo</code> van a ser usados como los nombres de cada fila de la matriz.</p> <p>2) Corran el c\u00f3digo anterior (sin el ejemplo) e impriman <code>matriz_datos</code> por consola. Van a ver que es similar a como se imprim\u00eda el Data Table, solo que las filas tienen nombre. Traten ahora de acceder a los valores de la primera columna de <code>matriz_datos</code>, \u00bfc\u00f3mo tienen que hacer para lograrlo?</p>","tags":["practicos"]},{"location":"practicos/TP08a_Clustering/#crear-la-matriz-de-distancias","title":"Crear la matriz de distancias","text":"<p>Ahora que tenemos una matriz con los nombres de los genes en las filas y las columnas, queremos usar la funci\u00f3n <code>dist</code> para calcular la matriz de distancias. El c\u00f3digo es:</p> <pre><code>matriz_distancias &lt;- dist(matriz_datos, method = \"euclidean\", diag = T)\n</code></pre> <p>Donde <code>method = \"euclidean\"</code> le est\u00e1 diciendo a la funci\u00f3n <code>dist</code> que tiene que calcular las distancias euclidianas entre filas y <code>diag = T</code> hace que deje la diagonal de ceros en el output.</p> <p>3) Corran el c\u00f3digo anterior e impriman <code>matriz_distancias</code> por consola. \u00bfCoinciden los datos con la matriz de distancias vista en el Ejercicio 1?</p>","tags":["practicos"]},{"location":"practicos/TP08a_Clustering/#hacer-el-clustering-jerarquico","title":"Hacer el clustering jer\u00e1rquico","text":"<p>El clustering jer\u00e1rquico se hace con la funci\u00f3n <code>hclust</code>, la cual se usa:</p> <pre><code>clustering_jerarquico &lt;- hclust(matriz_distancias, method = \"complete\")\n</code></pre> <p>Donde <code>method = \"complete\"</code> est\u00e1 indic\u00e1ndole a la funci\u00f3n que criterio de agregaci\u00f3n usar al momento de combinar elementos. Pueden usar <code>help(hclust)</code> para ver otros posibles criterios.</p> <p>4) Corran el c\u00f3digo anterior e impriman <code>clustering_jerarquico</code> por consola. \u00bfDa alguna informaci\u00f3n \u00fatil a simple vista?</p> <p>5) Usen la funci\u00f3n <code>plot</code> para plotear <code>clustering_jerarquico</code>. Usen el par\u00e1metro <code>main</code> para cambiarle el t\u00edtulo al plot indicando que es un clustering jer\u00e1rquico, que usa complete linkage y que usa datos sin estandarizar.</p>","tags":["practicos"]},{"location":"practicos/TP08a_Clustering/#asignando-clusters","title":"Asignando clusters","text":"<p>Cuando uno mira el \u00e1rbol creado en el punto 5) es com\u00fan detectar que ciertos genes son m\u00e1s similares entre s\u00ed que otros y suponer que entonces pertenecen a un mismo grupo. Esto se puede calcular computacionalmente \"cortando\" el \u00e1rbol usando un cierto umbral de similitud y agrupando en un mismo cluster a aquellos elementos que queden por debajo de ese umbral.</p> <p>Esto se puede hacer de dos formas, o determinando el umbral de similitud o determinando la cantidad de clusters a crear.</p> <pre><code>clusters_porAltura &lt;- cutree(clustering_jerarquico, h = @@EDITAR@@)\nclusters_porCantidad &lt;- cutree(clustering_jerarquico, k = @@EDITAR@@)\n</code></pre> <p>Donde <code>h</code> es el par\u00e1metro que recibe la altura de similitud a la cual cortar (eje y en el plot anterior) y <code>k</code> es el par\u00e1metro que recibe la cantidad de clusters a crear. Hay que usar uno o el otro.</p> <p>6) Bas\u00e1ndose en el plot creado en el punto 5), corran el c\u00f3digo anterior cambiando <code>@@EDITAR@@</code> por el n\u00famero correspondiente para agrupar los genes como le parezca mejor. Impriman las variables <code>clusters_porAltura</code> y <code>clusters_porCantidad</code> para confirmar que los genes se agruparon como ustedes quer\u00edan.</p> Extraer esta informaci\u00f3n a un Data Table <p>La variable <code>clusters_porAltura</code> es un vector con nombres, por lo que si quisi\u00e9ramos extraer su informaci\u00f3n y guardarla en un Data Table, tendr\u00edamos que hacer:</p> <pre><code>dt_clusters_porAltura &lt;- data.table(gen = names(genes_clusters_porAltura),\n                                    cluster = genes_clusters_porAltura)\n</code></pre>","tags":["practicos"]},{"location":"practicos/TP08a_Clustering/#datos-estandarizados","title":"Datos estandarizados","text":"","tags":["practicos"]},{"location":"practicos/TP08a_Clustering/#estandarizar-los-datos","title":"Estandarizar los datos","text":"<p>El primer paso para trabajar con estos datos es estandarizarlos como hicimos en el Ejercicio 1. Si bien podr\u00edamos calcular a mano el promedio (funci\u00f3n <code>mean</code>) y la desviaci\u00f3n estandar (funci\u00f3n <code>sd</code>) de cada fila y luego hacer las cuentas, existe ya en R una funci\u00f3n que hace esta estandarizaci\u00f3n por nosotros.</p> <p>Esta funci\u00f3n es <code>scale</code>, pero un problema que tenemos es que dicha funci\u00f3n estandariza por columna, no por fila. Por suerte es bastante f\u00e1cil en R transponer una matriz (lo que b\u00e1sicamente cambia filas por columnas y viceversa). Esto se hace usando la funci\u00f3n <code>t</code>.</p> <pre><code>#Transpongo la matriz de datos\nt_matriz_datos &lt;- t(matriz_datos) \n\n#Estandarizo los datos por columna (que ahora son los tres tiempos de cada gen)\n#*scale* va a devolver una variable que tiene mas informacion que una matriz, pero funciona como matriz\nt_matriz_datos_ST &lt;- scale(t_matriz_datos) \n\n#Vuelvo a transponer la matriz, lo cual la pone en el orden de antes, ahora estandarizada\nmatriz_datos_ST &lt;- t(t_matriz_datos_ST) \n</code></pre> <p>7) Corran el c\u00f3digo anterior e impriman <code>matriz_datos_ST</code> por consola. \u00bfCoinciden los datos estandarizados con los obtenidos en el Ejercicio 1?</p>","tags":["practicos"]},{"location":"practicos/TP08a_Clustering/#hacer-el-resto-del-analisis","title":"Hacer el resto del an\u00e1lisis","text":"<p>8) Vuelvan a hacer los pasos 3) a 6) usando la nueva matriz de datos estandarizados, <code>matriz_datos_ST</code>. Vayan creando nuevas variables en cada caso para no sobrescribir las anteriores (recomendamos usar los mismos nombres y agregarles el sufijo <code>_ST</code>).</p>","tags":["practicos"]},{"location":"practicos/TP08a_Clustering/#ejercicio-3-k-means-y-silhouette","title":"Ejercicio 3 - K-means y Silhouette","text":"","tags":["practicos"]},{"location":"practicos/TP08a_Clustering/#k-means","title":"K-means","text":"<p>Otro m\u00e9todo muy popular para agrupar elementos es el K-means. A diferencia del clustering jer\u00e1rquico, \u00e9ste no crea un \u00e1rbol de similitud, sino que utiliza un m\u00e9todo iterativo para asignar directamente cada elemento a diferentes grupos. Otra caracter\u00edstica del K-means es que hay que pasarle el n\u00famero de clusters a crear.</p> <p>La funci\u00f3n <code>kmeans</code> viene con R y se usa:</p> <pre><code>#Esta funcion controla el aspecto azaroso de kmeans para que nos de igual a todos\nset.seed(1)\n\n#Corro la funcion kmeans para los datos estandarizados pidiendole 2 clusters\nclustering_kmeans_k2_ST &lt;- kmeans(matriz_datos_ST, centers = 2)\n\n#Extraigo los clusters calculados\nclusters_kmeans_k2_ST &lt;- clustering_kmeans_k2_ST$cluster\n</code></pre> <p>Donde <code>centers = 2</code> le est\u00e1 diciendo a la funci\u00f3n que cree 2 clusters (lo que estoy indicando en el nombre de la variable con _k2 para que no haya confusi\u00f3n m\u00e1s adelante).</p> <p>Tip - Predeterminar el azar</p> <p>La funci\u00f3n <code>kmeans()</code> genera la primera posici\u00f3n de sus centros al azar. Esto hace que si la corren varias veces o en diferentes computadoras va a dar diferentes resultados cada vez. Esto se puede controlar con una funci\u00f3n de R que asigna a mano el valor de la seed, que es el n\u00famero base que usa R al momento de generar azar. Si les interesa hacer esto tienen que ejecutar la siguiente l\u00ednea antes de usar la funci\u00f3n <code>kmeans()</code>:</p> <pre><code>set.seed(1)\n</code></pre> <p>P.D.: El azar en las computadoras no existe realmente. Muchos programas usan lista pre-generadas de \"n\u00fameros creados al azar\" y otras usan cosas como \"el quinto decimal de la temperatura del procesador en este momento\", lo que se aproxima suficientemente al azar para funcionar bien.</p> <p>1) Corran el c\u00f3digo anterior y comparen estos clusters a los obtenidos para los datos estandarizados en el Ejercicio 2 usando clustering jer\u00e1rquico.</p>","tags":["practicos"]},{"location":"practicos/TP08a_Clustering/#silhouette","title":"Silhouette","text":"<p>Para cada elemento presente en un agrupamiento se puede calcular un Silhouette coeficient, el cual es un n\u00famero entre -1 y 1 que indica que tan similar es dicho elemento a otros elementos de su mismo cluster y que tan diferente es dicho elemento a los elementos de otros clusters. Cuanto m\u00e1s cerca de 1, mejor asignado esta dicho elemento en su cluster.</p> <p>Es posible entonces calcular el promedio de los Silhouette coefficients de todos los elementos presentes en un agrupamiento, donde promedios m\u00e1s cercanos a 1 van a indicar que el agrupamiento general es mejor.</p> <p>Este m\u00e9todo tiene bastantes usos, pero uno de los m\u00e1s comunes es definir cu\u00e1l es el n\u00famero ideal de clusters a crear con K-means. </p> <p>En R Esta funci\u00f3n se usa:</p> <pre><code>library(cluster) #paquete que contiene la funcion silhouette()\n\n#Calculo los silhouette coefficients para los datos estandarizados agrupados en 2 clusters usando kmeans \n#Tengo que pasarle tambien la matriz de distancias correspondiente para que pueda calcular similitud entre elementos\nsilhouette_kmeans_k2_ST &lt;- silhouette(clusters_kmeans_k2_ST, dist = matriz_distancias_ST)\n\n#La funcion *silhouette* saca los nombres de las filas, por lo cual ahora mis genes estan como numeros\n#Para recuperar los nombres de las filas (o *rownames*) hago lo siguiente\nrownames(silhouette_kmeans_k2_ST) &lt;- rownames(matriz_datos_ST)\n\n#Podemos plotear los silhouette coefficients con plot\nplot(silhouette_kmeans_k2_ST, main = \"STD - Kmeans - centers = 2\")\n\n#Y podemos extraer el promedio de los *Silhouette coefficients*\npromedio_silhouette_kmeans_k2_ST &lt;- summary(silhouette_kmeans_k2_ST)[[1]][[\"Mean\"]]\n</code></pre> <p>2) Corran el c\u00f3digo anterior y vean su salida.</p> <p>3) Bas\u00e1ndose en los c\u00f3digos usados en 1) y en 2), vuelvan a agrupar a los cuatro genes en base a sus datos estandarizados pero ahora en 3 clusters. Luego ploteen los Silhouette coefficients de este agrupamiento y calculen su promedio. Guarden estos nuevos datos en variables con diferentes nombres que las anteriores.</p> <p>4) Comparando lo obtenido en los puntos anteriores, \u00bfqu\u00e9 n\u00famero de clusters resulta en un mejor promedio para los Silhouette coefficients? \u00bfcoincide esto con lo observado en el dendrograma hecho a partir del clustering jer\u00e1rquico?</p>","tags":["practicos"]},{"location":"practicos/TP08a_Clustering/#bibliografia","title":"Bibliograf\u00eda","text":"","tags":["practicos"]},{"location":"practicos/TP08a_Clustering/#consola-de-r","title":"Consola de R","text":"<ul> <li>Comando <code>help()</code></li> </ul>","tags":["practicos"]},{"location":"practicos/TP08b_Data_Mining/","title":"Practico Ocho","text":"","tags":["practicos"]},{"location":"practicos/TP08b_Data_Mining/#tp-8b-data-mining","title":"TP 8b. Data Mining","text":"<p> Materiales</p>","tags":["practicos"]},{"location":"practicos/TP08b_Data_Mining/#slides-mostrados-en-la-clase","title":"Slides mostrados en la clase","text":"<ul> <li> Slides TP</li> </ul>","tags":["practicos"]},{"location":"practicos/TP08b_Data_Mining/#videos-de-la-clase-grabada","title":"Videos de la clase grabada","text":"<ul> <li> Cierre TP</li> </ul>","tags":["practicos"]},{"location":"practicos/TP08b_Data_Mining/#software-a-usar","title":"Software a usar","text":"<ul> <li>R (ya instalado en la VM).</li> <li>RStudio (ya instalado en la VM)</li> </ul>","tags":["practicos"]},{"location":"practicos/TP08b_Data_Mining/#recursos-online","title":"Recursos Online","text":"<ul> <li>Curso online de R de Coursera (se puede hacer gratis) (en ese caso no da certificado)</li> <li>Data Tables: Introducci\u00f3n oficial y otra p\u00e1gina con m\u00e1s info</li> <li>ggplot2: Vistazo r\u00e1pido, detalles sobre los tipos de plots, cheatsheet e informaci\u00f3n sobre colores y daltonismo</li> <li>dendextend: Detalle del paquete</li> </ul>","tags":["practicos"]},{"location":"practicos/TP08b_Data_Mining/#objetivos","title":"Objetivos","text":"<ul> <li>Usar m\u00e9todos de clustering junto con herramientas de programaci\u00f3n para resolver problemas biol\u00f3gicos.</li> <li>Familiarizarse en el paquete <code>ggplot2</code> para hacer plots en R.</li> <li>Introducir paquetes de R que permiten plotear dendrogramas y heatmaps.</li> </ul>","tags":["practicos"]},{"location":"practicos/TP08b_Data_Mining/#introduccion-al-tema","title":"Introducci\u00f3n al Tema","text":"<p>Este TP retoma lo empezado en el TP 10a, donde aprendimos m\u00e9todos de clustering como clustering jer\u00e1rquico o K-means y los aplicamos a un ejemplo m\u00ednimo de una tabla con solo 4 filas.</p> <p>Vamos ahora a utilizar los mismos m\u00e9todos para trabajar con data sets m\u00e1s grandes y tratar de ir entendiendo cu\u00e1ndo, c\u00f3mo y por qu\u00e9 es conveniente agrupar nuestros datos.</p> <p>A su vez vamos a desarrollar algunos temas de R que son muy \u00fatiles, pero para los cuales no nos alcanz\u00f3 el tiempo en los TPs anteriores: plotear usando <code>ggplot2</code> y utilizar funciones creadas por nosotros.</p> <p>Para hacer esto vamos a utilizar 2 data sets. En el Ejercicio 1 vamos a trabajar con el ya conocido data set iris que tiene 150 filas y viene por defecto con R. En el Ejercicio 2 vamos a trabajar con datos de un estudio de transcript\u00f3mica que nos devolvi\u00f3 9 datos para cada uno de 11.106 genes estudiados. Este trabajo es un segundo paso de lo realizado en el TP 5b cuando busc\u00e1bamos inhibidores para la Enzima Z.</p>","tags":["practicos"]},{"location":"practicos/TP08b_Data_Mining/#mejores-plots-ggplot2","title":"Mejores plots: ggplot2","text":"","tags":["practicos"]},{"location":"practicos/TP08b_Data_Mining/#bases-de-ggplot2","title":"Bases de ggplot2","text":"<p>En el TP 5a mencionamos r\u00e1pidamente al paquete <code>ggplot2</code>, el cual es uno de las formas m\u00e1s populares de hacer plots en R. Este paquete es bastante complicado y tiene un sinf\u00edn de funcionalidades, pero hoy vamos a darle un vistazo a su funcionalidad b\u00e1sica (el cheatsheet es una forma r\u00e1pida de ver todas las posibilidades que tiene).</p> <p>Un ejemplo muy simple de hacer un plot con la funci\u00f3n <code>ggplot</code> ser\u00eda:</p> <pre><code>library(ggplot2)\n\n#Recuerden que *iris* es un *Data Frame* para hacer pruebas que esta siempre cargado en la memoria de R\np &lt;- ggplot(data = iris, aes(x = Petal.Length, y = Sepal.Length)) +\n    geom_point()\n\nprint(p)\n</code></pre> <ul> <li>p es una variable en la que estoy guardando el plot. Cuando la imprimo (usando <code>print</code>) el plot va a aparecer en la pesta\u00f1a Plots en RStudio (en el panel de abajo a la derecha).</li> <li><code>data = iris</code> le est\u00e1 indicando a la funci\u00f3n <code>ggplot</code> de que tabla va a sacar la informaci\u00f3n a plotear. En <code>ggplot</code> se pueden usar Data Frames o Data Tables indistintamente.</li> <li><code>aes()</code> es una funci\u00f3n que se encuentra dentro de la funci\u00f3n principal de <code>ggplot</code>. Se va a encargar de relacionar las diferentes columnas de la tabla con las diferentes variables del plot.</li> <li><code>x = Petal.Length</code> est\u00e1 indicando que la variable X en el plot va a ser los datos de la columna Petal.Length.</li> <li><code>y = Sepal.Length</code> est\u00e1 indicando que la variable Y en el plot va a ser los datos de la columna Sepal.Length.</li> <li><code>geom_point()</code> est\u00e1 indicando el tipo de plot a realizar. Si leen el cheatsheet van a ver que en este caso estamos haciendo un scatter plot.</li> <li>Ambas funciones del plot est\u00e1n separadas por el s\u00edmbolo <code>+</code>, lo que les puede resultar un poco extra\u00f1o (porque lo es), pero as\u00ed es como funciona <code>ggplot</code>.</li> </ul> <p>1) Corran el c\u00f3digo anterior y vean el plot resultante.</p>","tags":["practicos"]},{"location":"practicos/TP08b_Data_Mining/#cambiar-la-estetica-del-plot-segun-variables","title":"Cambiar la est\u00e9tica del plot seg\u00fan variables","text":"<p>La funci\u00f3n <code>aes()</code> recibe su nombre de la palabra en ingl\u00e9s aesthetics, o est\u00e9tica. No es de extra\u00f1ar entonces que dentro de dicha funci\u00f3n es donde podemos poner otras variables que determinen los colores, formas o tama\u00f1os de cada punto del plot (entre otras caracter\u00edsticas).</p> <p>2) Corran el siguiente c\u00f3digo y vean el plot resultante:</p> <pre><code>p &lt;- ggplot(data = iris, aes(x = Petal.Length, y = Sepal.Length, color = Species)) +\n    geom_point()\n\nprint(p)\n</code></pre> <p>En este c\u00f3digo, <code>color = Species</code> le est\u00e1 diciendo a <code>ggplot</code> que modifique el color de los puntos dependiendo del valor de la columna Species. Si recuerdan a iris, esta columna era una columna categ\u00f3rica (o factor) con 3 valores que podemos ver en el plot. Como le pasamos a <code>color</code> una variable categ\u00f3rica, nos devolvi\u00f3 una escala de colores categ\u00f3rica.</p> <p>3) Corran el c\u00f3digo anterior, pero ahora reemplacen a Species por Petal.Width, \u00bfqu\u00e9 cambios observan?</p> <p>4) Es posible tambi\u00e9n modificar varias de estas caracter\u00edsticas a la vez. Corran el siguiente c\u00f3digo y vean el plot resultante:</p> <pre><code>p &lt;- ggplot(data = iris, aes(x = Petal.Length, y = Sepal.Length, color = Species, shape = Species, size = Petal.Width)) +\n    geom_point()\n\nprint(p)\n</code></pre> <p>En este caso agregamos 2 caracter\u00edsticas nuevas, <code>shape</code> (la forma de los puntos) y <code>size</code> (el tama\u00f1o de los puntos) y le asignamos cada uno de ellos a una variable de la tabla. Noten que no hay problema con que una columna modifique m\u00e1s de una caracter\u00edstica a la vez.</p> <p>5) Tal vez ya lo notaron, pero por el momento no tenemos ning\u00fan control sobre que colores o formas le asigna <code>ggplot</code> a mis tres categor\u00edas. Vamos a mostrarles como hacerlo para este caso espec\u00edfico, pero sepan que las funciones a usar son ligeramente diferentes dependiendo si la variable pasada es discreta o continua. </p> <p>Corran el siguiente c\u00f3digo y vean el plot resultante:</p> <pre><code>#Los colores se pueden escribir en ingles o en hexadecimal\n#\"#FF0000\" es el color rojo (se podr\u00eda haber puesto \"red\")\np &lt;- ggplot(data = iris, aes(x = Sepal.Length, y = Petal.Length, color = Species, shape = Species)) +\n    geom_point() +\n    scale_colour_manual(values = c(\"#FF0000\", \"blue\", \"green\")) +\n    scale_shape_manual(values =  c(2, 4, 1))\n\nprint(p)\n</code></pre> <ul> <li><code>scale_colour_manual()</code>: me permite modificar a mano una escala discreta de colores. El par\u00e1metro <code>values</code> modifica los colores en s\u00ed.</li> <li><code>scale_shape_manual()</code>: me permite modificar a mano una escala discreta de formas. El par\u00e1metro <code>values</code> modifica las formas, las cuales corresponden a un n\u00famero entero (en el tip a continuaci\u00f3n se muestran las m\u00e1s comunes).</li> </ul> <p>Un detalle importante a destacar es que el orden en que se asign\u00f3 cada color a cada categor\u00eda depende del orden en el que aparecen los Levels de la columna Species, la cual es un factor (pueden imprimir <code>iris$Species</code> para ver a lo que nos referimos). </p> Tip - Posibles valores para <code>shape</code> <p> </p> <p>El color interior las formas 21 a 25 depende de la variable <code>fill</code> que no mencionamos todav\u00eda, pero se usa igual que el resto.</p> Tip - Colores y daltonismo <p>El daltonismo ocurre cuando hay un problema con los pigmentos en ciertas c\u00e9lulas nerviosas del ojo que perciben el color. Estas c\u00e9lulas se llaman conos y los hay de tres tipos, los cuales son responsables de ver principalmente al rojo, al verde y al azul respectivamente. </p> <p> </p> <p>La frecuencia del daltonismo es bastante alta, con un 8% de los hombres cauc\u00e1sicos, 5% de los asi\u00e1ticos y 4% de los africanos presentando problemas para distinguir el color rojo del verde. Como la mayor\u00eda de los casos de daltonismo provienen de una mutaci\u00f3n de un gen recesivo ligado al cromosoma X, muy pocas mujeres son dalt\u00f3nicas.</p> <p>Debido al considerable n\u00famero de personas con daltonismo, es buena \u00eddea tener en cuenta esto al momento de elegir colores para cualquier figura que vaya a ser vistas por el p\u00fablico general. Se pueden encontrar decenas de herramientas online que nos ayudan a crear esto, as\u00ed como paquetes de R o paletas de colores. Un ejemplo de una paleta de colores ser\u00eda:</p> <p> </p> <p>Pueden leer m\u00e1s informaci\u00f3n sobre este tema aca.</p> Tip - Asignar colores espec\u00edficos a cada caracter\u00edstica sin depender del orden de los Levels <p>Si bien el c\u00f3digo anterior funciona perfecto, depender del orden de los Levels de un factor al momento de matchear color con un valor dado puede ser peligroso. Una forma de estar seguros que le estamos asignando el color correcto a cada valor es usando vectores con nombres (o named vectors). Algo mencionamos de estos vectores en el pasado, pero b\u00e1sicamente son vectores donde cada posici\u00f3n tiene un nombre (adem\u00e1s del \u00edndice). En este caso ser\u00eda:</p> <pre><code>categorias &lt;- c(\"setosa\", \"versicolor\", \"virginica\")\ncolores &lt;- c(\"#FF0000\", \"blue\", \"green\")\nnames(colores) &lt;- categorias\n\n#Puedo acceder a \"blue\" haciendo `colores[2]` o `colores[\"versicolor\"]`\n</code></pre> <p>De hacer <code>scale_colour_manual(values = colores)</code> en la funci\u00f3n <code>ggplot</code> nos asegurar\u00edamos que el primer elemento de <code>categorias</code> va a tener el primer color de <code>colores</code> y as\u00ed.</p> <p>6) Por \u00faltimo, \u00bfqu\u00e9 pasa si no queremos cambiar la est\u00e9tica del plot dependiendo del valor de una variable, sino que simplemente queremos cambiarla y que afecte a todos los puntos por igual? En estos casos hay que modificar dicha caracter\u00edstica dentro de la funci\u00f3n espec\u00edfica del plot.</p> <p>Corran el siguiente c\u00f3digo y vean el plot resultante:</p> <pre><code>p &lt;- ggplot(data = iris, aes(x = Sepal.Length, y = Petal.Length, color = Species)) +\n    geom_point(size = 2, shape = 4) +\n    scale_colour_manual(values = c(\"#FF0000\", \"blue\", \"green\"))\n\nprint(p)\n</code></pre>","tags":["practicos"]},{"location":"practicos/TP08b_Data_Mining/#nombres-y-estilo-de-los-ejes-y-el-plot","title":"Nombres y estilo de los ejes y el plot","text":"<p>7) Ahora que ya modificamos bastante el estilo de los datos, vamos a modificar el resto del plot. Lo primero que vamos a hacer es cambiar el nombre del eje X, el eje Y y el t\u00edtulo del plot.</p> <p>Corran el siguiente c\u00f3digo y vean el plot resultante:</p> <pre><code>p &lt;- ggplot(data = iris, aes(x = Sepal.Length, y = Petal.Length, color = Species, shape = Species)) +\n    geom_point(size = 2) +\n    xlab(\"Sepal Length\") +\n    ylab(\"Petal Length\") +\n    ggtitle(\"Sepal Length vs Petal Length per Species\") +\n    scale_colour_manual(values = c(\"#FF0000\", \"blue\", \"green\")) +\n    scale_shape_manual(values =  c(2, 4, 1))\n\nprint(p)\n</code></pre> <ul> <li><code>xlab()</code>: indica el nombre del eje X</li> <li><code>ylab()</code>: indica el nombre del eje Y</li> <li><code>ggtitle()</code>: indica el t\u00edtulo del plot</li> </ul> <p>8) Si bien obtuvimos lo deseado, puede ser que queramos cambiar el tama\u00f1o de los ejes o centrar el t\u00edtulo. Esto lo hacemos con la funci\u00f3n <code>theme()</code>:</p> <p>Corran el siguiente c\u00f3digo y vean el plot resultante:</p> <pre><code>p &lt;- ggplot(data = iris, aes(x = Sepal.Length, y = Petal.Length, color = Species, shape = Species)) +\n    geom_point(size = 2) +\n    xlab(\"Sepal Length\") +\n    ylab(\"Petal Length\") +\n    ggtitle(\"Sepal Length vs Petal Length per Species\") +\n    theme(plot.title = element_text(size = 16, hjust = 0.5),\n          axis.title = element_text(size = 14),\n          axis.text = element_text(size = 12)) +\n    scale_colour_manual(values = c(\"#FF0000\", \"blue\", \"green\")) +\n    scale_shape_manual(values =  c(2, 4, 1))\n\nprint(p)\n</code></pre> <ul> <li><code>theme()</code>: es la funci\u00f3n que contiene el estilo del texto de los ejes y del t\u00edtulo de un plot.</li> <li><code>plot.title = element_text(size = 16, hjust = 0.5)</code>: estamos modificando el titulo del plot, donde <code>size</code> modifica el tama\u00f1o de letra y <code>hjust = 0.5</code> lo centra horizontalmente.</li> <li><code>axis.title = element_text(size = 14)</code>: estamos modificando los t\u00edtulos de los ejes (es decir, los nombre de los ejes).</li> <li><code>axis.text = element_text(size = 12)</code>: estamos modificando el tama\u00f1o de los n\u00fameros de los ejes.</li> </ul> <p>Noten que dentro de <code>theme()</code> cada l\u00ednea se separa con comas, y reci\u00e9n una vez que termina volvemos a usar el s\u00edmbolo <code>+</code>.</p>","tags":["practicos"]},{"location":"practicos/TP08b_Data_Mining/#fondo-del-plot","title":"Fondo del plot","text":"<p>9) Lo \u00faltimo que nos queda por modificar es el \"fondo\" del plot, es decir, el color de fondo, las l\u00edneas que corresponden a las divisiones de los ejes y el recuadro general del plot. Si bien esto se puede hacer a mano, ggplot viene con algunas opciones ya armadas.</p> <p>Corran el siguiente c\u00f3digo y vean el plot resultante:</p> <pre><code>p &lt;- ggplot(data = iris, aes(x = Sepal.Length, y = Petal.Length, color = Species, shape = Species)) +\n    geom_point(size = 2) +    \n    xlab(\"Sepal Length\") +\n    ylab(\"Petal Length\") +\n    ggtitle(\"Sepal Length vs Petal Length per Species\") +\n    theme_bw() +\n    theme(plot.title = element_text(size = 16, hjust = 0.5),\n          axis.title = element_text(size = 14),\n          axis.text = element_text(size = 12)) +\n    scale_colour_manual(values = c(\"#FF0000\", \"blue\", \"green\")) +\n    scale_shape_manual(values =  c(2, 4, 1))\nprint(p)\n</code></pre> <ul> <li><code>theme_bw()</code> es una funci\u00f3n que setea varias opciones de <code>theme()</code> a un estilo espec\u00edfico (en este caso un estilo simple en blanco y negro). La tenemos que usar antes de <code>theme()</code> para asegurarnos que cualquier cambio que hagamos a mano en <code>theme()</code> sobrescriba los de <code>theme_bw()</code>.</li> </ul>","tags":["practicos"]},{"location":"practicos/TP08b_Data_Mining/#otros-tipos-de-plots","title":"Otros tipos de plots","text":"<p>Si bien la mayor\u00eda de lo que les mencionamos hasta ahora es aplicable al uso general de ggplot, hasta el momento nos enfocamos en un solo tipo de plot, el scatter plot, hecho mediante <code>geom_point()</code>.</p> <p>Debido a que esto es suficiente para lo que necesitamos hacer hoy (y que este TP es de Data Mining) no vamos a hablar hoy de otros tipos de plots, pero si les interesa pueden verlo con mucho detalle en esta p\u00e1gina o ver un vistazo r\u00e1pido en la cheatsheet.</p>","tags":["practicos"]},{"location":"practicos/TP08b_Data_Mining/#ejercicio-1-agrupando-flores-por-especies","title":"Ejercicio 1 - Agrupando flores por especies","text":"","tags":["practicos"]},{"location":"practicos/TP08b_Data_Mining/#introduccion-al-data-set","title":"Introducci\u00f3n al data set","text":"<p>En este ejercicio vamos a trabajar una vez m\u00e1s con el data set iris, el cual es un set de datos que viene por defecto con R y est\u00e1 siempre cargado en memoria.</p> <p>Este data set contiene las medidas de ancho (width) y largo (length) de los s\u00e9palos y los p\u00e9talos para 3 especies de flores diferentes: setosa, versicolor, y virginica (todas del Genus Iris). Tiene mediciones de 150 flores, 50 por especie.</p> S\u00e9palo vs p\u00e9talo <p> </p> <p>Antes que nada vamos a familiarizarnos un poco con este data set.</p> <p>1) Corran el siguiente c\u00f3digo y vean el plot resultante:</p> <pre><code>library(data.table)\nlibrary(ggplot2)\n\n#Transformo a iris en un *Data Table* (que aca realmente no hace falta, pero para despues)\ndt_iris &lt;- as.data.table(iris)\n\n#Hago un plot comparando el largo de los sepalos y los petalos\n#Estoy cambiando la forma y el color segun la especie\np &lt;- ggplot(data = dt_iris, aes(x = Sepal.Length, y = Petal.Length, color = Species)) +\n    geom_point(size = 2) +\n    theme_bw() +\n    xlab(\"Sepal Length\") +\n    ylab(\"Petal Length\") +\n    ggtitle(\"Sepal Length vs Petal Length per Species\") +\n    theme(plot.title = element_text(size = 16, hjust = 0.5),\n          axis.title = element_text(size = 14),\n          axis.text = element_text(size = 12)) +\n    scale_colour_manual(values = c(\"#004D40\",\"#D81B60\",\"#FFC107\"))\n\nprint(p)\n</code></pre> <p>Podemos ver que con solo plotear el largo de los p\u00e9talos y los s\u00e9palos ya estamos viendo diferencias entre las especies. Es te\u00f3ricamente posible agregar una tercera dimensi\u00f3n para plotear otra de las variables, e incluso agregar la cuarta variable como \"tama\u00f1o\" de los diferentes puntos, pero dichos plots van a resultar considerablemente mas complejos al momento de leerlos.</p>","tags":["practicos"]},{"location":"practicos/TP08b_Data_Mining/#problema-a-resolver","title":"Problema a resolver","text":"<p>En este ejercicio vamos a suponer que alguien apret\u00f3 el bot\u00f3n equivocado y borr\u00f3 la columna Species de dicha tabla. Como nos acordamos de que eran tres especies y que ten\u00edan diferencias en sus largos y anchos de p\u00e9talos y s\u00e9palos, queremos entonces usar m\u00e9todos de clustering para tratar de recuperar lo mejor que podamos los tres grupos de flores.</p> <p>Dicho esto vamos a hacer un poco de trampa y vamos a comparar visualmente lo que vamos obteniendo por los m\u00e9todos de clustering con lo que nosotros sabemos es verdad.</p> <p>Por \u00faltimo, c\u00f3mo vamos a tener que hacer varios plots similares, vamos a aprovechar la oportunidad y vamos a usar por primera vez funciones de R creadas por nosotros.</p>","tags":["practicos"]},{"location":"practicos/TP08b_Data_Mining/#guardar-el-plot-en-un-pdf","title":"Guardar el plot en un PDF","text":"<p>Vamos a crear una funci\u00f3n que guarde diferentes plots como PDFs.</p> <p>2) Copien el siguiente c\u00f3digo y modifiquen las secciones que dicen <code>@@EDITAR@@</code>. Para esto vean el punto 1) y as\u00edgnenle a cada par\u00e1metro de la funci\u00f3n el valor que ten\u00eda en dicho punto, por ejemplo <code>x_colname = \"Sepal.Length\"</code> (el nombre de las columnas v\u00e1 entre comillas porque estamos usando <code>aes_string()</code> y no <code>aes()</code>). Una vez hecho esto, corran la funci\u00f3n para replicar el plot hecho en el punto 1) y guardarlo en un archivo llamado 01_Sepal_vs_Petal_Length_per_Species.pdf.</p> C\u00f3digoC\u00f3digo con comentarios <pre><code>library(data.table)\nlibrary(ggplot2)\n\n#### FUNCIONES AUXILIARES ####\nplotData2PDF_wColor &lt;- function(data_par,\n                                x_colname, y_colname, color_colname,\n                                x_label, y_label, plot_title,\n                                pdf_file) {\n    p &lt;- ggplot(data = data_par, aes_string(x = x_colname, y = y_colname, color = color_colname)) +\n        geom_point(size = 2) +\n        theme_bw() +\n        xlab(x_label) +\n        ylab(y_label) +\n        ggtitle(plot_title) +\n        theme(plot.title = element_text(size = 16, hjust = 0.5),\n              axis.title = element_text(size = 14),\n              axis.text = element_text(size = 12)) +\n        scale_colour_manual(values = c(\"#004D40\",\"#D81B60\",\"#FFC107\"))\n\n    pdf(file = pdf_file, width = 8, height = 7)\n    print(p)\n    dev.off()\n}\n\n#### CODIGO PRINCIPAL ####\ndt_iris &lt;- as.data.table(iris)\n\nplotData2PDF_wColor(data_par = dt_iris,\n                    x_colname = \"@@EDITAR@@\", \n                    y_colname = \"@@EDITAR@@\", \n                    color_colname = \"@@EDITAR@@\",\n                    x_label = \"@@EDITAR@@\", \n                    y_label = \"@@EDITAR@@\", \n                    plot_title = \"@@EDITAR@@\",                        \n                    pdf_file = \"01_Sepal_vs_Petal_Length_per_Species.pdf\")    \n</code></pre> <pre><code>library(data.table)\nlibrary(ggplot2)\n\n#Estoy usando comentarios rodeados de cuatro numerales para delimitar secciones de mi c\u00f3digo \n#Esto no es puramente est\u00e9tico, sino que tambi\u00e9n es aprovechado por *RStudio* para crear una de barra de \n#navegaci\u00f3n del c\u00f3digo (es la barra horizontal entre el script y la consola)\n#### FUNCIONES AUXILIARES ####\nplotData2PDF_wColor &lt;- function(data_par,\n                                x_colname, y_colname, color_colname,\n                                x_label, y_label, plot_title,\n                                pdf_file) {\n    #La funci\u00f3n *aes_string()* es similar a *aes()*, solo que en este caso los nombres de las columnas \n    #tienen que ser *strings* (recuerden que con *aes()* se escriben sin comillas)\n    #Esto es ideal para cuando el nombre de la columna utilizar esta guardado en una variable\n    p &lt;- ggplot(data = data_par, aes_string(x = x_colname, y = y_colname, color = color_colname)) +\n        geom_point(size = 2) +\n        theme_bw() +\n        xlab(x_label) +\n        ylab(y_label) +\n        ggtitle(plot_title) +\n        theme(plot.title = element_text(size = 16, hjust = 0.5),\n              axis.title = element_text(size = 14),\n              axis.text = element_text(size = 12)) +\n        scale_colour_manual(values = c(\"#004D40\",\"#D81B60\",\"#FFC107\"))\n\n    #*pdf()* \"abre\" un archivo pdf. Todo lo que se imprima hasta cerrarlo va a ir a \u00e9l, \n    #en vez de a la pesta\u00f1a *Plots* de *RStudio*\n    #8 y 7 indican el ancho y el alto del pdf en pulgadas\n    pdf(file = pdf_file, width = 8, height = 7)\n    print(p)\n    #La funci\u00f3n *dev.off()* cierra el plot abierto, en este caso el pdf.\n    dev.off()\n}\n\n#### CODIGO PRINCIPAL ####\ndt_iris &lt;- as.data.table(iris)\n\nplotData2PDF_wColor(data_par = dt_iris,\n                    x_colname = \"@@EDITAR@@\", \n                    y_colname = \"@@EDITAR@@\", \n                    color_colname = \"@@EDITAR@@\",\n                    x_label = \"@@EDITAR@@\", \n                    y_label = \"@@EDITAR@@\", \n                    plot_title = \"@@EDITAR@@\",      \n                    pdf_file = \"01_Sepal_vs_Petal_Length_per_Species.pdf\") \n</code></pre> <p>3) Usando la funci\u00f3n que acabamos de crear, vean como se distribuyen los puntos al comparar Sepal.Width contra Petal.Width. Guarden este plot en un archivo llamado 02_Sepal_vs_Petal_Width_per_Species.pdf.</p>","tags":["practicos"]},{"location":"practicos/TP08b_Data_Mining/#clustering-jerarquico","title":"Clustering jer\u00e1rquico","text":"<p>Lo primero que vamos a hacer entonces es usar un clustering jer\u00e1rquico para agrupar a las 150 filas en 3 grupos seg\u00fan los valores de las 4 medidas. Un problema que tenemos es que por ahora no hay ninguna forma de identificar a una fila espec\u00edfica, as\u00ed que le vamos a agregar un ID num\u00e9rico a cada fila. Debido al orden que tienen las filas de dt_iris, los primeros 50 IDs van a corresponder a flores de la especie setosa, los segundos 50 a versicolor y los \u00faltimos a virginica (aunque supuestamente esto no lo sabemos).</p> <p>4) Corran el siguiente c\u00f3digo para crear la matriz de datos que vamos a usar al momento de clusterizar. Lean los comentarios en la segunda pesta\u00f1a para entender que estamos haciendo.</p> C\u00f3digoC\u00f3digo con comentarios <pre><code>dt_iris$row_id &lt;- c(1:dt_iris[, .N])\n\nsetcolorder(dt_iris, c(\"row_id\"))\n\nmatriz_datos &lt;- as.matrix(dt_iris[, -c(\"Species\")], rownames = 1)\n</code></pre> <pre><code>#Agregamos una nueva columna denominada row_id que tiene un numero entre 1 y 150\n#dt_iris[, .N] es una funci\u00f3n de *Data Tables* que me devuelve el numero de filas en la tabla\n#El numero de filas tambien se puede conseguir haciendo nrow(dt_iris)\ndt_iris$row_id &lt;- c(1:dt_iris[, .N])\n\n#Aca estamos cambiando el orden de las columnas a *dt_iris*.\n#No hace falta asignar esto a *dt_iris* ya que *setcolorder* modifica la variable misma \n#Como solo le estamos pasando 1 columna, lo que estamos haciendo es mover esa columna al principio\n#(al usar as\u00ed *setcolorder* las otras se quedan donde estan)\nsetcolorder(dt_iris, c(\"row_id\"))\n\n#Similar a lo que hicimos en el TP anterior, estamos transformando nuestros datos a una matriz\n#donde la primer columna (en este caso *row_id*) va a transformarse en los nombres de las filas\n#Estamos sacando a la columna *Species* ya que queremos simular que no tenemos esta informacion\n#(la columna *Species* va a estar todavia en *dt_iris*, pero no en *matriz_datos*)\nmatriz_datos &lt;- as.matrix(dt_iris[, -c(\"Species\")], rownames = 1)\n</code></pre> <p>5) Usando lo aprendido en el TP anterior y la matriz de datos reci\u00e9n creada:</p> <p>5.1) Usen la funci\u00f3n <code>dist()</code> para crear una matriz de distancias euclidianas que muestre tambi\u00e9n la diagonal.</p> <p>5.2) usen la funci\u00f3n <code>hclust()</code> para crear un clustering jer\u00e1rquico basado en su matriz de distancias usando el criterio de agregaci\u00f3n complete linkage. </p> <p>5.3) Usen la funci\u00f3n <code>plot()</code> para plotear el clustering jer\u00e1rquico.</p> <p>5.4) Mirando el plot reci\u00e9n creado, \u00bfles es f\u00e1cil distinguir a simple vista los tres grupos de especies en el clustering jer\u00e1rquico? (recuerden que pueden usar el bot\u00f3n Zoom para agrandar el plot).</p>","tags":["practicos"]},{"location":"practicos/TP08b_Data_Mining/#mejorar-el-plot-del-clustering-jerarquico","title":"Mejorar el plot del clustering jer\u00e1rquico","text":"<p>6) Una cosa que vendr\u00eda bien al momento de leer el plot reci\u00e9n creado ser\u00eda colorear cada flor dependiendo de su especie. Si bien esto no es posible en este caso usando solo la funci\u00f3n <code>plot()</code>, hay paquetes de R que nos van a permitir hacer esto:</p> <p>6.1) Usen la funci\u00f3n <code>install.packages()</code> e instalen la librer\u00eda dendextend (recuerden que al usar <code>install.packages()</code> el nombre del paquete va entre comillas). Luego corran el siguiente c\u00f3digo:</p> C\u00f3digoC\u00f3digo con comentarios <pre><code>library(dendextend)\n\n#Estoy asumiendo que guardaron la salida de *hclust()* en una variable llamada clustering_jerarquico\n#De no ser asi, cambien el nombre de la variable a continuacion por lo que corresponda\ndend &lt;- as.dendrogram(clustering_jerarquico)\n\ncolores_especies &lt;- c(\"#004D40\",\"#D81B60\",\"#FFC107\")\ncolors_aux &lt;- rep(colores_especies, each = 50)\nlabels_colors(dend) &lt;- colors_aux[order.dendrogram(dend)]\n\ndend &lt;- dend %&gt;% set(\"labels_cex\", 0.6)\n\npdf_file &lt;- \"11_Clustering_jerarquico_complete_linkage.pdf\"\npdf(file = pdf_file, width = 18, height = 6)\n\nplot(x = dend, main = \"Clustering Jer\u00e1rquico - Complete Linkage - Color per Species\")\n\ndev.off()\n</code></pre> <pre><code>library(dendextend)\n\n#Estoy asumiendo que guardaron la salida de *hclust()* en una variable llamada clustering_jerarquico\n#De no ser asi, cambien el nombre de la variable a continuacion por lo que corresponda\n#Aca estoy transformando la variable *clustering_jerarquico* que es de tipo *hclust* a un *dendrogram*, \n#que es una variable usada por el paquete *dendextend*\ndend &lt;- as.dendrogram(clustering_jerarquico)\n\n#La funcion *labels_colors()* me permite asignar a mano los colores para los 150 labels del dendrograma\n#Ahora bien, yo se que originalmente en la tabla las primera 50 filas corresponden al color 1 y asi\n#Lo que estoy haciendo aca es armar una lista de 150 colores ordenada como esta en la tabla original y luego\n#reordenarlas para que coincidan con el orden de los IDs en el dendrograma\ncolores_especies &lt;- c(\"#004D40\",\"#D81B60\",\"#FFC107\")\ncolors_aux &lt;- rep(colores_especies, each = 50)\nlabels_colors(dend) &lt;- colors_aux[order.dendrogram(dend)]\n\n#Esto simplemente es para achicar un poco el texto de los labels para que no choquen entre si\n#El simbolo %&gt;% cumple una funcion similar al + en ggplot\ndend &lt;- dend %&gt;% set(\"labels_cex\", 0.6)\n\n#Creo el pdf de salida y guardo el clustering jer\u00e1rquico\npdf_file &lt;- \"11_Clustering_jerarquico_complete_linkage.pdf\"\npdf(file = pdf_file, width = 18, height = 6)\n\nplot(x = dend, main = \"Clustering Jer\u00e1rquico - Complete Linkage - Color per Species\")\n\ndev.off()\n</code></pre> <p>6.2) Abran el archivo 11_Clustering_jerarquico_complete_linkage.pdf. \u00bfPueden ahora distinguir los tres grupos de especies en el clustering jer\u00e1rquico? \u00bfCu\u00e1les especies les parecen mejor agrupadas? (los colores de las especies corresponden al color usado en el plot creado en los puntos 1) y 2))</p>","tags":["practicos"]},{"location":"practicos/TP08b_Data_Mining/#single-linkage","title":"Single Linkage","text":"<p>7) Hasta el momento s\u00f3lo utilizamos complete linkage al momento de hacer nuestros clustering jer\u00e1rquicos, pero ser\u00eda interesante ver como es el dendrograma resultante de hacer el clustering usando otro criterio de agregaci\u00f3n, por ejemplo el single linkage. Para esto:</p> <p>7.1) Vuelvan a correr la funci\u00f3n <code>hclust()</code> como en 5.2), pero ahora usen <code>method = \"single\"</code> y guarden el clustering resultante en una nueva variable. Luego usen el c\u00f3digo de 6.1) editando lo que sea necesario para crear un archivo que contenga al dendrograma hecho a partir del clustering jer\u00e1rquico que usa single linkage como criterio de agregaci\u00f3n. Nombren a este archivo 12_Clustering_jerarquico_single_linkage.pdf.</p> <p>7.2) \u00bfQu\u00e9 diferencias ven entre este dendrograma y el creado en 6.2)? \u00bfPueden relacionar estas diferencias con lo que saben de single linkage y complete linkage?</p> <p>7.3) Ignorando los colores, \u00bfcu\u00e1l les parece el mejor criterio de agregaci\u00f3n para este caso donde queremos recuperar tres clusters?</p>","tags":["practicos"]},{"location":"practicos/TP08b_Data_Mining/#hacer-clusters-y-plots","title":"Hacer clusters y plots","text":"<p>Por \u00faltimo vamos a querer recrear el plot generado en los puntos 1) y 2), pero ahora mostrando informaci\u00f3n tanto de las especies originales (con el color) como de la agrupaci\u00f3n resultante del clustering jer\u00e1rquico (con la forma). Vamos a utilizar los datos del clustering jer\u00e1rquico que usa el criterio de agregaci\u00f3n complete linkage.</p> <p>8) Lo primero es entonces agregar la informaci\u00f3n del clustering jer\u00e1rquico a nuestro dt_iris; para ello:</p> <p>8.1) Usen la <code>cutree</code> para dividir a los datos obtenidos en 5.2) en 3 clusters.</p> <p>8.2) Asignen esa informaci\u00f3n a una nueva columna en la tabla dt_iris llamada CJ_cluster (como en este caso <code>cutree()</code> devuelve los datos en el mismo orden que est\u00e1n en la tabla se puede hacer directamente con <code>&lt;-</code>, no hace falta usar <code>merge()</code>).</p> <p>8.3) Por el momento la variable es num\u00e9rica, pero para nosotros los n\u00fameros 1, 2 y 3 son categor\u00edas que te\u00f3ricamente corresponden a las especies (aunque no sabemos qu\u00e9 categor\u00eda corresponde a que especie). Corran el siguiente c\u00f3digo para convertir la columna reci\u00e9n creada en un factor:</p> <pre><code>#En este caso poner los levels a mano no es 100% necesario, pero no viene mal\n#Recuerden que no sabemos que numero corresponde a que especie\n#(porque ademas ya vimos que no hay un match perfecto 1 a 1)\ndt_iris$CJ_cluster &lt;- factor(dt_iris$CJ_cluster, levels = c(1, 2, 3))\n</code></pre> <p>9) Ahora queremos hacer un plot similar al creado en el punto 2), pero donde la columna Species determine el color y la columna CJ_cluster determine la forma de los diferentes puntos del plot; para ello:</p> <p>9.1) Copien la funci\u00f3n <code>plotData2PDF_wColor()</code> y c\u00e1mbienle en nombre a <code>plotData2PDF_wColorAndShape()</code>. Modifiquen esta nueva funci\u00f3n considerando lo siguiente:</p> <ul> <li>Agreguen un par\u00e1metro a la funci\u00f3n el cual va a recibir el nombre de la columna que determina la forma, o shape, de los puntos.</li> <li>Modifiquen la funci\u00f3n <code>aes_string()</code>, agregando la caracter\u00edstica <code>shape</code> y asign\u00e1ndole el valor del par\u00e1metro agregado.</li> <li>Agreguen la funci\u00f3n <code>scale_shape_manual()</code> a <code>ggplot</code> para definir a mano las tres formas. Usen los valores <code>c(2, 4, 1)</code>.</li> </ul> <p>9.2) Usando la funci\u00f3n que acabamos de crear, vean como se distribuyen los puntos al comparar Sepal.Length contra Petal.Length usando la columna Species para determinar el color y la columna CJ_cluster para determinar la forma de los diferentes puntos. Guarden este plot en un archivo llamado 21_Sepal_vs_Petal_Length_per_Species_CJ3.pdf.</p> <p>9.3) Abran el archivo reci\u00e9n creado. \u00bfCu\u00e1les especies les parecen mejor agrupadas? Entre este plot y el dendrograma creado en 11_Clustering_jerarquico_complete_linkage.pdf \u00bfCu\u00e1l les parece la mejor manera de representar este clustering? \u00bfPor qu\u00e9?</p> <p>Importante - Clustering vs Plot</p> <p>Tengan en cuenta que al momento de clusterizar estamos usando los datos de las cuatro columnas de la tabla. Sin embargo, en este \u00faltimo plot estamos viendo solo la relaci\u00f3n entre dos. Por esta raz\u00f3n, este plot no es realmente representativo del clustering que estamos haciendo.</p> <p>Dicho todo esto, este plot es \u00fatil ya que es mucho m\u00e1s f\u00e1cil de leer que otros plots m\u00e1s complejos, pero debe tomarse como un an\u00e1lisis exploratorio.</p>","tags":["practicos"]},{"location":"practicos/TP08b_Data_Mining/#kmeans","title":"Kmeans","text":"<p>10) Lo \u00faltimo que vamos a hacer con este data set es volver a crear los clusters pero usando ahora la funci\u00f3n <code>kmeans()</code>.</p> <p>10.1) Usando lo aprendido en el TP anterior:</p> <ul> <li>Usen la funci\u00f3n <code>kmeans()</code> para crear un nuevo clustering. Usen la cantidad de <code>centers</code> que consideren necesarios.</li> <li>Extraigan los clusters del clustering reci\u00e9n creado y as\u00edgnenlos a una nueva columna en dt_iris llamada K3_cluster (como en este caso <code>kmeans()</code> devuelve los datos en el mismo orden que est\u00e1n en la tabla se puede hacer directamente con <code>&lt;-</code>, no hace falta usar <code>merge()</code>).</li> <li>Transformen dicha columna en un factor.</li> <li>Usando la funci\u00f3n creada en el punto 9), vean como se distribuyen los puntos al comparar Sepal.Length contra Petal.Length usando la columna Species para determinar el color y la columna K3_cluster para determinar la forma de los diferentes puntos. Guarden este plot en un archivo llamado 22_Sepal_vs_Petal_Length_per_Species_K3.pdf.</li> </ul> <p>10.2) Abran el archivo reci\u00e9n creado. Bas\u00e1ndose solo en lo que pueden observar en este plot, \u00bfpueden decir algo de si este agrupamiento es mejor, peor o similar al obtenido con el clustering jer\u00e1rquico? (recuerden que \"no\" tambi\u00e9n es una respuesta v\u00e1lida)</p> <p>10.3) Supongamos ahora que estamos en un escenario real, por lo que no tenemos informaci\u00f3n de a que especie corresponde cada punto. En base a lo visto en el TP anterior, \u00bfse les ocurre alguna forma de evaluar objetivamente cu\u00e1l de ambos es el mejor clustering?</p> <p>Tip - Predeterminar el azar</p> <p>La funci\u00f3n <code>kmeans()</code> genera la primera posici\u00f3n de sus centros al azar. Esto hace que si la corren varias veces o en diferentes computadoras va a dar diferentes resultados cada vez. Esto se puede controlar con una funci\u00f3n de R que asigna a mano el valor de la seed, que es el n\u00famero base que usa R al momento de generar azar. Si les interesa hacer esto tienen que ejecutar la siguiente l\u00ednea antes de usar la funci\u00f3n <code>kmeans()</code>:</p> <pre><code>set.seed(1)\n</code></pre> <p>P.D.: El azar en las computadoras no existe realmente. Muchos programas usan lista pre-generadas de \"n\u00fameros creados al azar\" y otras usan cosas como \"el quinto decimal de la temperatura del procesador en este momento\", lo que se aproxima suficientemente al azar para funcionar bien.</p>","tags":["practicos"]},{"location":"practicos/TP08b_Data_Mining/#ejercicio-2-analizando-el-efecto-de-dos-inhibidores","title":"Ejercicio 2 - Analizando el efecto de dos inhibidores","text":"<p>En el TP 5b hicimos un ejercicio donde us\u00e1bamos el equipo FilterMax F5 para analizar 22 inhibidores de una llamada Enzima Z, la cual resulta que era la cruzipa\u00edna, es decir, la ciste\u00edn proteasa principal de Trypanosoma cruzi, el par\u00e1sito causante de la enfermedad de Chagas.</p> <p>En esta segunda fase del experimento se eligieron 2 inhibidores y se realiz\u00f3 un an\u00e1lisis m\u00e1s detallado, estudiando como var\u00eda la expresi\u00f3n de miles de genes en presencia o ausencia de dichos inhibidores. Para esto se hizo un estudio de transcript\u00f3mica (RNA-seq) donde se extrajo el ARN y se lo analiz\u00f3 con Illumina. Luego, cada read encontrado se mape\u00f3 contra el genoma de referencia y se lleg\u00f3 a una tabla de conteo para cada uno de las transcriptos del genoma.</p> <p>Para cada caso (control, droga 1 y droga 2) se realizaron 3 r\u00e9plicas t\u00e9cnicas para obtener resultados m\u00e1s robustos.</p> <p>Nuestro objetivo va a ser entonces obtener una lista de los genes que son m\u00e1s afectados por cada droga.</p>","tags":["practicos"]},{"location":"practicos/TP08b_Data_Mining/#leer-los-datos","title":"Leer los datos","text":"<p>1) Lean los archivos control_data.tsv, drug1_data.tsv y drug2_data.tsv que se encuentran en sus materiales de trabajo y gu\u00e1rdenlos en diferentes variables llamadas control_data, drug1_data y drug2_data respectivamente. Asegurense que las variables son del tipo Data Table</p>","tags":["practicos"]},{"location":"practicos/TP08b_Data_Mining/#estandarizar-los-datos","title":"Estandarizar los datos","text":"<p>El conteo de reads no se puede comparar entre genes puesto que la expresi\u00f3n basal de cada uno es distinto, por lo cual encontrar 10 reads de un gen puede ser mucho, y encontrar 1000 de otro puede ser poco. Adem\u00e1s cada ensayo de secuenciaci\u00f3n puede tener distinta profundidad con lo que tampoco ser\u00eda viable comparar 10 reads de un ensayo donde en total se mapearon \\(2\\text{x}10^8\\) reads con los mismos 10 de otro ensayo donde se mapearon \\(1\\text{x}10^8\\) (es decir, la mitad).</p> <p>Por esta raz\u00f3n vamos a querer modificar las nueve columnas y transformar el valor a \"conteo por mill\u00f3n\", cuya f\u00f3rmula es:</p> \\[ \\text{RPM or CPM} = \\frac{ReadsDelGen * 10^6}{ReadsTotales} \\]","tags":["practicos"]},{"location":"practicos/TP08b_Data_Mining/#combinar-las-replicas","title":"Combinar las r\u00e9plicas","text":"<p>Otra cosa que vamos a querer hacer es combinar las tres r\u00e9plicas para cada caso. Esto lo vamos a hacer simplemente promediando los 3 valores de CPM para cada gen en cada tratamiento.</p> <p>2) En base a los TPs anteriores ya tienen los conocimientos para hacer el estandarizado de datos y la combinaci\u00f3n de r\u00e9plicas usando fors, pero para hacerla un poco m\u00e1s f\u00e1cil les vamos a dar un par de funciones que les van a simplificar bastante este paso (y ya que estamos les mostramos la funci\u00f3n <code>apply()</code> en acci\u00f3n):</p> C\u00f3digoC\u00f3digo con comentarios <pre><code>calcularConteoPorMillon &lt;- function(vector_cuentas) {\n    #Dado un vector de *reads*, esta funcion lo transforma en CPM y devuelve el vector\n\n    vector_cuentas &lt;- vector_cuentas * 1000000 / sum(vector_cuentas) \n\n    return(vector_cuentas)\n}\n\nparsearDatos &lt;- function(dt_par, columnas_a_parsear, nombre_columna_nueva) {\n    #Dado un *Data Table*, un vector de *strings* con los nombres de las columnas con *reads* a parsear y\n    #un nombre de una columna a crear, esta funcion:\n    # - Transforma los *reads* de las columnas a parsear en CPM\n    # - Calcula el promedio de los CPM por cada fila y lo guarda en una columna nueva con el nombre dado\n    # - Saca las columnas a parsear del *Data Table*\n    # - Devuelve el *Data Table* con los cambios\n\n    dt_aux &lt;- dt_par[, columnas_a_parsear, with = F]\n\n    matrix_aux &lt;- apply(dt_aux, 2, calcularConteoPorMillon)\n\n    dt_par[[nombre_columna_nueva]] &lt;- apply(matrix_aux, 1, mean)\n    dt_par[[nombre_columna_nueva]] &lt;- round(dt_par[[nombre_columna_nueva]], 4)\n\n    dt_par &lt;- dt_par[, -columnas_a_parsear, with = F]\n\n    return(dt_par)\n}\n</code></pre> <pre><code>calcularConteoPorMillon &lt;- function(vector_cuentas) {\n    #Dado un vector de *reads*, esta funcion lo transforma en CPM y devuelve el vector\n\n    #Aca estoy asumiendo que sum(vector_cuentas) nunca es 0 (lo que tiene un poco\n    #de sentido ya que si es 0 entonces todas los counts son 0)\n    vector_cuentas &lt;- vector_cuentas * 1000000 / sum(vector_cuentas) \n\n    return(vector_cuentas)\n}\n\nparsearDatos &lt;- function(dt_par, columnas_a_parsear, nombre_columna_nueva) {\n    #Dado un *Data Table*, un vector de *strings* con los nombres de las columnas con *reads* a parsear y\n    #un nombre de una columna a crear, esta funcion:\n    # - Transforma los *reads* de las columnas a parsear en CPM\n    # - Calcula el promedio de los CPM por cada fila y lo guarda en una columna nueva con el nombre dado\n    # - Saca las columnas a parsear del *Data Table*\n    # - Devuelve el *Data Table* con los cambios\n\n    #Creo un nuevo *Data Table* que solo contenga las columnas a parsear (y no el ID del gen)\n    dt_aux &lt;- dt_par[, columnas_a_parsear, with = F]\n\n    #La funcion *apply* con el parametro 2 va a ejecutar la funcion *calcularConteoPorMillon* para \n    #cada COLUMNA de dt_aux (las tres replicas, en este caso)\n    matrix_aux &lt;- apply(dt_aux, 2, calcularConteoPorMillon)\n\n    #La funcion *apply* con el parametro 1 va a ejecutar la funcion *mean* para \n    #cada FILA de matrix_aux (cada uno de los genes estudiados)\n    dt_par[[nombre_columna_nueva]] &lt;- apply(matrix_aux, 1, mean)\n    dt_par[[nombre_columna_nueva]] &lt;- round(dt_par[[nombre_columna_nueva]], 4)\n\n    #Saco las columnas que ya no me interesan de *dt_par*\n    dt_par &lt;- dt_par[, -columnas_a_parsear, with = F]\n\n    return(dt_par)\n}\n</code></pre> <p>2.1) Corran las funciones anteriores para cargarlas en memoria, luego \u00fasenlas para estandarizar y combinar las r\u00e9plicas del control y las drogas 1 y 2. Un ejemplo de correr esta funci\u00f3n para el caso de control ser\u00eda:</p> <pre><code>control_data &lt;- parsearDatos(dt_par = control_data,\n                             columnas_a_parsear = c(\"control1\", \"control2\", \"control3\"),\n                             nombre_columna_nueva = \"control\")\n</code></pre> <p>2.2) Ahora que ya tenemos los datos parseados, usen la funci\u00f3n <code>merge()</code> dos veces para combinar los 3 Data Tables en uno solo llamado full_data (si todo sali\u00f3 bien deber\u00eda tener 11.106 filas y 4 columnas).</p>","tags":["practicos"]},{"location":"practicos/TP08b_Data_Mining/#calcular-el-fold-change","title":"Calcular el Fold Change","text":"<p>3) Algo mencionamos antes, pero concluir que \"hay 10 CPM m\u00e1s al agregarle la droga\" no significa nada en el vac\u00edo. Si en el control era solo 1 CPM, entonces 10 m\u00e1s es mucho. Si en el control eran 10.000 CPM, 10 m\u00e1s es insignificante.</p> <p>Vamos entonces a calcular el fold change, es decir, cuantas veces m\u00e1s (o menos) de CPM fueron observados al agregarle la droga frente a cuando estaba solo el control. Esto lo calculamos como:</p> \\[ \\text{Fold Change} = \\frac{\\text{CPM Droga}}{\\text{CPM Control}} \\] <p>3.1) Antes de seguir leyendo \u00bfSe les ocurre alg\u00fan caso donde la f\u00f3rmula anterior nos de problemas?</p> Respuesta <p>B\u00e1sicamente hay 2 casos donde el c\u00e1lculo del Fold Change va a dar problemas:</p> <ul> <li>Cuando CPM Control = 0: La divisi\u00f3n no se puede hacer (y de hacerla en R va a dar infinito)</li> <li>Cuando CPM Control ~ 0: En este caso la divisi\u00f3n se hace, pero el Fold Change va a dar un n\u00famero muy grande (y probablemente varios \u00f3rdenes de magnitud m\u00e1s grande que el resto de los Fold Change calculados). Este Fold Change no se debe a que CPM Droga es realmente mayor, sino a que CPM Control es muy chico, por lo que no es realmente informativo.</li> </ul> <p>Estos dos problemas se pueden arreglar agregando un n\u00famero buffer, es decir, un n\u00famero peque\u00f1o que se adiciona al numerador y al denominador. En este caso vamos a usar 0,125 con lo que la f\u00f3rmula quedar\u00eda:</p> \\[ \\text{Fold Change} = \\frac{\\text{CPM Droga} + 0.125}{\\text{CPM Control} + 0.125} \\] <p>3.2) \u00bfQu\u00e9 pasa ahora en los dos casos problem\u00e1ticos que estamos tratando resolver? \u00bfC\u00f3mo afecta este buffer a los casos \"normales\"? (es decir, cuando tanto el numerador como el denominador son n\u00fameros mayores a 1)</p> <p>3.3) Usando la f\u00f3rmula con buffer, calculen el Fold Change para ambas drogas y gu\u00e1rdenlos en nuevas columnas de la tabla full_data (p\u00f3nganles nombres que representen la informaci\u00f3n que contienen).</p>","tags":["practicos"]},{"location":"practicos/TP08b_Data_Mining/#transformar-el-fold-change","title":"Transformar el Fold Change","text":"<p>Ahora bien, vamos a analizar como se distribuyen los valores del Fold Change para todas las prote\u00ednas (primera pesta\u00f1a del plot que est\u00e1 abajo). Podemos ver que si bien el Fold Change llega hasta 20 en algunos casos, la gran mayor\u00eda de ellas tienen Fold Changes menores a 4.</p> <p>En el paso siguiente vamos a querer agrupar nuestros genes por como se comportan frente a las drogas 1 y 2 clusterizando con <code>kmeans()</code> y luego plotearlo en un heatmap. En este momento la mayor\u00eda de los datos se encuentran en un peque\u00f1o rango del \"espectro\" de Fold Change, por lo que al momento de agrupar por similitud b\u00e1sicamente van a formar un \u00fanico gran cluster, lo que no da informaci\u00f3n.</p> <p>Por esta raz\u00f3n queremos convertir nuestros datos a una escala logar\u00edtmica. Como Fold Change solo llega hasta 20 vamos a usar una escala logar\u00edtmica en base 2. En R esto se hace usando la funci\u00f3n <code>log()</code>. Por defecto esta funci\u00f3n usa como base a \\(e\\), es decir, es el logaritmo natural. Sin embargo, se le puede cambiar la base a 2 pas\u00e1ndole el par\u00e1metro <code>base = 2</code> (ver la segunda pesta\u00f1a en el siguiente plot).</p> <p>4) Usando la funci\u00f3n <code>log()</code> con el par\u00e1metro necesario, calculen el logaritmo en base 2 de los Fold Change para ambas drogas y gu\u00e1rdenlos en nuevas columnas de la tabla full_data.</p> Fold Change para la Droga 1Log2(Fold Change) para la Droga 1 <p> </p> <p> </p>","tags":["practicos"]},{"location":"practicos/TP08b_Data_Mining/#plotear-el-heatmap","title":"Plotear el Heatmap","text":"<p>El heatmap es un tipo de plot que no vimos hasta el momento, pero que tal vez conozcan. La versi\u00f3n b\u00e1sica del heatmap nos permite graficar valores num\u00e9ricos como una escala de colores lo que nos permite ver diferencias entre filas r\u00e1pidamente e incluso encontrar filas similares o patrones.</p> <p>A continuaci\u00f3n mostramos un ejemplo que usa los datos estandarizados del Ejercicio 2 del TP 10a (la tabla ejemplo con los 4 genes, matriz_datos_ST):</p> <p></p> <p>No solo nos permite ver r\u00e1pidamente que hay 2 grupos de genes, sino que este paquete de heatmap tambi\u00e9n va a agrupar las filas por similitud y mostrar un dendrograma de similitud (todo esto se puede poner o sacar con par\u00e1metros).</p> <p>5) En nuestro caso tenemos miles de genes, por lo que es complicado usar un heatmap que los muestre a todos por separado. Vamos entonces a clusterizarlos por similitud usando <code>kmeans</code>, lo cual en este caso se puede hacer desde el mismo paquete que hace el heatmap. Al momento de definir clusters no sabemos cu\u00e1ntos son, por lo que vamos a elegir un n\u00famero relativamente grande, sabiendo que eso puede resultar en varios clusters que son muy similares.</p> <p>5.1) Instalen en R el paquete pheatmap.</p> <p>5.2) Corran el siguiente c\u00f3digo reemplazando log2_fold_change_drug1_wBuffer y log2_fold_change_drug2_wBuffer por el nombre de las columnas que contienen el logaritmo en base 2 de los Fold Change:</p> <pre><code>library(pheatmap)\n\n#Como *pheatmap* usa kmeans adentro inicializo la seed para que el plot de igual en todos lados siempre\nset.seed(1)\n\n#Me quedo solo con las columnas a plotear (en este caso el log 2 de los Fold Change para ambas drogas)\nplot_data &lt;- full_data[, .(log2_fold_change_drug1_wBuffer, log2_fold_change_drug2_wBuffer)]\n\n#Uso la funcion *pheatmap* para hacer un heatmap mas lindo\npheatmap(mat = plot_data, kmeans_k = 10, cluster_cols = F)\n</code></pre> <ul> <li><code>kmeans_k = 10</code> le est\u00e1 diciendo que agrupe los datos en 10 clusters, similar a correr <code>kmeans(plot_data, centers = 10)</code></li> <li><code>cluster_col = F</code> le est\u00e1 diciendo que no trate de agrupar las columnas por similitud y que no haga un dendrograma asociado</li> </ul> <p>5.3) Mirando los 10 clusters que acabamos de crear, para que clusters de genes se observa:</p> <ul> <li>Fold change alto para ambas drogas</li> <li>Fold change bajo para ambas drogas</li> <li>Fold change alto para la droga 1 y bajo la droga 2</li> <li>Fold change bajo para la droga 1 y alto la droga 2</li> </ul>","tags":["practicos"]},{"location":"practicos/TP08b_Data_Mining/#calcular-genes-mas-afectados","title":"Calcular genes m\u00e1s afectados","text":"<p>6) Si bien el heatmap nos da una idea global de como actuaron las drogas, nuestro objetivo es entender un poco m\u00e1s de su funcionamiento. Para esto, vamos a analizar la lista de genes que se vieron afectados por ellas.</p> <p>Para obtener esta lista es necesario entonces definir un umbral num\u00e9rico de Fold Change a partir del cual consideramos que el cambio fue \"significativo\" para nosotros. Estos umbrales se pueden elegir en base a conocimientos previos, en base a controles positivos y negativos, o mediante prueba y error (analizando qu\u00e9 y cu\u00e1ntos genes quedan por encima del umbral).</p> <p>Otra cosa a considerar es que en este caso estamos analizando drogas que funcionan como inhibidores, por lo que no nos interesa solo los genes con Fold Change alto, sino que incluso nos interesan m\u00e1s los genes con Fold Change bajo (que debido a como se calcul\u00f3 quiere decir cercanos a 0).</p> <p>En este caso vamos a quedarnos con aquellos genes que cumplan alguna de las siguientes condiciones:</p> <ul> <li>\\(log_2(FoldChange) \\geq 1.5\\) (es decir \\(FoldChange \\geq 2.83 = 2^{1.5}\\))</li> <li>\\(log_2(FoldChange) \\leq -1.5\\) (es decir \\(FoldChange \\leq \\frac{1}{2.83} = 2^{-1.5}\\))</li> </ul> <p>O sea, que nos vamos a quedar con aquellos genes que tienen un CPM 2.83 veces m\u00e1s grande o m\u00e1s chico que el control.</p> <p>6.1) Filtren full_data para quedarnos con aquellas filas donde el logaritmo en base 2 del Fold Change de la droga 1 sea mayor a 1.5 o menor a -1.5. Guarden la lista de los IDs de las prote\u00ednas que cumplen esa condici\u00f3n en una nueva variable. Hagan lo mismo para la droga 2.</p> <p>Tip - Calcular el valor absoluto</p> <p>La funci\u00f3n <code>abs()</code> nos devuelve el valor absoluto de un n\u00famero. Si bien es posible filtrar estos datos usando simplemente un OR, tambi\u00e9n lo pueden hacer usando <code>abs()</code>, lo que prefieran.</p> <p>6.2) Usen <code>write.table()</code> para generar un nuevo archivo llamado affected_genes_drug1 y guarden en \u00e9l los IDs reci\u00e9n calculados para la droga 1. Tengan en cuenta que queremos solo los IDs, por lo que tienen que cambiar los par\u00e1metros de la funci\u00f3n para que no haya nombres de las filas, nombres de las columnas ni comillas. Hagan lo mismo para la droga 2.</p>","tags":["practicos"]},{"location":"practicos/TP08b_Data_Mining/#buscar-nuestros-genes-en-bases-de-datos","title":"Buscar nuestros genes en bases de datos","text":"<p>7) Lo \u00faltimo que vamos a hacer con esta informaci\u00f3n es investigar en bases de datos para tratar de entender un poco m\u00e1s que procesos biol\u00f3gicos est\u00e1n siendo afectados por nuestras drogas. Como estamos trabajando con Trypanosoma cruzi vamos a ir a una p\u00e1gina que se especializa en tripanosom\u00e1tidos llamada TriTrypDB.</p> <p>7.1) Entren a este link y copien la lista de IDs que acabamos de crear para la droga 1. Hagan click en Get Answer.</p> <p>7.2) Una vez que se hayan cargados los datos vayan a Analyze Results Gene Onthology Enrichment, aseg\u00farense que este checkeado Biological Process y aprieten Submit (disclaimer: esta parte a veces no anda y hay que probar otro d\u00eda).</p> Tip - Ubicaci\u00f3n del bot\u00f3n Analyze Results <p> </p> <p>7.3) Esta tabla muestra procesos biol\u00f3gicos relacionados con nuestra lista de genes. A grandes rasgos, \u00bfqu\u00e9 procesos biol\u00f3gicos parecen estar afectados directa o indirectamente por la droga 1? Para responder esto pueden ordenar la tabla obtenida por la columna P-value en forma ascendente o pueden presionar el bot\u00f3n Show Word Cloud que se encuentra arriba de la tabla para ver un Word Cloud de los diferentes procesos biol\u00f3gicos.</p> <p>7.4) Hagan 7.1), 7.2) y 7.3) para la droga 2.</p> <p>7.5) \u00bfQue habr\u00eda que cambiar en lo que hicimos en el punto 6) si s\u00f3lo nos interesaran los procesos biol\u00f3gicos que son inhibidos por nuestras drogas?</p>","tags":["practicos"]},{"location":"practicos/TP08b_Data_Mining/#bibliografia","title":"Bibliograf\u00eda","text":"","tags":["practicos"]},{"location":"practicos/TP08b_Data_Mining/#consola-de-r","title":"Consola de R","text":"<ul> <li>Comando <code>help()</code></li> </ul>","tags":["practicos"]},{"location":"practicos/TP09_Short-Read-Mapping/","title":"Practico Nueve","text":"","tags":["practicos"]},{"location":"practicos/TP09_Short-Read-Mapping/#tp-9-short-read-mapping","title":"TP 9. Short Read Mapping","text":"<p> Materiales</p>","tags":["practicos"]},{"location":"practicos/TP09_Short-Read-Mapping/#slides-mostrados-en-la-clase","title":"Slides mostrados en la clase","text":"<ul> <li> Slides TP</li> </ul>","tags":["practicos"]},{"location":"practicos/TP09_Short-Read-Mapping/#objetivos","title":"Objetivos","text":"<ul> <li>Interpretar los formatos utilizados com\u00fanmente en NGS</li> <li>Mapear secuencias al genoma de referencia</li> <li>Visualizar e interpretar alteraciones gen\u00e9ticas</li> </ul>","tags":["practicos"]},{"location":"practicos/TP09_Short-Read-Mapping/#introduccion","title":"Introducci\u00f3n","text":"<p>La re-secuenciaci\u00f3n consiste en secuenciar un individuo perteneciente a una especie que ya se ha secuenciada anteriormente. Su objetivo es capturar informaci\u00f3n de polimorfismos de una base (SNPs), variaciones en el n\u00famero de copias (CNVs) e inserciones y deleciones (indels) en el individuo de inter\u00e9s.</p> <p>Siempre que exista un genoma de referencia, lo ideal es mapear en lugar de ensamblar, ya que el genoma de referencia contiene mucha informaci\u00f3n acumulada sobre el organismo de inter\u00e9s. Hay que tener en cuenta que al mapear se realizan m\u00faltiples asunciones, como por ejemplo, que el organismo de referencia y el analizado tienen la misma arquitectura gen\u00f3mica.</p>","tags":["practicos"]},{"location":"practicos/TP09_Short-Read-Mapping/#chlamydia-trachomatis","title":"Chlamydia trachomatis","text":"<p>Chlamydia trachomatis es uno de los pat\u00f3genos humanos de mayor prevalencia en el mundo, capaz de causar una variedad de cuadros cl\u00ednicos. Las cepas de transmisi\u00f3n sexual pueden ser subdivididas en aquellas restringidas al tracto intestinal y tipos m\u00e1s invasivos como el linfogranuloma venereo o LGV biovar. A pesar de las diferencias en la severidad de la enfermedad, hay pocas diferencias gen\u00e9ticas que distinguen a las diferentes cepas de C. trachomatis. Como veremos a continuaci\u00f3n, la mayor\u00eda de las variaciones ocurren al nivel de SNPs.</p> <p>En este trabajo pr\u00e1ctico, procederemos a mapear las lecturas producidas con Illumina de una nueva variante de Chlamydia trachomatis aislada del tracto genital y compararlas con la cepa de referencia Lb y otra cepa conocida L2b. Esta nueva cepa, llamada NV, caus\u00f3 un alerta sanitario en Europa en el a\u00f1o 2006 y comenz\u00f3 a diseminarse alrededor del mundo. La causa de su expansi\u00f3n es que evade la detecci\u00f3n por el test diagn\u00f3stico basado en una reacci\u00f3n de PCR. En el desarrollo de este trabajo pr\u00e1ctico podr\u00e1n identificar la raz\u00f3n por la cual esta cepa evadi\u00f3 el ensayo diagn\u00f3stico.</p>","tags":["practicos"]},{"location":"practicos/TP09_Short-Read-Mapping/#flujo-de-trabajo-de-secuenciacion-y-mapeo","title":"Flujo de trabajo de secuenciaci\u00f3n y mapeo","text":"<p>Laboratorio h\u00famedo: El ADN de la cepa NV de C. trachomatis es clivado en fragmentos con enzimas o sonicaci\u00f3n. Mediante Illumina se secuencian entre 75 y 100 bases de ambos extremos de cada fragmento, generando lecturas pareadas (en ingl\u00e9s \"paired-end reads\").</p> <p>In silico: Se obtienen archivos en formato <code>FASTQ</code> que contienen las secuencias de cada fragmento (llamadas lecturas o reads) y valores de calidad de secuenciaci\u00f3n por base. El formato <code>FASTQ</code> es similar al formato <code>FASTA</code> pero contiene una l\u00ednea con la calidad (Q) codificada en ASCII. Luego cada lectura es alineada y mapeada al genoma de referencia. En este paso se obtiene un archivo en formato <code>SAM</code>, el cual contiene la secuencia, la calidad y adem\u00e1s las coordenadas donde se ubica este fragmento respecto al genoma de referencia.</p> <p></p>","tags":["practicos"]},{"location":"practicos/TP09_Short-Read-Mapping/#ejercicio-1-inspeccion-de-los-datos-crudos","title":"Ejercicio 1: Inspecci\u00f3n de los datos crudos","text":"<p>Siempre que sea posible, es una buena pr\u00e1ctica visualizar los archivos de trabajo.  Para comenzar leeremos los archivos crudos de secuenciaci\u00f3n de Chlamydia trachomatis, los cuales tienen formato <code>FASTQ</code>.</p> <p>Abrir una terminal y dirigirse al directorio de descarga de los materiales del TP \"Short-Read-Mapping\".  Leer la primera l\u00ednea de un archivos fastq con el siguiente comando:</p> <pre><code>zcat NV_1.fastq.gz | head -4 \n</code></pre> <p>Formato FASTQ</p> <ul> <li> <p>1ra l\u00ednea: <code>IL7_1788:5:1:34:600/1</code> es el nombre de la lectura secuenciada y contiene la siguiente informaci\u00f3n</p> Elemento Descripci\u00f3n IL7_1788 ID del instrumento y n\u00famero de corrida 5 flowcell lane o carril 1 tile o casilla en la flowcell lane 34 coordenada 'x' 600 coordenada 'y' /1 sentido de la secuenciaci\u00f3n </li> </ul> <p></p> <ul> <li>2da l\u00ednea: La secuencia.</li> <li>3ra l\u00ednea: <code>+</code> Separador entre la secuencia y la calidad.</li> <li>4ta l\u00ednea: Calidad de la secuencia. Hay un caracter para cada nucle\u00f3tido. El caracter est\u00e1 asociado a un puntaje de calidad de cada nucle\u00f3tido, lo cual est\u00e1 codificado de la siguiente forma: cada caracter representa un n\u00famero (N\u00b0) seg\u00fan el c\u00f3digo decimal ASCII, y la calidad se define como este n\u00famero menos 33. \u00bfY c\u00f3mo se asocia esto a la probabilidad de error (p) de la base asignada?</li> </ul> \\[ Q = -10 \\log _{{10}} P \\] <p>o bien:</p> \\[ P=10^{{{\\frac  {-Q}{10}}}} \\] <p>Donde \\(Q\\) es la calidad:</p> <p><code>(N\u00b0 - 33) = calidad</code></p> <p>El n\u00famero que representa la calidad va de 33 (calidad m\u00e1s baja; <code>!</code> En ASCII) a 126 (calidad m\u00e1s alta; <code>~</code> en ASCII). Estos son los caracteres de valor de calidad en orden creciente de calidad de izquierda a derecha:</p> <pre><code> ! \"# $% &amp; '() * +, -. / 0123456789:; &lt;=&gt;? @ ABCDEFGHIJKLMNOPQRSTUVWXYZ [\\] ^ _` abcdefghijklmnopqrstuvwxyz {|} ~\n</code></pre> <ol> <li> <p>Identificar los componentes de la primer lectura: nombre, secuencia, calidad y ubicaci\u00f3n f\u00edsica de la lectura en la celda de flujo (es decir, lane, tile, x, y).</p> </li> <li> <p>Usando el c\u00f3digo ASCII, determinar la calidad de las primeras 3 bases secuenciadas.</p> </li> <li> <p>Leer la primera lectura del archivo <code>NV_2.fastq.gz</code>. \u00bfQu\u00e9 similitudes y diferencias encuentra en cada una de las l\u00edneas de texto? \u00bfA qu\u00e9 se deben? </p> </li> </ol>","tags":["practicos"]},{"location":"practicos/TP09_Short-Read-Mapping/#ejercicio-2-analisis-de-calidad-de-secuencias","title":"Ejercicio 2: An\u00e1lisis de calidad de secuencias","text":"<p>Dado que la secuenciaci\u00f3n de segunda generaci\u00f3n tiene una mayor tasa de error que la de primera generaci\u00f3n (Sanger), es importante revisar la calidad de nuestras lecturas. Explorar y entender las caracter\u00edsticas de los datos en crudo nos dar\u00e1 confianza en los experimentos ulteriores que llevemos adelante con las secuencias.</p>","tags":["practicos"]},{"location":"practicos/TP09_Short-Read-Mapping/#fastqc","title":"FastQC","text":"<p>Este programa analiza los datos crudos para realizar gr\u00e1ficas y tablas que muestren la calidad global de los datos. Permite identificar algunos problemas relacionados a distintos aspectos de los datos. </p> <p>El reporte de FastQC tiene este formato (puede variar entre versiones):</p> <p></p> <p>Algunos aspectos a evaluar en un reporte de calidad son:</p> <ul> <li>Calidad de secuencia por base: Es un indicador global que muestra la distribuci\u00f3n de calidad de base (Phred score, en el eje y) por posici\u00f3n en la lectura (eje x). Los Phred scores por encima de 30 suelen considerarse de buena calidad para una lectura de Illumina. En este caso, la lectura comienza con una alta calidad (zona verde), que decrece a medida que aumenta la longitud de la lectura (zonas amarilla, Phred &lt; 30 y rojo, Phred &lt; 20). Deber\u00eda mantenerse, en lineas generales, dentro de la zona verde; aunque no debemos preocuparnos si cae abruptamente para lecturas largas.</li> <li>Calidad de secuencia seg\u00fan posici\u00f3n en la flowcell: Este indicador permite detectar problemas en regiones f\u00edsicas especificas del secuenciador. Un problema frecuente es la formaci\u00f3n de burbujas. </li> <li>Contenido de base por secuencia: La frecuencia de cada nucle\u00f3tido en una lectura deber\u00eda ser m\u00e1s o menos constante, y visualizarse como lineas horizontales paralelas a lo largo de toda la lectura.</li> <li>Contenido de GC por secuencia: Esta gr\u00e1fica permite identificar contaminaciones. Un perfil de contenido de GC que no se ajusta a una distribuci\u00f3n normal podr\u00eda indicar presencia de contaminantes. La curva esperada est\u00e1 ajustada a la distribuci\u00f3n en humanos, si se trabaja con otro organismo podr\u00eda verse diferente, pero lo importante es ver un solo pico. </li> <li>Contenido de N por base: El caracter N indica que el proceso de secuenciaci\u00f3n fue inconcluyente a la hora de asignar un nucle\u00f3tido. Un exceso de \u00e9stos indica problemas.</li> <li>Niveles de duplicaci\u00f3n de secuencia: La aparici\u00f3n de duplicaciones excesivas puede sugerir artefactos durante la generaci\u00f3n de la librer\u00eda que usamos para secuenciar (o problemas en la PCR que usamos para amplificar nuestra muestra, si usamos alguna).</li> <li>Contenido de adaptadores: Aparici\u00f3n de adaptadores propios de la tecnolog\u00eda de secuenciaci\u00f3n (no pertenecen a nuestra secuencia de inter\u00e9s y deben ser removidos antes de mapear al genoma de referencia).</li> </ul>","tags":["practicos"]},{"location":"practicos/TP09_Short-Read-Mapping/#analisis-de-calidad-de-las-secuencias-de-c-trachomatis","title":"An\u00e1lisis de calidad de las secuencias de C. trachomatis","text":"<p>Para realizar el an\u00e1lisis de calidad de la secuenciaci\u00f3n con FastQC, ejecute el siguiente comandos:</p> <p></p><pre><code>fastqc NV_1.fastq.gz\nfastqc NV_2.fastq.gz\n</code></pre> Puede observar con el comando <code>ls</code>, que FastQC ha generado nuevos archivos en el directorio donde se encuentra.  A continuaci\u00f3n, visualice los resultados de cada archivo de secuenciaci\u00f3n por separado abriendo el html generado con un navegador: <pre><code>firefox NV_1_fastqc.html NV_2_fastqc.html\n</code></pre> <ol> <li>\u00bfQu\u00e9 opina de la calidad de los datos? \u00bfContinuar\u00eda trabajando con ellos? Compare con este ejemplo y justifique su decisi\u00f3n: Example of Conventional Base Calls</li> </ol>","tags":["practicos"]},{"location":"practicos/TP09_Short-Read-Mapping/#ejercicio-3-mapeo-de-secuencias-al-genoma-de-referencia-de-c-trachomatis","title":"Ejercicio 3: Mapeo de secuencias al genoma de referencia de C. trachomatis","text":"<p>El formato SAM (Sequence Alignment Map) es un formato estandarizado para guardar de secuencias de nucle\u00f3tidos alineadas (Para mas informaci\u00f3n ver SAM format). </p> <p>Otro formato similar es el BAM, el cual es el equivalente binario y comprimido de SAM, desarrollado para aumentar la velocidad y utilizarse en procesamientos intensivos de datos.</p> <p>Como crear el archivo SAM</p> <p>NO EJECUTAR EL C\u00d3DIGO A CONTINUACI\u00d3N! Es de muestra</p> <p>Por si no qued\u00f3 claro con todas las aclaraciones, ustedes NO deben ejecutar los comandos de esta etapa. Podr\u00e1n ver los resultados ya creados en su directorio de trabajo. Le brindamos los comandos en caso de querer reproducir el an\u00e1lisis en secuencias de su inter\u00e9s.</p> <p>El software para mapear las lecturas es BWA. Para instalarlo habr\u00eda que ejecutar:</p> <pre><code># NO ejecutar\nsudo apt install bwa\n</code></pre> <p>La secuencia de referencia para este ejercicio es la cepa LGV de Chlamydia trachomatis, denominada L2 y se encuentra en el archivo <code>L2_cat.fasta</code>. Este archivo contiene concatenado en formato fasta la secuencia del genoma y de un pl\u00e1smido.</p> <p>La mayor\u00eda de los programas que trabajan con genomas completos necesitan indexar la secuencia de referencia contra la que se alinear\u00e1n las lecturas antes de comenzar.  Para ello habr\u00eda que ejecutar:</p> <pre><code># NO ejecutar\nbwa index L2_cat.fasta \n</code></pre> <p>Realizado el indexado del genoma de referencia, podr\u00edamos mapear nuestras secuencias crudas empleando el algoritmo BWA-MEM:</p> <pre><code># NO ejecutar\nbwa mem L2_cat.fasta NV_1.fastq.gz NV_2.fastq.gz &gt; mapping.sam\n</code></pre> <p>A partir de aqui SI contin\u00fae ejecutando los comandos</p> <p>Revisen de qu\u00e9 se trata el <code>.sam</code> visualizando las primeras l\u00edneas del archivo por consola:</p> <pre><code>head mapping.sam\n</code></pre> <p>Las partes del archivo SAM son las siguientes:</p> <p></p>","tags":["practicos"]},{"location":"practicos/TP09_Short-Read-Mapping/#compresion-de-archivos-sam","title":"Compresi\u00f3n de archivos SAM","text":"<p>Primero vamos a convertir el alineamiento de formato SAM a formato BAM:</p> <pre><code>samtools view -b -S mapping.sam &gt; mapping.bam \n</code></pre> <p>Si el comando no es encontrado, cierre TODA terminal abierta y vuelva a probar. Si ah\u00ed no anda, avise</p> <ul> <li>Compare el tama\u00f1o de los archivos SAM y BAM y determine el factor de compresi\u00f3n. </li> </ul> \u00bfSe le ocurre qu\u00e9 comando puede utilizar para ver el tama\u00f1o de los archivos? <pre><code>ls -lh mapping*\n</code></pre> <p>Seguidamente ordene las lecturas mapeadas por cromosoma y/o coordenada con el siguiente comando:</p> <pre><code>samtools sort -o NV.bam mapping.bam \n</code></pre> <ul> <li>\u00bfPor qu\u00e9 las secuencias no est\u00e1n ordenadas y debemos hacerlo en un paso m\u00e1s?</li> </ul> <p>Finalmente indexaremos el archivo en formato BAM:</p> <pre><code>samtools index NV.bam\n</code></pre>","tags":["practicos"]},{"location":"practicos/TP09_Short-Read-Mapping/#ejercicio-4-visualizacion-de-secuencias-mapeadas","title":"Ejercicio 4: Visualizaci\u00f3n de secuencias mapeadas","text":"<p>JBrowser2 permite visualizar datos de secuenciaci\u00f3n de tecnolog\u00edas de nueva generaci\u00f3n como Illumina, 454 o Solid. JBrowser2 se puede descargar e instalar desde la p\u00e1gina oficial. Si est\u00e1n trabajando desde las computadoras del laboratorio, ya deber\u00edan tener instalado el programa.</p>","tags":["practicos"]},{"location":"practicos/TP09_Short-Read-Mapping/#vista-basica-de-jbrowse2","title":"Vista b\u00e1sica de JBrowse2","text":"<ul> <li>Abra JBrowse2 y cargue la secuencia de referencia \"L2_cat.fasta\". Para esto, hacer click en <code>'OPEN SEQUENCE FILE(S)'</code> y seleccione el archivo correspondiente. En <code>assembly name</code> elija un nombre que sea representativo del archivo cargado, y en <code>Type</code> FastaAdapter. </li> <li>Luego de seleccionar <code>submit</code> elija <code>Linear genome view</code> y luego presione <code>LAUNCH VIEW</code></li> <li>La siguiente ventana muestra que hay dos entradas en nuestro archivo multifasta, una que corresponde al ADN cromosomal y otra que corresponde al ADN plasm\u00eddico. Para visualizar las dos en simultaneo, seleccione <code>SHOW ALL REGIONS IN ASSEMBLY</code></li> </ul> <p>En este punto, su programa deber\u00eda verse de esta forma:</p> <p></p> <p>Componentes de la interfaz:</p> <ul> <li>Barra de herramientas (Men\u00faes desplegables): Puede acceder a diferentes opciones, como abrir archivos, agregar tracks, descargar plugins, etc.</li> <li>Tracks cargados (Entradas activas): Seleccionando <code>OPEN TRACK SELECTOR</code> puede ver los tracks disponibles y elegir cual visualizar. En nuestro caso, ver\u00e1 \"Reference sequence (l2_cat)\" o el nombre de referencia elegido.</li> <li>Panel de visualizaci\u00f3n principal: Muestra la secuencia de referencia, con las hebras positiva y negativa representadas por l\u00edneas. Puede observar los marcos de lectura, los codones stop (mostrados como l\u00edneas verticales o puntos), y las caracter\u00edsticas como genes o dominios que se representan mediante cajas coloreadas (dependiendo de los tracks que est\u00e9n cargados y seleccionados).</li> <li>Desplazarse y hacer zoom: El deslizador horizontal permite moverse a lo largo de la secuencia (observe que se ven las dos entradas, cromosoma y pl\u00e1smido). Haciendo zoom sobre la secuencia se pueden observar las bases de las dos hebras y los residuos en los seis marcos de lectura.</li> </ul> <p>Ahora vamos a cargar las anotaciones del genoma de L2_cat. Estas anotaciones estan en formato gff, y en dos archivos distintos, uno para el ADN cromosomal y otra para el ADN plasm\u00eddico.</p> <ul> <li> <p>Abra los archivos de anotaci\u00f3n denominados \"L2_genomic.gff\" y \"L2_plasmid.gff\". Para esto, desde el panel <code>Available tracks</code> hacer click en el s\u00edmbolo \"+\" &gt; <code>Add track</code> y seleccione el archivo correspondiente. Luego de apretar <code>Next</code>, en <code>Adapter type</code> seleccione <code>GFF3</code>, deje el resto de las opciones como est\u00e1n y presione <code>ADD</code></p> </li> <li> <p>Para visualizar el mapeo de lecturas que acabamos de hacer vamos a cargar en JBrowse2 nuestras lecturas mapeadas en formato BAM, de la siguiente manera: desde el panel <code>Available tracks</code> hacer click en el s\u00edmbolo \"+\" &gt; <code>Add track</code> y abra el archivo <code>NV.bam</code>. Luego de apretar <code>Next</code>, en <code>Adapter type</code> seleccione <code>BAM adapter</code>, deje el resto de las opciones como est\u00e1n y presione <code>ADD</code></p> </li> </ul> <p>Recuerden que estas lecturas son de la cepa sueca NV mapeadas contra el genoma de referencia de la cepa L2.</p> <p>Ahora deber\u00eda ver la ventana con las lecturas en la parte inferior de la pantalla principal. Su panel principal, donde est\u00e1 la secuencia y los tracks asociados, deber\u00eda verse de esta forma: (la secuencia se ve seg\u00fan el nivel de zoom)</p> <p></p> <p>Por defecto, la vista de las lecturas tiene dos secciones. La superior muestra la profundidad de cobertura de las lecturas en cada posici\u00f3n en el genoma, y tambi\u00e9n con lineas de colores cualquier las discrepancias entre el genoma le\u00eddo y el genoma de referencia. Abajo se muestran las lecturas apiladas, que tambien muestran las discrepancias de base con lineas de colores.</p> <p>Si quieren saber mas sobre una lectura, clickeen sobre la misma y ver\u00e1n a la derecha una ventana con los <code>Feature details</code>. Ah\u00ed podr\u00e1n ver detalles como posici\u00f3n, nombre y largo de la misma, secuencia, calidad de cada una de las bases, entre otras. Para ver como se conectan las lecturas entre s\u00ed, pueden probar la vista tipo arco, la encuentran en <code>Display types</code> &gt; <code>Arc display</code>, en el men\u00fa que se abre al seleccionar los tres puntos al lado del track correspondiente.</p>","tags":["practicos"]},{"location":"practicos/TP09_Short-Read-Mapping/#calidad-de-mapeo","title":"Calidad de Mapeo","text":"<p>La calidad de mapeo depende en la precisi\u00f3n de la lectura y el n\u00famero de \"mismatches\" respecto a la secuencia de referencia. Un valor de 0 indica que la lectura mapea igualmente bien con al menos otro lugar por lo que su mapeo no es confiable. El m\u00e1ximo valor posible de \"Mapping quality\" es 60.</p> <ul> <li>Bas\u00e1ndose en sus conocimientos de biolog\u00eda y de bioinform\u00e1tica \u00bfqu\u00e9 aspectos considera que podr\u00edan influir en la calidad de mapeo?</li> </ul> <p>A continuaci\u00f3n, vamos a filtrar las lecturas para visualizar solo aquellas que tienen una buena calidad de mapeo. Para realizar esto haga click en los tres puntos al lado de <code>NV.bam</code> en el panel de las lecturas, seleccionen <code>Pileup settings</code> y luego <code>Filter by</code>. Aparecer\u00e1 una ventana con muchas opciones para filtrar. En <code>Filter by tag name and value</code> pongan MQ como <code>Tag name</code> y 60 como <code>Tag value</code> (removiendo asi lecturas con calidad de mapeo menor a dicho n\u00famero). En este punto, la mayor\u00eda de lecturas deber\u00edan conservarse. Si no ven esto en su aplicaci\u00f3n, prueben poner mq (en min\u00fascula) como <code>Tag value</code>.</p> <p>Tip</p> <p>Filtrar lecturas con regiones repetitivas y ver \u00fanicamente lecturas correctamente apareadas puede ser muy \u00fatil para hacer el an\u00e1lisis del mapeo.</p> <p>Info</p> <p>JBrowser2 no permite (por el momento) definir un intervalo de valores. Si quieren tener lecturas que est\u00e9n entre dos valores de calidad, podr\u00edan filtrar por consola el archivo NV.bam.</p>","tags":["practicos"]},{"location":"practicos/TP09_Short-Read-Mapping/#visualizacion-de-las-lecturas-mapeadas","title":"Visualizaci\u00f3n de las lecturas mapeadas","text":"<p>JBrowse2 tiene varias modalidades de visualizaci\u00f3n de archivos BAM. Para explorarlas haga click sobre los tres puntos en el panel BAM y seleccionen el men\u00fa de opciones <code>Display types</code>: </p> <ul> <li>La visualizaci\u00f3n por defecto (la que est\u00e1n viendo) es 'Alignments display (combination)'. Como ya se mencion\u00f3 antes, combina la cobertura y las lecturas sobre la secuencia. La cobertura es la cantidad de lecturas secuenciadas para esa posici\u00f3n. Dado que esta tecnolog\u00eda puede tener errores, a mayor cobertura, mayor confianza en la detecci\u00f3n de variantes. </li> <li>La vista 'Pileup display' es una simplificaci\u00f3n de la visualizaci\u00f3n anterior, donde s\u00f3lo se muestran las lecturas. </li> <li>La vista 'SNPCoverage display', muestra la frecuencia de aparici\u00f3n de cada nucle\u00f3tido, y en caso de no coincidir con la referencia, lo colorea. Cuando una columna aparece completamente coloreada, en esa posici\u00f3n existe un SNP (no es un error de secuenciaci\u00f3n ya que todas las lecturas presentaron la misma variaci\u00f3n) </li> <li>La vista 'Arc display' muestra la relaci\u00f3n entre lecturas apareadas (paired-end reads) que est\u00e1n mapeadas en diferentes posiciones del genoma de referencia. Las lecturas paired-end que est\u00e1n mapeadas a diferentes posiciones del genoma se conectan mediante un arco. Esto es muy \u00fatil para visualizar de forma clara las lecturas que no est\u00e1n alineadas juntas o de forma esperada, lo que podr\u00eda indicar variaciones estructurales, problemas de ensamblado, etc.</li> <li>La vista 'Read cloud display' es similar a 'Arc display', pero utiliza etiquetas provenientes de algunos tipos de secuenciaci\u00f3n. Es especialmente \u00fatil para detectar variaciones estructurales y comprender c\u00f3mo las lecturas de un mismo fragmento de ADN se alinean en el genoma </li> </ul> <p>\u00bfPor qu\u00e9 podr\u00edan generarse lecturas duplicadas? \u00bfTodas las lecturas duplicadas ser\u00e1n \u00fatiles?</p> <p>Sacaremos provecho de la vistas en nuestro ejemplo biol\u00f3gico. Para ello primero creen una copia seleccionando <code>Copy track</code> en el panel bam. Luego, seleccionen la vista 'Read cloud display' en uno de los paneles bam y 'Pileup display' en el otro. </p> <p>Vamos a enfocarnos en el ADN plasm\u00eddico, por lo que posicionense en la secuencia 'AM886278.1' o seleccionen dicha secuencia desde el panel que se encuentra en el primer track (al lado del zoom). Comparen la cobertura del pl\u00e1smido con la regi\u00f3n gen\u00f3mica de NV</p> <p>Su pantalla de JBrowse2 deber\u00eda verse as\u00ed:</p> <p></p> <ul> <li> <p>\u00bfQu\u00e9 aspectos considera que pueden influir en la cobertura en general y en este caso en particular?</p> </li> <li> <p>A simple vista, \u00bfnotan alguna regi\u00f3n diferente?</p> </li> </ul> <p>A continuaci\u00f3n, copien y peguen lo siguiente en el selector de secuencias: <code>AM886278.1:5,000..6,000</code>. Eso va a mostrar en la pantalla las posiciones 5000 a 6000 de la secuencia AM886278.1 (el ADN plasm\u00eddico)</p> <p>Su pantalla de JBrowser2 deber\u00eda verse as\u00ed (en violeta el recuadro del selector de secuencias):</p> <p></p> <p>Observar\u00e1n que no hay lecturas que hayan sido alineadas sobre esa regi\u00f3n del genoma, y que adem\u00e1s las lecturas adyacentes a dicha regi\u00f3n est\u00e1n conectadas entre s\u00ed (esto tambi\u00e9n lo podr\u00edan visualizar con 'Arc display'). Esto es indicativo de una deleci\u00f3n en la cepa secuenciada comparada con la referencia.</p>","tags":["practicos"]},{"location":"practicos/TP09_Short-Read-Mapping/#visualizacion-de-multiples-archivos-bam","title":"Visualizaci\u00f3n de m\u00faltiples archivos BAM","text":"<p>Tambi\u00e9n pueden visualizar m\u00faltiples archivos BAM al mismo tiempo. Recuerden que los archivos BAM son un grupo procesado de lecturas alineadas de una bacteria (en este caso) contra una secuencia de referencia. Asi que en principio podriamos observar m\u00faltiples aislamientos bacterianos diferentes mapeados contra la misma referencia. La cepa de C. trachomatis que va a leer es la L2b. Es filogen\u00e9ticamente m\u00e1s cercana a la cepa de referencia que la que hemos analizado hasta el momento, por eso el nombre similar.</p> <p>No har\u00e1n nuevamente el mapeo para esta cepa, ya hemos procesado los datos crudos en fastq por ustedes. El archivo que necesitan se denomina \"L2b.bam\". Para abrirlo, vayan al <code>Track selector</code>, presionen el s\u00edmbolo + y carguen el archivo correspondiente. Recuerden que el tipo es <code>Bam adapter</code>, y dejen el resto de las opciones como vienen predeterminadas.</p> <p>Veamos  la regi\u00f3n no mapeada que analizamos previamente (entre las bases 5000 a 6000). Comparen los distintos tipos de visualizaci\u00f3n entre ambas secuenciaciones.</p> <ul> <li>Vuelva a leer en la Introducci\u00f3n la raz\u00f3n por la cu\u00e1l la cepa NV caus\u00f3 un alerta sanitario en Europa en el a\u00f1o 2006. Considerando lo que acabamos de ver, \u00bfpor qu\u00e9 raz\u00f3n cree que la cepa NV no es detectada en el ensayo diagn\u00f3stico est\u00e1ndar pero s\u00ed lo es la cepa L2b?</li> </ul> <p></p>","tags":["practicos"]},{"location":"practicos/TP09_Short-Read-Mapping/#ejercicio-5-deteccion-de-variantes-snp-e-indel","title":"Ejercicio 5: Detecci\u00f3n de variantes (SNP e InDel)","text":"<p>Para comenzar, regresen a la visualizaci\u00f3n de lecturas apiladas (Pileup display)).</p> <p>Observen las distintas l\u00edneas de colores que aparecen en algunas lecturas. Esas l\u00edneas representan los SNPs con respecto a la referencia y el color corresponde a la base presente en la lectura (C = celeste, G = naranja, T = rojo, A = verde y N = gris). Observar\u00e1n que algunos SNPs est\u00e1n presentes en todas las lecturas, formando l\u00edneas verticales de color, mientras que otros SNPs se encuentran distribuidos m\u00e1s espor\u00e1dicamente. Los primeros tienen mayor probabilidad de ser verdaderos SNPs mientras que los \u00faltimos probablemente sean errores de secuenciaci\u00f3n. </p> <p></p> <p>Si acerca la visualizaci\u00f3n de las lecturas apiladas al m\u00e1ximo podr\u00e1n observar (1) las secuencias individuales de cada lectura y (2) las bases que difieren de la referencia estar\u00e1n en el color correspondiente.</p> <p></p> <p>Info</p> <p>Muchos SNPs son bastante claros, sin embargo, esto no es siempre el caso. \u00bfQu\u00e9 sucede si la profundidad de lecturas es muy baja? Si solo hay dos lecturas mapeando en un sector, la referencia es T y ambas lecturas son C, \u00bfEs evidencia suficiente para decir que hay un SNP? \u00bfQue pasa si hay muchas lecturas mapeando una regi\u00f3n y, por ejemplo, de 100, 50 tienen G y las otras 50 tienen T en una posici\u00f3n en particular. \u00bfEs un SNP? Tambi\u00e9n podria ser una coinfecci\u00f3n o una variaci\u00f3n en un genoma diploide...</p>","tags":["practicos"]},{"location":"practicos/TP09_Short-Read-Mapping/#calculando-con-mas-precision-los-snps","title":"Calculando con m\u00e1s precisi\u00f3n los SNPs","text":"<p>Hasta el momento hemos visto la variaci\u00f3n como un simple y homog\u00e9neo grupo de SNPs. En realidad se necesitar\u00eda m\u00e1s informaci\u00f3n para entender el efecto que el cambio en la secuencia puede ocasionar en, por ejemplo, la capacidad codificante. Para esto podemos visualizar un tipo de formato denominado \"variant call format\" (VCF), el cual tiene su forma comprimida denominada \"binary variant call format\" (BCF).</p> <p>El formato VCF fue desarrollado para representar datos de variaci\u00f3n de 1000 proyectos genoma humanos y ya es bastante aceptado por la comunidad como el formato est\u00e1ndar para SNP calling. </p> <p>Nosotros vamos a generar el archivo en formato VCF a partir de nuestro archivo <code>'NV.bam'</code> y visualizarlo en JBrowse2.</p> <p>Para crear un archivo VCF necesita ir a la terminal y escribir los siguientes comandos:</p> <pre><code>bcftools mpileup -Ou -f L2_cat.fasta NV.bam | bcftools call -v -c --ploidy 1 -O v &gt; NV.bcf\nbgzip NV.vcf\ntabix NV.vcf.gz\n</code></pre> <p>Visualicen el resultado del variant calling usando head:</p> <pre><code>zcat NV.vcf.gz | head\n</code></pre> <p>Ahora leeremos en JBrowser2 el archivo VCF que recien crearon. Para esto vayan al <code>Track selector</code>, presionen el s\u00edmbolo + y carguen el archivo <code>\"NV.vcf.gz\"</code>. Presionen <code>Next</code> y verifiquen que en <code>Adapter type</code> diga VCF tabix adapter.</p> <p>Para ver una regi\u00f3n con algo de variaci\u00f3n gen\u00e9tica interesante vayan al gen CTL0578. Este gen pertenece al ADN cromosomal, y est\u00e1 en las posiciones 684021 a 685991</p> <p></p> <ul> <li>\u00bfQu\u00e9 tipos de variantes pueden identificar en el gen CTL0578?</li> </ul>","tags":["practicos"]},{"location":"practicos/TP09_Short-Read-Mapping/#ejercicio-adicional-comparando-cepas","title":"Ejercicio adicional: comparando cepas","text":"<p>En el directorio de trabajo tiene el archivo BAM de la cepa L2b. Con los comandos vistos, calcule las variantes de esta cepa respecto al genoma de referencia de L2. </p> <p>Una vez generado el VCF, agreguelo a la vista de la misma manera que para la cepa NV. Compare ambas cepas en el visualizador.</p> <ul> <li>\u00bfQu\u00e9 cepa tiene mayor cantidad de variantes? \u00bfPor qu\u00e9?</li> </ul>","tags":["practicos"]},{"location":"practicos/TP10_Desorden/","title":"Practico Diez","text":"","tags":["practicos"]},{"location":"practicos/TP10_Desorden/#tp-10-prediccion-de-desorden","title":"TP 10. Predicci\u00f3n de Desorden","text":"","tags":["practicos"]},{"location":"practicos/TP10_Desorden/#slides-mostrados-en-la-clase","title":"Slides mostrados en la clase","text":"<ul> <li> Slides</li> </ul> <p> Materiales</p>","tags":["practicos"]},{"location":"practicos/TP10_Desorden/#parte-i-prediccion-de-desorden","title":"PARTE I: Predicci\u00f3n de Desorden","text":"","tags":["practicos"]},{"location":"practicos/TP10_Desorden/#recursos-online","title":"Recursos online","text":"<ul> <li>ProViz                http://slim.icr.ac.uk/proviz/</li> <li>IUPred2A            https://iupred2a.elte.hu/plot</li> <li>DisProt            https://www.disprot.org</li> </ul>","tags":["practicos"]},{"location":"practicos/TP10_Desorden/#objetivos","title":"Objetivos","text":"<ul> <li>Interpretar alineamientos m\u00faltiples de secuencias</li> <li>Identificar regiones ordenadas y desordenadas en alineamientos m\u00faltiples de secuencia</li> <li>Familiarizarse con la base de datos DisProt</li> <li>Entender las t\u00e9cnicas experimentales que permiten la identificaci\u00f3n de regiones desordenadas</li> <li>Familiarizarse con distintos m\u00e9todos de predicci\u00f3n de desorden (s\u00f3lo en ejercicios adicionales)</li> <li>Interpretaci\u00f3n de los resultados de los distintos m\u00e9todos de predicci\u00f3n de desorden (s\u00f3lo en ejercicios adicionales)</li> </ul>","tags":["practicos"]},{"location":"practicos/TP10_Desorden/#metodos-de-prediccion-de-desorden","title":"M\u00e9todos de predicci\u00f3n de desorden","text":"<p>Uno de los mayores desaf\u00edos en el campo de las prote\u00ednas es la predicci\u00f3n de la estructura tridimensional a partir de la estructura primaria incluyendo aquellas prote\u00ednas que son total o parcialmente desordenadas. Mientras que las prote\u00ednas globulares adquieren una \u00fanica estructura nativa, las prote\u00ednas intr\u00ednsecamente desordenadas (IDPs, del ingl\u00e9s intrinsically disordered proteins) son un conjunto de estructuras tridimensionales. Tambi\u00e9n pueden existir regiones desordenadas conectando dos dominios globulares, como los loops; o incluso regiones m\u00e1s largas, que abarcan m\u00e1s de 30 residuos de longitud, que reciben el nombre de IDRs (del ingl\u00e9s intrinsically disordered regions).</p> <p>En el a\u00f1o 2020, AlphaFold2 gana la competici\u00f3n de predicci\u00f3n de estructuras (CASP14) con un amplio margen prediciendo estructuras con muy alta precisi\u00f3n. Sin embargo, a\u00fan la predicci\u00f3n de un conjunto de estructuras para prote\u00ednas desordenadas no se ha resuelto.</p> <p>La predicci\u00f3n de IDRs/IDPs a partir de la secuencia de amino\u00e1cidos permite un an\u00e1lisis r\u00e1pido y abarcativo de distintas prote\u00ednas permitiendo establecer hip\u00f3tesis sobre la presencia de desorden en las prote\u00ednas (Dunker et al., 2008; van der Lee et al., 2014). La importancia que adquirieron las IDRs/IDPs en los \u00faltimos a\u00f1os llev\u00f3 al desarrollo de numerosos m\u00e9todos de predicci\u00f3n, pero en general se basan en tres estrategias de predicci\u00f3n de desorden: </p> <ol> <li>a partir de composici\u00f3n de secuencia, </li> <li>a partir de machine learning sobre estructuras determinadas por cristalograf\u00eda de rayos X y </li> <li>a partir de meta-predictores que integran los resultados predichos por diferentes m\u00e9todos.</li> </ol> <p>Entre los algoritmos que se basan en composici\u00f3n de secuencia podemos nombrar IUPred (Doszt\u00e1nyi et al., 2005; Erd\u00f6s et al., 2021), que aplica un campo de energ\u0131\u0301a desarrollado a partir de un gran n\u00famero de prote\u00ednas con estructura determinada obtenidas de PDB. El primer algoritmo en machine learning fue PONDR (Obradovic et al., 2003; Romero et al., 1997), entrenado a partir de un grupo estructuras de prote\u00ednas globulares y atributos de secuencia asociados a residuos no resueltos en dichas estructuras, que corresponden a regiones flexibles dentro del cristal. GlobPlot (Linding et al., 2003) fue entrenado estudiando la tendencia de un residuo a adquirir determinada estructura secundaria, h\u00e9lices \u03b1 o l\u00e1minas \u03b2.</p>","tags":["practicos"]},{"location":"practicos/TP10_Desorden/#ejercicios","title":"Ejercicios","text":"","tags":["practicos"]},{"location":"practicos/TP10_Desorden/#ejercicio-1-visualizacion-de-alineamientos-en-proviz","title":"Ejercicio 1. Visualizaci\u00f3n de Alineamientos en ProViz","text":"<p>Antes de empezar, piensen ...</p> <p>\u00bfPorqu\u00e9 es importante visualizar un MSA?</p> <p>\u00bfQu\u00e9 informaci\u00f3n podemos obtener de los MSA?</p> <p>ProViz es una herramienta que permite visualizar alineamientos y estructura de dominios de una prote\u00edna online. Ingresa a la web de ProViz http://slim.icr.ac.uk/proviz/, y busca la prote\u00edna p53 ingresando su Accession Number en la ventana \u201csearch\u201d (Accession Number: P04637):</p> <p>Selecciona la prote\u00edna que se llama: Cellular tumor antigen p53 (TP53) Homo sapiens (Human). Es la primera de la lista.</p> <p>IMPORTANTE</p> <p>Para responder las preguntas debajo, aseg\u00farate de que en el panel superior de la p\u00e1gina, en alignments, est\u00e9 seleccionada la opci\u00f3n QFO. (Puedes investigar qu\u00e9 pasa si cambian a otras opciones, como mammalian o vertebrates).</p> <p>En Options a la izquierda haz click en Show/hide gaps. Aparecen m\u00e1s posiciones con gaps en el alineamiento que antes estaban ocultas.</p> <p>1.1. \u00bfQu\u00e9 regiones parecen estar mejor alineadas (indicar aproximadamente de qu\u00e9 posici\u00f3n a qu\u00e9 posici\u00f3n de la primera secuencia)?</p> <p>1.2. \u00bfExiste diferencia en la composici\u00f3n de secuencia entre las regiones mejor alineadas y las no tan bien alineadas?</p> <p>1.3. \u00bfSe observan diferencias en el grado de conservaci\u00f3n de estas regiones?</p> <p>1.4. \u00bfA qu\u00e9 pueden deberse las diferencias observadas?</p>","tags":["practicos"]},{"location":"practicos/TP10_Desorden/#ejercicio-2-prediccion-de-desorden-a-partir-de-la-secuencia","title":"Ejercicio 2. Predicci\u00f3n de desorden a partir de la secuencia","text":"<p>Ingresa en la web de IUPred2A https://iupred2a.elte.hu e ingresa la prote\u00edna p53 (puede ingresarse la secuencia de amino\u00e1cidos, el Uniprot ID - P53_HUMAN o el accession number - P04637). </p> <p>Score IUPred</p> <p>El algoritmo IUPred brinda una puntuaci\u00f3n. En general se considera que un residuo es:</p> <ul> <li>Desordenado cuando el valor de IUPred es mayor o igual a 0.5</li> <li>Ordenado cuando es menor a 0.5</li> </ul> <p>Nota: Esta es una convenci\u00f3n. El umbral lo puede decir el usuario a su propia conveniencia.</p> <p>2.1. Anota las posiciones iniciales y finales de las regiones predichas como desordenadas.</p> <ul> <li>\u00bfSe correlacionan las regiones predichas como ordenadas o desordenadas con las diferencias observadas en el ejercicio anterior?</li> </ul> <p>2.2. Imaginemos que queremos correr la predicci\u00f3n de desorden para cientos de prote\u00ednas, o que queremos contar el porcentaje de amino\u00e1cidos que se encuentran en regiones desordenadas:</p> <ul> <li>\u00bfLe parece que el visualizador online ser\u00eda una herramienta \u00fatil para hacerlo?</li> </ul> <p>\u00a1Claro que no! Por suerte, el algoritmo IUPred puede tambi\u00e9n correrse de manera local y adem\u00e1s es r\u00e1pido. Para hacer esto, primero descarguen IUPred desde este link. </p> <p>Abre una terminal, descomprime el archivo <code>iupred2a.tar.gz</code> y ve al directorio d\u00f3nde est\u00e1 IUPred</p> <p></p><pre><code>cd ~/Tools/IUPred/\n\n# Primero corremos IUPred sin ninguna opci\u00f3n para ver c\u00f3mo es su uso:\n./iupred2a.py\n</code></pre> Deber\u00eda aparecer lo siguiente: <pre><code>Usage: ./iupred2a.py (options) (seqfile) (iupred type)\n   Available types: \"long\", \"short\", \"glob\"\n\nOptions\n   -d str   -   Location of data directory (default='./')\n   -a       -   Enable ANCHOR2 prediction\n</code></pre> <p>El archivo con la secuencia de p53 (<code>P53_HUMAN.seq</code>) est\u00e1 guardado en el mismo directorio que IUPred. En base a esto, el comando a utilizar es el siguiente</p> <pre><code>./iupred2a.py -a P53_HUMAN.seq long &gt; P53_HUMAN_long.iupred\n</code></pre> <p>2.3. Explora el archivo generado (<code>P53_HUMAN_long.iupred</code>) y responde.</p> <ul> <li>\u00bfC\u00f3mo es el formato de los datos?</li> <li>\u00bfLas columnas tienen nombre? \u00bfSer\u00e1n interpretadas correctamente por R?</li> </ul> <p>2.4. Crea un script en R.</p> <p>Para esto, abre RStudio y elije:</p> <p>New \u2192 RScript</p> <p>Recuerda ver en qu\u00e9 directorio est\u00e1s trabajando y configurarlo para trabajar en el directorio deseado, por si no lo recuerdas las funciones eran:</p> <ul> <li><code>getwd()</code>: Devuelve el directorio de trabajo</li> <li><code>setwd()</code>: Configura el directorio de trabajo</li> </ul> <p>2.4a. \u00a1A cargar los datos!</p> <p>\u00bfTe acord\u00e1s c\u00f3mo se hac\u00eda?</p> <p>Se utilizaba la funci\u00f3n <code>fread()</code>. Vamos a modificar algunos argumentos para que lea correctamente el archivo. Si quer\u00e9s saber qu\u00e9 es cada argumento siempre se puede revisar el uso de las funciones con <code>help(fread)</code></p> <p></p><pre><code>library(data.table)\n\nfileIN &lt;- \"~/Tools/IUPred/P53_HUMAN_long.iupred\"\n\nheader &lt;-c(\"Posicion\",\"Aminoacido\",\"Iupred\",\"Anchor\")\n\np53 &lt;- fread(file=fileIN, header=T ,sep=\"\\t\", col.names=header, skip=\"POS\")\n</code></pre> Asegurate que los datos se cargaron correctamente, esperamos una tabla con 4 columnas. <p>2.4b. Ahora quisi\u00e9ramos clasificar las posiciones en pase a la predicci\u00f3n realizada por IUPred como Orden y Desorden.</p> <p>\u00bfSe te ocurre c\u00f3mo hacerlo?</p> <p>Primero crearemos una columna en el data.table:</p> <pre><code>umbral &lt;- 0.5\np53$Prediccion &lt;- \"\"\np53[Iupred&gt;=umbral]$Prediccion &lt;- \"Desorden\"\np53[Iupred&lt;umbral]$Prediccion &lt;- \"Orden\"\n</code></pre> <p>Para obtener un gr\u00e1fico similar al que brinda el servidor de IUPred, utilizaremos la librer\u00eda <code>ggplot2</code>:</p> <pre><code>library(ggplot2)\n\nplot_p53 &lt;- ggplot(p53,aes(x=Posicion,y=Iupred)) +\n  scale_x_continuous(n.breaks = 20,expand = c(0.01,0.01)) +\n  scale_y_continuous(n.breaks = 10,limits = c(0,1),expand = c(0,0.01)) +\n  geom_line(color=\"navyblue\") +\n  geom_point(aes(color=Prediccion)) +\n  geom_hline(yintercept = 0.5,lty=\"dotted\",size=1) +\n  theme_linedraw()\n\nplot_p53\n</code></pre> <p>Deber\u00eda obtener un gr\u00e1fico como el siguiente:</p> <p></p> <p>Ahora, quisi\u00e9ramos evaluar el porcentaje de residuos predichos ordenados y desordenados. Por suerte, R tiene una funci\u00f3n que \u201ccuenta\u201d por nosotros:</p> <pre><code>cuentaTotal &lt;- table(p53$Prediccion)\nporcentaje &lt;- 100*cuentaTotal/length(p53$Posicion)\n\nprint(cuentaTotal)\nprint(porcentaje)\n</code></pre> <p>2.4c. En base a los valores obtenidos, \u00bfdir\u00eda que la prote\u00edna p53 es altamente desordenada?</p> <p>2.4d. Ahora analizaremos la composici\u00f3n de amino\u00e1cidos de p53.</p> <p>Pero antes:</p> <p>Seg\u00fan lo que vieron en la te\u00f3rica:</p> <ul> <li>\u00bfQu\u00e9 residuos espera ver enriquecidos en las regiones desordenadas y cuales en las ordenadas? \u00bfPor qu\u00e9?</li> </ul> <p>Vamos a graficar el porcentaje de cada amino\u00e1cido predicho como ordenado o desordenado en la secuencia de p53</p> <pre><code>aminoacidos &lt;- table(p53$Aminoacido,p53$Prediccion)\nprint(aminoacidos)\n</code></pre> <ul> <li>\u00bfQu\u00e9 hizo la funci\u00f3n <code>table</code> en este caso?</li> </ul> <p>Para calcular el porcentaje de amino\u00e1cidos:</p> <pre><code>aminoacidos_porcentaje &lt;- 100*aminoacidos/length(p53$Posicion)\n</code></pre> <p>Ahora vamos a convertir la tabla en un data.table para graficar con <code>ggplot2</code>:</p> <p></p><pre><code>aminoacidos_df&lt;-as.data.table(aminoacidos_porcentaje)\ncolnames(aminoacidos_df) &lt;- c(\"Aminoacidos\",\"Prediccion\",\"Porcentaje\")\n\nplot_aa &lt;- ggplot(aminoacidos_df,aes(x=Aminoacidos,y=Porcentaje,fill=Prediccion)) +\n      geom_col(position = \"dodge\") +\n      scale_y_continuous(n.breaks = 10,limits = c(0,10),expand = c(0,0.01)) +\n      theme_bw()\n\nggsave(filename=\"aminoacidos.png\",plot=plot_aa,device=\"png\",dpi=150,width=10,height=5,units=\"cm\")\n</code></pre> Deber\u00edas obtener un gr\u00e1fico como el siguiente: <p></p> <ul> <li>\u00bfQu\u00e9 amino\u00e1cidos son los m\u00e1s abundantes en las regiones desordenadas? \u00bfLa abundancia de los amino\u00e1cidos coincide con lo esperado?</li> </ul> <p>2.5. Por \u00faltimo, vuelva a correr IUPred pero con la opci\u00f3n <code>short</code> en lugar de <code>long</code>.</p> <pre><code>./iupred2a.py -a P53_HUMAN.seq short &gt; P53_HUMAN_short.iupred\n</code></pre> <p>Utilizando el script de R creado anterior grafique el score de IUPred por posici\u00f3n, y responda:</p> <ul> <li>\u00bfSe mantiene la predicci\u00f3n de regiones ordenadas y desordenadas?</li> <li>\u00bfCu\u00e1les son las diferencias principales con el gr\u00e1fico de IUPred long para p53?</li> </ul>","tags":["practicos"]},{"location":"practicos/TP10_Desorden/#parte-ii-base-de-datos-disprot","title":"PARTE II: Base de Datos Disprot","text":"<p>La base de datos DisProt es una colecci\u00f3n de evidencia de desorden experimental recolectada de la literatura y curada manualmente. La evidencia corresponde a una regi\u00f3n proteica, e incluye por lo menos:</p> <ul> <li>un experimento,</li> <li>el art\u00edculo cient\u00edfico correspondiente a ese experimento,</li> <li>el inicio y final de la regi\u00f3n desordenada en la secuencia proteica</li> <li>un t\u00e9rmino de anotaci\u00f3n que corresponde a la Ontolog\u00eda de desorden.</li> </ul> <p>Cada una de las entradas en la base de datos posee un identificador \u00fanico</p> <p>La ontolog\u00eda de desorden est\u00e1 organizada en tres categor\u00edas diferentes:</p> <ul> <li>Estado estructural (Structural State): Orden o Desorden (Order or Disorder)</li> <li>Transici\u00f3n estructural (Structural Transition): Transiciones que pueden ocurrir entre diferentes estados estructurales (Disorder to order)</li> <li>Funci\u00f3n de desorden (Disorder Function): La funci\u00f3n de una regi\u00f3n incluyendo t\u00e9rminos espec\u00edficos a desorden.</li> </ul> <p>En Disprot tambi\u00e9n se incluye la funci\u00f3n molecular Molecular function de cada regi\u00f3n. </p>","tags":["practicos"]},{"location":"practicos/TP10_Desorden/#ejercicio-1-base-de-datos-disprot","title":"Ejercicio 1. Base de datos DisProt","text":"<p>La prote\u00edna p53 es una prote\u00edna supresora de tumores, es decir que su mutaci\u00f3n favorece el crecimiento tumoral. p53 es uno de los genes m\u00e1s mutados en el c\u00e1ncer humano, y act\u00faa como un factor de transcripci\u00f3n que se expresa en todos los tejidos. Cumple un rol principal en el ciclo celular y es el regulador principal de la apoptosis. Es esencial para inducir la respuesta celular ante el da\u00f1o al ADN, deteniendo el ciclo celular cuando las c\u00e9lulas no pueden reparar el ADN da\u00f1ado por agentes genot\u00f3xicos. Si falla p53 podr\u00edan facilitar la formaci\u00f3n de tumores celulares y en consecuencia producir c\u00e1ncer. Alrededor de un 50% de los tumores humanos identificados poseen mutaciones en la prote\u00edna p53. Esta prote\u00edna, por su importancia para la salud humana, es una de las prote\u00ednas m\u00e1s estudiadas en cuanto a su estructura y funci\u00f3n.</p> <p>Ingresa a la p\u00e1gina web de DisProt y encuentra la prote\u00edna p53 (P04637). La b\u00fasqueda puede realizarse utilizando el Accession Number o por palabras claves. El identificador de DisProt que deber\u00edan encontrar es DP00086. Una vez encontrado haz click en el identificador de Disprot.</p> <p>1.a. Si Disprot consensus est\u00e1 colapsado, expandelo:</p> <ul> <li>\u00bfQu\u00e9 tipo de informaci\u00f3n observa en la p\u00e1gina?</li> </ul> <p>1.b. Expande Structural state y luego expande Disorder:</p> <ul> <li>\u00bfA qu\u00e9 corresponden los segmentos coloreados?</li> <li>\u00bfQu\u00e9 tipo de evidencia poseen dichos fragmentos?</li> </ul> <p>1.c. Pensando en el rol de las regiones desordenadas.</p> <p>1.c.i. Expande Molecular Function:</p> <ul> <li>\u00bfQu\u00e9 tipo de funciones est\u00e1n indicadas para cada regi\u00f3n?</li> <li>\u00bfQu\u00e9 t\u00e9cnicas se usaron para identificarlas?</li> </ul> <p>1.c.ii. Expande Disorder Function:</p> <ul> <li>\u00bfQu\u00e9 tipo de funciones est\u00e1n indicadas?</li> <li>\u00bfCu\u00e1ntos experimentos y que tipo de t\u00e9cnicas se realizaron para identificar cada una?   </li> </ul> <p>1.d. Observa la l\u00ednea que corresponde a InterPro.</p> <p>Interpro</p> <p>Es un consorcio de bases de datos de prote\u00ednas que provee un an\u00e1lisis funcional de prote\u00ednas clasific\u00e1ndolas en familias y prediciendo dominios y sitios importantes. </p> <p>Entre todas las bases de datos incluye a Pfam.</p> <p>La base de datos Pfam es una colecci\u00f3n de familias de dominios de prote\u00ednas construida en base a alineamientos m\u00faltiples de secuencia y modelos ocultos de markov (HMMs). Las prote\u00ednas est\u00e1n compuestas por una o m\u00e1s regiones funcionales o dominios, que combinados de distintas maneras crean la diversidad proteica que se encuentra en las prote\u00ednas naturales.</p> <p>En base a esto, responda:</p> <ul> <li> <p>\u00bfPor qu\u00e9 es necesario identificar dominios en las prote\u00ednas?</p> </li> <li> <p>\u00bfPfam identifica dominios globulares?</p> </li> </ul> <ul> <li> <p>\u00bfCu\u00e1ntos dominios predichos muestra InterPro?</p> </li> <li> <p>\u00bfEst\u00e1 de acuerdo seg\u00fan lo observado con esa predicci\u00f3n?</p> </li> <li> <p>\u00bfCu\u00e1ntos de estos dominios NO adquiere una estructura globular?</p> </li> </ul> <p>1.e. \u00bfLa evidencia experimental recolectada coincide con las predicciones realizadas en el Ejercicio 1 y en el Ejercicio 2 de la Parte I?</p>","tags":["practicos"]},{"location":"practicos/TP10_Desorden/#parte-iii-analisis-de-alineamientos-multiples-de-secuencia-de-proteinas-visualizando-alineamientos-con-jalview","title":"PARTE III: An\u00e1lisis de alineamientos m\u00faltiples de secuencia de prote\u00ednas - Visualizando alineamientos con JalView","text":"","tags":["practicos"]},{"location":"practicos/TP10_Desorden/#software","title":"Software","text":"<ul> <li>JalView:                https://www.jalview.org/</li> </ul>","tags":["practicos"]},{"location":"practicos/TP10_Desorden/#objetivos_1","title":"Objetivos","text":"<ul> <li>Aprender a utilizar Jalview para visualizar un MSA y familiarizarse con el manejo de programas de visualizaci\u00f3n de alineamientos.</li> <li>Interpretar alineamientos m\u00faltiples de secuencias. Identificar regiones de secuencia conservadas y asociarlas a diferentes elementos funcionales de las prote\u00ednas. </li> <li>Visualizar y analizar los patrones de sustituci\u00f3n aminoac\u00eddica encontrados en prote\u00ednas modulares. Correlacionar con sus conocimientos sobre matrices de sustituci\u00f3n </li> </ul>","tags":["practicos"]},{"location":"practicos/TP10_Desorden/#ejercicios_1","title":"Ejercicios","text":"","tags":["practicos"]},{"location":"practicos/TP10_Desorden/#jalview-software-de-visualizacion-de-alineamientos","title":"JalView, software de visualizaci\u00f3n de alineamientos","text":"<p>Para poder visualizar alineamientos m\u00faltiples de secuencias (MSA, de sus siglas en ingl\u00e9s: Multiple Sequence Alignment) utilizaremos el visualizador de alineamientos JalView desarrollado en JAVA. Jalview permite generar alineamientos, manipularlos, editarlos y anotarlos. Tiene una interfaz que permite acceder remotamente numerosas herramientas como programas para realizar alineamientos m\u00faltiples de secuencia y predictores de estructura secundaria. A lo largo de la gu\u00eda de ejercicios, introduciremos este programa usandolo para visualizar alineamientos m\u00faltiples de secuencias (MSAs) de prote\u00ednas modulares y discutir caracter\u00edsticas de secuencia asociadas a los dominios y motivos funcionales encontrados en las prote\u00ednas.</p> <p>JalView es un programa que se ofrece de manera gratuita, y est\u00e1 disponible para descargar e instalar en tu propia computadora en https://www.jalview.org/</p> <p>Existen un alto n\u00famero de gu\u00edas y tutoriales disponibles online que pueden encontrar en: https://www.jalview.org/training</p> <p>Los desarrolladores de JalView crearon numerosos videos de entrenamiento disponibles en el Canal de YouTube de JalView</p>","tags":["practicos"]},{"location":"practicos/TP10_Desorden/#ejercicio-1-usando-jalview-para-analizar-un-msa-de-p53","title":"Ejercicio 1. Usando JalView para analizar un MSA de p53","text":"<p>1.1. Abre Jalview</p> <p>Para abrir Jalview vayan al directorio: <code>~/Tools/Jalview/</code> y corran el archivo <code>jalview.sh</code>:</p> <pre><code>bash jalview.sh\n</code></pre> <p>Abran en Jalview el conjunto de secuencias de p53 que se encuentra en el archivo <code>p53.fasta</code>:  </p> <p>File \u2192 Input Alignment \u2192  From File</p> <p>1.2. Para realizar el alineamiento utilizaremos el programa Clustal, al cual accederemos de manera remota desde JalView de la siguiente manera:</p> <p>Web Service \u2192 Alignment \u2192  Clustal \u2192 With defaults</p> <p>Si no llegara a funcionar, pues Internet, Virtualidad, la vida... Tienen las secuencias ya alineadas en el archivo <code>p53_aligned.fasta</code></p> <p>1.3. Inspecciona el alineamiento visualmente y reconoce algunas caracter\u00edsticas de las secuencias. Si no se muestran todos los residuos y algunos aparecen como <code>.</code> ve a:</p> <p>Format \u2192 Show Non-Conserved</p> <p>1.3a. Algunas secuencias son m\u00e1s cortas que otras \u00bfpor qu\u00e9 crees que es esto?</p> <p>1.3b. \u00bfSi quieren construir un alineamiento de alta calidad, preservar\u00edan o descartar\u00edan estas secuencias?</p> <p>1.3c. Remuevan las secuencias que no corresponden a prote\u00ednas completas. Para ello seleccionar las secuencias haciendo click sobre el nombre de la misma en el panel izquierdo, la secuencia se marcar\u00e1 con una caja roja punteada. Remover la secuencia seleccionada utilizando la tecla Backspace o Del</p> <p>1.3d. \u00bfExisten regiones del alineamiento que no est\u00e9n alineadas correctamente?</p> <p>Para editar el alineamiento, primero asegurate de realizar:</p> <p>Select \u2192 Deselect All</p> <p>Eliminar gaps: Seleccione con el mouse el gap o arrastrando sobre el grupo de gaps que desea eliminar y presione o Backspace o bien Del</p> <p>Agregar gaps: Presione F2. En la primera posici\u00f3n del alineamiento en la primera secuencia aparecer\u00e1 un cursor de color negro. Col\u00f3quelo en la posici\u00f3n donde desee ingresar un gap y presione la barra espaciadora.</p>","tags":["practicos"]},{"location":"practicos/TP10_Desorden/#ejercicio-2-analisis-de-distintas-propiedades-del-msa-utilizando-el-menu-colour","title":"Ejercicio 2. An\u00e1lisis de distintas propiedades del MSA utilizando el men\u00fa COLOUR.","text":"<p>Este men\u00fa permite colorear el alineamiento con diferentes paletas de colores que permiten visualizar determinadas caracter\u00edsticas fisicoqu\u00edmicas o relacionadas con la conservaci\u00f3n o identidad de secuencia que facilitan el an\u00e1lisis de la informaci\u00f3n contenida en el MSA.</p> <p>Por ejemplo: Percentage identity colorea los residuos seg\u00fan el porcentaje de identidad en la columna. Hydrophobicity colorea los residuos seg\u00fan el grado de hidrofobicidad.</p> <p>Tambi\u00e9n es posible disminuir la intensidad de los colores seg\u00fan el grado de conservaci\u00f3n (By conservation) o filtrar los colores seg\u00fan el porcentaje de identidad (Above identity threshold) a partir de un umbral deseado.</p> <p>2.1. Seleccione para colorear el alineamiento desde el men\u00fa la opci\u00f3n:</p> <p>Colour \u2192 Clustalx</p> <p>Este esquema es muy com\u00fanmente utilizado para la visualizaci\u00f3n de MSAs y permite representar informaci\u00f3n importante contenida en los patrones de sustituci\u00f3n de un MSA.</p> <p>Observando el alineamiento intente identificar:</p> <p>2.1a. \u00bfCu\u00e1l es la base del esquema de color \u201cClustalX\u201d provisto por Jalview? Nota: Google provee respuestas pero... pueden ir directamente al esquema de colores de ClustalX </p> <p>2.1b. \u00bfCu\u00e1ntos colores existen?  </p> <p>2.1c. \u00bfQu\u00e9 propiedades fisicoqu\u00edmicas representa cada grupo de color?  </p> <p>2.1d.. La ciste\u00edna cumple un rol estructural importante en algunas prote\u00ednas (\u00bfcu\u00e1l?).</p> <ul> <li>\u00bfQu\u00e9 observa respecto de la coloraci\u00f3n de la ciste\u00edna? \u00bfEs siempre igual?</li> <li>\u00bfA qu\u00e9 se debe el cambio en la representaci\u00f3n?  </li> </ul> <p>En ProViz la ciste\u00edna estaba siempre coloreada del mismo color, pero en el esquema de colores de ClustalX no lo est\u00e1.</p> <p>2.1e. \u00bfEn qu\u00e9 situaciones los residuos no est\u00e1n coloreados?</p> <p>2.1f. Hay residuos que siempre est\u00e1n coloreados? \u00bfCu\u00e1les son y a qu\u00e9 cree que se debe?</p> <p>2.2. Manteniendo el esquema de color Clustal, es posible filtrar regiones de acuerdo al % identidad en el alineamiento m\u00faltiple. Para ello, aplique el filtro de identidad yendo a:</p> <p>Colour \u2192 Above identity threshold</p> <p>Se abrir\u00e1 una ventana en la cual podr\u00e1 seleccionar el % identidad del filtro en escala de 0 a 100%. Explore los cambios en todo el alineamiento al variar la escala de 0 a 100%.</p> <p>Utilizando el filtro, respondan:</p> <p>2.2.a. \u00bfQu\u00e9 regiones muestran una identidad de secuencia mayor al 80% en el MSA de p53? \u00bfY al 100%?</p> <p>Anote los l\u00edmites de estas regiones y responda: \u00bfQu\u00e9 correlaci\u00f3n observa con la informaci\u00f3n obtenida de Pfam?</p> <p>Con la identidad al 80%, observe en las columnas del MSA que sustituciones ocurren. Estas susticiones son un reflejo de la historia evolutiva de la prote\u00edna y contienen mucha informaci\u00f3n funcional.</p> <p>Observando detenidamente, responda:</p> <p>2.2.b. \u00bfQu\u00e9 tipos de sustituciones observa?</p> <p>2.2.c. \u00bfQu\u00e9 relaci\u00f3n guardan estas sustituciones con las matrices PAM y BLOSUM utilizadas para construir alineamientos de prote\u00ednas? </p> <p>2.2.d. En base a este alineamiento analice las regiones desordenadas y ordenadas ya reconocidas en p53. Compare sus observaciones en este alineamiento con el alineamiento visualizado en ProViz en el Ejercicio 1 de la PARTE I.</p> <ul> <li>\u00bfPuede distinguir las mismas regiones? </li> <li>\u00bfVe diferencias en la composici\u00f3n de secuencia en cada regi\u00f3n entre los dos alineamientos?  </li> <li>\u00bfSe observan diferencias en el grado de conservaci\u00f3n entre los dos alineamientos?  </li> <li>\u00bfLas especies a las que corresponde cada secuencia son las mismas en los alineamientos? \u00bfCu\u00e1l posee organismos m\u00e1s distantes?  </li> <li>Discuta qu\u00e9 ventajas considera que tiene trabajar con un alineamiento propio respecto de trabajar con el alineamiento de ProViz.</li> </ul>","tags":["practicos"]},{"location":"practicos/TP10_Desorden/#ejercicios-adicionales-de-desorden","title":"Ejercicios Adicionales de Desorden","text":"","tags":["practicos"]},{"location":"practicos/TP10_Desorden/#ejercicio-adicional-1-busqueda-de-regiones-funcionales-dentro-de-las-idps-usando-como-ejemplo-la-proteina-p53","title":"Ejercicio Adicional 1. B\u00fasqueda de regiones funcionales dentro de las IDPs, usando como ejemplo la prote\u00edna p53.","text":"","tags":["practicos"]},{"location":"practicos/TP10_Desorden/#objetivos_2","title":"Objetivos","text":"<ul> <li>Familiarizarse con la identificaci\u00f3n de sitios de uni\u00f3n en IDPs</li> <li>Interpretaci\u00f3n de los resultados de los distintos m\u00e9todos.</li> </ul> <p>Muchas prote\u00ednas desordenadas ejercen su funci\u00f3n uni\u00e9ndose a una prote\u00edna globular, mediante una transici\u00f3n de desorden a orden. ANCHOR es un algoritmo para predecir sitios de uni\u00f3n en prote\u00ednas desordenadas buscando identificar segmentos que residen en regiones desordenadas y no forman interacciones intracatenarias suficientes que favorezcan el plegado por s\u00ed mismas, pero s\u00ed logran estabilizarse al interactuar con una prote\u00edna globular.</p> <ol> <li> <p>Ve a la web de IUPred. https://iupred2a.elte.hu</p> </li> <li> <p>Ingresa la prote\u00edna p53 (P53_HUMAN), aseg\u00farate que la opci\u00f3n ANCHOR en Context-dependent predictions est\u00e9 seleccionada.</p> <ul> <li>\u00bfCu\u00e1ntas regiones de interacci\u00f3n identifica ANCHOR?</li> </ul> </li> <li> <p>La base de datos IDEAL se enfoca en IDRs que adoptan una estructura 3D al unirse a sus pares proteicos y se los llama Protean Segments (ProS), que se definen cuando la informaci\u00f3n estructural y no desestructural existen. Hay otros conceptos similares a los ProS que difieren en la definici\u00f3n, como por ejemplo, los Molecular recognition features (MoRFs), que tienen una limitaci\u00f3n de longitud de 70 residues y los motivos lineales eucari\u00f3ticos que son expresados por expresiones regulares.</p> <p>Ingresa a la base de datos IDEAL https://www.ideal-db.org/ y busca la prote\u00edna p53 (P53_HUMAN, P04637). \u00bfQu\u00e9 regiones est\u00e1n involucradas en la formaci\u00f3n de complejos?</p> <p>Prestando atenci\u00f3n a la regi\u00f3n C-terminal:</p> <ul> <li>\u00bfA cu\u00e1ntas prote\u00ednas distintas se une p53? (Revise el link \"complex\") </li> <li>\u00bfQu\u00e9 tipo de estructura secundaria adquieren en el complejo?</li> </ul> </li> <li> <p>\u00bfCu\u00e1n parecidas son las predicciones de ANCHOR con las regiones de uni\u00f3n conocidas?</p> </li> </ol> <p>Existen much\u00edsimos m\u00e9todos para predecir regiones desordenadas. Puedes probar los siguientes m\u00e9todos en casa y ver las diferencias:</p> <ul> <li>PONDR: http://www.pondr.com</li> <li> <p>PredictProtein: https://predictprotein.org/</p> <p>IDPs se predicen por Meta-Disorder a partir de una combinaci\u00f3n de NORSnet, DISOPRED2, PROFbval y Ucon.</p> </li> <li> <p>Globplot2 http://globplot.embl.de/</p> </li> <li> <p>DISOPRED3 http://bioinf.cs.ucl.ac.uk/psipred/</p> <p>Elegir la opci\u00f3n Disopred3. Este m\u00e9todo lleva por lo menos 20 minutos y puede tardar hasta 2 horas.</p> </li> </ul>","tags":["practicos"]},{"location":"practicos/TP10_Desorden/#ejercicio-adicional-2-analisis-de-una-proteina-altamente-desordenada","title":"Ejercicio Adicional 2. An\u00e1lisis de una prote\u00edna altamente desordenada.","text":"<ol> <li>Utiliza un predictor de desorden para la entrada de DisProt DP00039.</li> <li>Utiliza el servidor protparam https://web.expasy.org/protparam/, o alg\u00fan otro m\u00e9todo que conozcas, para contar el n\u00famero de amino\u00e1cidos cargados positivamente y el n\u00famero de amino\u00e1cidos cargados negativamente.</li> <li>Calcula la carga neta (o utiliza el servidor protparam). \u00bfCoincide con lo que esperaba?</li> <li>Observa los dominios que propone InterPro. \u00bfExisten contradicciones entre la asignaci\u00f3n de dominios y el desorden predicho?</li> </ol>","tags":["practicos"]},{"location":"practicos/TP11_Motivos/","title":"Practico Once","text":"","tags":["practicos"]},{"location":"practicos/TP11_Motivos/#tp-11-motivos-lineales","title":"TP 11. Motivos lineales","text":"","tags":["practicos"]},{"location":"practicos/TP11_Motivos/#slides-mostrados-en-la-clase","title":"Slides mostrados en la clase","text":"<ul> <li> Slides</li> </ul> <p>Atenci\u00f3n: Este TP tiene informe.</p> <p> Materiales</p>","tags":["practicos"]},{"location":"practicos/TP11_Motivos/#recursos-online","title":"Recursos Online","text":"<ul> <li>Regex101 https://regex101.com</li> <li>UniProt  http://www.uniprot.org/</li> <li>ELM http://elm.eu.org</li> </ul>","tags":["practicos"]},{"location":"practicos/TP11_Motivos/#objetivos","title":"Objetivos","text":"<ul> <li>Familiarizarse con la simbolog\u00eda utilizada en expresiones regulares</li> <li>Utilizar la simbolog\u00eda para poder realizar b\u00fasquedas basadas en texto</li> </ul>","tags":["practicos"]},{"location":"practicos/TP11_Motivos/#introduccion","title":"Introducci\u00f3n","text":"<p>La simbolog\u00eda com\u00fanmente utilizada en expresiones regulares es:</p> S\u00edmbolo Definici\u00f3n . Cualquier amino\u00e1cido es permitido [XY] Solo los amino\u00e1cidos X e Y son permitidos [^XY] Los amino\u00e1cidos X e Y est\u00e1n prohibidos {min,max} N\u00famero m\u00ednimo y m\u00e1ximo de veces que se puede repetir una posici\u00f3n ^X El amino\u00e1cido X se encuentra en el extremo N-terminal X$ El amino\u00e1cido X se encuentra en el extremo C-terminal (AB)|(CD) Se encuentran, o bien, los amino\u00e1cidos AB, o bien, los amino\u00e1cidos CD <p>Estos s\u00edmbolos nos permiten definir patrones que son observados en prote\u00ednas naturales para luego identificarlos en otras prote\u00ednas y ser puestos a prueba experimentalmente.</p>","tags":["practicos"]},{"location":"practicos/TP11_Motivos/#ejercicios","title":"Ejercicios","text":"","tags":["practicos"]},{"location":"practicos/TP11_Motivos/#ejercicio-1-familiarizandonos-con-las-expresiones-regulares","title":"Ejercicio 1. Familiariz\u00e1ndonos con las Expresiones Regulares","text":"<p>Los receptores nucleares interact\u00faan con diversas prote\u00ednas mediantes un motivo lineal llamado NRBox (Nuclear Receptor Box) (Heery,1997). Existen numerosas estructuras de p\u00e9ptidos unidos a diferentes receptores nucleares (PDBs: 3CS8, 2GPO, 1GWQ, 1RJK, 1M2Z) que permitieron estudiar y entender algunas caracter\u00edsticas de la interacci\u00f3n.</p> <p>La evidencia experimental recolectada de la literatura indica que:</p> <ul> <li> <p>El motivo NRBox forma una h\u00e9lice alfa</p> </li> <li> <p>Existen tres leucinas que se encuentran en una misma cara de la h\u00e9lice que interact\u00faan con un bolsillo hidrof\u00f3bico en la superficie del receptor nuclear (Figura 1).</p> </li> </ul> <p></p> <p>Figura 1. Fragmento de la prote\u00edna PGC-1 alfa unido al receptor nuclear PPAR-gamma. Se muestra en naranja el backbone de la prote\u00edna representado en Cartoon y en azul las tres leucinas que median la interacci\u00f3n representadas en Sticks (PDB:3CS8) y que conforman el motivo NRBox.</p> <p> </p> <p>Los siguientes fragmentos de secuencia corresponden a regiones de distintas prote\u00ednas que interact\u00faan con diversos receptores nucleares y cuya interacci\u00f3n se verific\u00f3 de manera experimental por distintos m\u00e9todos.</p> <pre><code>&gt;sp|Q15648|MED1_HUMAN|644-650\nSMAGNTKNHPMLMNLLKDNPAQDFSTL\n&gt;sp|O43593|HAIR_HUMAN|565-571\nAKHLLSGLGDRLCRLLRREREALAWAQ\n&gt;sp|Q16881-4|TRXR1_HUMAN|46-52\nGPTLKAYQEGRLQKLLKMNGPEDLPKS\n&gt;sp|P48552|NRIP1_HUMAN|500-506\nDVHQDSIVLTYLEGLLMHQAAGGSGTA\n&gt;sp|Q9UQ80|PA2G4_HUMAN|353-359\nYKSEMEVQDAELKALLQSSASRKTQKK \n&gt;sp|Q90ZL7|Q90ZL7_DANRE|69-75\nVQHADGEKSNVLRKLLKRANSYEDAVM\n&gt;sp|Q9UBK2|PRGC1_HUMAN|143-149\nPPPQEAEEPSLLKKLLLAPANTQLSYN \n&gt;sp|Q9JL19|NCOA6_MOUSE|1494-1500\nMSPAMREAPTSLSQLLDNSGAPNVTIK\n&gt;sp|Q15596|NCOA2_HUMAN|689-695\nHGTSLKEKHKILHRLLQDSSSPVDLAK\n&gt;sp|Q92793|CBP_HUMAN|69-75\nLVPDAASKHKQLSELLRGGSGSSINPG\n</code></pre> <p>1. Copie y pegue las secuencias en el recuadro de Test String en regex101 https://regex101.com y pruebe encontrar una expresi\u00f3n regular que permita identificar el motivo que media la interacci\u00f3n de estas prote\u00ednas con los receptores nucleares y que cumpla con la evidencia experimental observada.</p> <p>Regex101</p> <p>No es una herramienta que se use en bioinform\u00e1tica. Simplemente es un recurso educativo para entender Expresiones Regulares.</p> <p>En <code>R</code> hay funciones como <code>grep</code> o <code>gregexpr</code> que permiten identificar expresiones regulares y en python hay todo una librer\u00eda <code>re</code> dedicada a expresiones regulares.</p> <p>2. Considerando que el motivo se encuentra en una h\u00e9lice, \u00bfmodificar\u00eda la expresi\u00f3n regular que obtuvo?</p>","tags":["practicos"]},{"location":"practicos/TP11_Motivos/#ejercicio-2-base-de-datos-de-motivos-lineales-en-eucariotas-elmdb","title":"Ejercicio 2. Base de datos de motivos lineales en Eucariotas (ELMdb)","text":"<p>La base de datos ELM (Eukaryotic Linear Motifs) es una base de datos que se enfoca principalmente en la anotaci\u00f3n y detecci\u00f3n de motivos lineales (MLs). Para ello cuenta con un repositorio de motivos manualmente anotados, por lo cual est\u00e1 altamente curada y tambi\u00e9n cuenta con una herramienta de predicci\u00f3n de motivos. Esta predicci\u00f3n de motivos se realiza mediante una b\u00fasqueda de patrones de secuencia basada en texto utilizando expresiones regulares.</p> <p>Las instancias anotadas (es decir, probadas experimentalmente) pueden ser:</p> <ul> <li>True Positives: Una instancia anotada con evidencia experimental que demuestra que es funcional.</li> <li>False Positives: Una instancia anotada con evidencia experimental que sugiere que es funcional. Pero luego de una inspecci\u00f3n cuidadosa de los anotadores se cree que la instancia en realidad no es funcional.</li> <li>True Negative: Una instancia anotada donde los experimentos muestren que es no funcional.</li> <li>Unknown: No se encontr\u00f3 evidencia suficiente para determinar si la instancia es funcional o no.</li> </ul> <p>1. Busque en ELMdb en la pesta\u00f1a Prediction la prote\u00edna PGC-1-alpha, una de las prote\u00ednas de la lista que usamos en el Ejercicio 1, utilizando el accession number o uniprot ID (Q9UBK2 - PRGC1_HUMAN).</p> <p>Para cada motivo encontrado, se indica con s\u00edmbolos (descriptos en la parte superior de la p\u00e1gina) si la instancia del motivo es predicha o fue identificada experimentalmente (anotadas o \"True Positives\"). Responda:</p> <ul> <li>\u00bfEncuentra el motivo NRBox entre los True positives?</li> <li>\u00bfCu\u00e1ntas instancias True Positive existen para esta prote\u00edna?</li> <li>\u00bfC\u00f3mo es la estructura de la prote\u00edna donde se encuentran estos motivos?</li> </ul> <p>2. Pegue y copie la siguiente secuencia en ELM y utilice los par\u00e1metros que se indican a continuaci\u00f3n.</p> <pre><code>&gt;P53_HUMAN\nMEEPQSDPSVEPPLSQETFSDLWKLLPENNVLSPLPSQAMDDLMLSPDDI  \nEQWFTEDPGPDEAPRMPEAAPPVAPAPAAPTPAAPAPAPSWPLSSSVPSQ  \nKTYQGSYGFRLGFLHSGTAKSVTCTYSPALNKMFCQLAKTCPVQLWVDST  \nPPPGTRVRAMAIYKQSQHMTEVVRRCPHHERCSDSDGLAPPQHLIRVEGN  \nLRVEYLDDRNTFRHSVVVPYEPPEVGSDCTTIHYNYMCNSSCMGGMNRRP  \nILTIITLEDSSGNLLGRNSFEVRVCACPGRDRRTEEENLRKKGEPHHELP  \nPGSTKRALPNNTSSSPQPKKKPLDGEYFTLQIRGRERFEMFRELNEALEL  \nKDAQAGKEPGGSRAHSSHLKSKKGQSTSRHKKLMFKTEGPDSD\n</code></pre> <p>Aseg\u00farese que los valores de los distintos par\u00e1metros son los siguientes:</p> <p>Cell Compartment: Not specified  </p> <p>Motif Probability Cutoff: 100  </p> <p>Taxonomic context: (leave blank) </p> <ul> <li>\u00bfCu\u00e1ntas instancias predichas de motivos se encuentran? Para verlo investigue la tabla llamada Filtering Summary. \u00bfCu\u00e1ntas son retenidas luego del filtro?</li> <li>\u00bfQu\u00e9 se puede decir sobre la estructura de la prote\u00edna? \u00bfSe observa alg\u00fan dominio? \u00bfSe observan regiones desordenadas?  </li> <li>\u00bfLos predictores estructurales y filtros (SMART, GlobPlot, IUPRED, Secondary Structure) coinciden sobre qu\u00e9 regiones son estructuradas/desordenadas?</li> </ul> <p>3. Filtrado por compartimento celular</p> <ul> <li>ELM nos permite fitrar por compartimento celular \u00bfPorqu\u00e9 consideran que esto ser\u00eda \u00fatil?</li> </ul> <p>Utilizando el uniprot ID de p53 (P53_HUMAN) busque en la web de Uniprot (https://www.uniprot.org/) las posibles localizaciones subcelulares de esta prote\u00edna y util\u00edcelas como filtro en ELM. Para esto:</p> <p>Realice de nuevo la predicci\u00f3n, ahora asignando en Cell compartment los compartimentos correspondientes utilizando Ctrl para seleccionar m\u00e1s de uno.</p> <ul> <li> <p>Realice la predicci\u00f3n y conteste: \u00bfCu\u00e1ntas instancias de motivos se encuentran ahora? \u00bfCu\u00e1ntas instancias de motivos son retenidas luego del filtro? \u00bfA qu\u00e9 se debe esta diferencia con el punto anterior?</p> </li> <li> <p>Investigue el motivo <code>CLV_PCSK_FUR_1</code> en la predicci\u00f3n realizada s\u00f3lo con la secuencia. \u00bfPor qu\u00e9 cree que fue filtrado?</p> </li> <li> <p>\u00bfCu\u00e1ntas instancias anotadas como true positive posee esta prote\u00edna? Compare la ubicaci\u00f3n de las instancias anotadas con la informaci\u00f3n estructural proveniente de IUPred.</p> </li> <li> <p>\u00bfCu\u00e1ntas instancias de la clase <code>MOD_CK1_1</code> se encontraron? \u00bfCu\u00e1l es la diferencia entre estas instancias?</p> </li> <li> <p>\u00bfCu\u00e1ntos degrons anotados hay en p53? \u00bfCu\u00e1l es la funci\u00f3n de estos motivos?</p> </li> <li> <p>\u00bfExiste alg\u00fan sitio anotado CDK (Cyclin Dependent Kinase) en p53?</p> </li> <li> <p>\u00bfExiste alg\u00fan sitio anotado <code>DOC_CYCLIN_RXL_1</code>? \u00bfQu\u00e9 relaci\u00f3n funcional existe entre este sitio y el sitio CDK?</p> </li> </ul> <p>4. Abra una nueva pesta\u00f1a y vaya de nuevo a la pesta\u00f1a de predicci\u00f3n. Manteniendo los compartimentos celulares seleccionados para p53, ingrese el Uniprot ID (P53_HUMAN) y modifique el par\u00e1metro:  </p> <p>Motif Probability Cutoff: 0.01 (Recuerde que en el punto anterior este par\u00e1metro era de 100)</p> <ul> <li> <p>\u00bfCu\u00e1ntas instancias predichas de motivos se encuentran ahora? \u00bfCu\u00e1ntas instancias de motivos son retenidas luego del filtro?</p> </li> <li> <p>\u00bfPor qu\u00e9 cree que es \u00fatil usar el umbral de probabilidad del motivo?</p> </li> </ul> <p>5. Abra una nueva pesta\u00f1a y vaya de nuevo a la pesta\u00f1a de predicci\u00f3n. Manteniendo los compartimentos celulares seleccionados para p53, ingrese el Uniprot ID (P53_HUMAN) y modifique el par\u00e1metro:  </p> <p>Taxonomic Context: Homo sapiens</p> <ul> <li> <p>\u00bfCu\u00e1ntas instancias predichas de motivos se encuentran ahora? \u00bfCu\u00e1ntas instancias de motivos son retenidas luego del filtro?</p> </li> <li> <p>\u00bfPor qu\u00e9 cree que es \u00fatil usar el contexto taxon\u00f3mico?</p> </li> </ul> <p>5. Busque la prote\u00edna P53_MOUSE en ELM.</p> <ul> <li>\u00bfExisten instancias anotadas?</li> <li>\u00bfExisten instancias asignadas por homolog\u00eda? \u00bfA qu\u00e9 organismo pertenecen?</li> </ul>","tags":["practicos"]},{"location":"practicos/TP11_Motivos/#ejercicio-3-identificacion-de-motivos-cortos-de-interaccion-en-p53-en-un-alineamiento-propio","title":"Ejercicio 3. Identificaci\u00f3n de motivos cortos de interacci\u00f3n en p53 en un alineamiento propio.","text":"<p>La regi\u00f3n amino terminal de p53 posee un motivo de uni\u00f3n a la E3 ligasa MDM2, el cual est\u00e1 caracterizado por una secuencia conservada que puede representarse por una expresi\u00f3n regular.</p> <ol> <li> <p>Entre en la base de datos ELM y busque la expresi\u00f3n regular del motivo con el ID: <code>DEG_MDM2_SWIB_1</code>. Para esto ingrese el ID en la parte superior derecha donde dice: Search ELM database. La expresi\u00f3n regular se encuentra marcada como \"Pattern\". A continuaci\u00f3n, busque las ocurrencias de esta expresi\u00f3n regular en las secuencias de p53. Para ello, abra en Jalview el alineamiento de p53 con el cu\u00e1l estuvo trabajando en la clase de TP N\u00b07 - Predicci\u00f3n de desorden. Jalview permite la b\u00fasqueda de motivos por expresiones regulares. Para hacerlo, utilice la funci\u00f3n:</p> <p>Select \u2192 Find</p> <p>En la ventana tipee la expresi\u00f3n regular. Si este procedimiento falla, y tiene la ventana de las secuencias no alineadas abiertas, ci\u00e9rrela. Si a\u00fan as\u00ed falla, identifique el motivo utilizando el filtro de conservaci\u00f3n.</p> </li> <li> <p>\u00bfTodas las secuencias de p53 tienen el motivo de interacci\u00f3n con MDM2?</p> </li> <li>\u00bfTodos los motivos MDM2 tienen la misma longitud de secuencia?</li> <li>\u00bfQu\u00e9 nivel de identidad de secuencia observa en esta regi\u00f3n? \u00bfA qu\u00e9 puede deberse?</li> </ol>","tags":["practicos"]},{"location":"practicos/TP11_Motivos/#ejercicio-a-informar","title":"Ejercicio a informar","text":"<p>Fecha l\u00edmite de entrega: Viernes, 1 de Noviembre 2024, 23:59hs.</p> <p>Enunciado</p> <p>M\u00e1s del 90 % de los casos de c\u00e1ncer cervical a nivel global est\u00e1n asociados a la infecci\u00f3n del papilomavirus humano con una alta prevalencia de los tipos virales de alto riesgo de la especie Alphapapillomavirus 9, HPV16 y HPV31, y Alphapapillomavirus 7, HPV18 y HPV45. Los tipos virales de bajo riesgo, como HPV11 y HPV6, se encuentran asociados con menor frecuencia a lesiones malignas. En los casos de c\u00e1ncer atribuidos a HPV los tumores se desarrollan muchos a\u00f1os despu\u00e9s de la infecci\u00f3n inicial. Por lo tanto, la infecci\u00f3n persistente es necesaria para el desarrollo de c\u00e1ncer invasivo. El mantenimiento del fenotipo transformado depende de la expresi\u00f3n continua de algunos de los genes virales, principalmente las prote\u0131\u0301nas E6 y E7.</p> <p>La Prote\u00edna E7 de papillomavirus contiene un dominio desordenado N-terminal (E7N) y un dominio globular C-terminal (E7C). El dominio E7C  media la homodimerizaci\u00f3n a trav\u00e9s de un ciste\u00ednas que coordinan un \u00e1tomo de Cinc.</p> <p>Info</p> <p>Para la introducci\u00f3n, se espera que digan brevemente la relevancia de estudiar motivos lineales en una la prote\u00edna viral E7.</p> <p>1. Usando IUPred, long, identifique las regiones desordenadas y globulares.</p> <p>Piense, analice y discuta:</p> <ul> <li> <p>\u00bfPuede identificar f\u00e1cilmente el dominio E7N del dominio E7C con el umbral de 0.5? \u00bfCambiar\u00eda el umbral de 0.5? \u00bfA qu\u00e9 puede deberse los valores por debajo del umbral observados en el dominio E7N?.</p> <p>Se espera que justifique los resultados en base al funcionamiento del algoritmo y su conocimiento en motivos lineales.</p> </li> </ul> <p>2. Analice la proporci\u00f3n de residuos predichos como ordenados y como desordenados utilizando el umbral de 0.4 \u00bfSe correlaciona esto con lo estudiado en la literatura? Si es que se encuentran diferencias, \u00bfpodr\u00eda hipotetizar a qu\u00e9 se deben?</p> <p>3. Knapp et al (Virology, 2009) proponen la existencia de una se\u00f1al de exportaci\u00f3n nuclear en las posiciones 76 a 89 de E7 de HPV16 dada por la expresion regular: </p> <p>[ILVM]..[ILVMF]...[ILMF]...[ILVMF].[ILVMF]</p> <p>4. Barbosa et al (EMBO J, 1990) proponen la existencia de dos motivos de fosforilaci\u00f3n CKII en las posiciones 31 y 32 de E7 de HPV16 cada uno. El motivo CKII est\u00e1 dado por la expresi\u00f3n regular [ST]..[DE] </p> <ul> <li>\u00bfCu\u00e1ntas instancias de cada uno de los motivos encuentra en el alineamiento, en qu\u00e9 posiciones y cu\u00e1les de estas instancias considera que son buenos candidatos o posibles motivos funcionales? Piense en el contexto estructural y en el grado de conservaci\u00f3n (un criterio para clasificar un buen motivo candidato es que est\u00e9 conservado en &gt;50% de un conjunto de secuencias hom\u00f3logas).</li> </ul> <p>Atenci\u00f3n</p> <p>Siempre que reporte/mencione una regi\u00f3n de una prote\u00edna o instancia de un motivo indique las posiciones de inicio y final de la misma y si las posiciones refieren a posiciones del alineamiento o de la secuencia. Para cada respuesta, indicar los algoritmos, base de datos y m\u00e9todos utilizados, y el criterio usado en cada caso para clasificar/identificar.</p> <p> Materiales</p>","tags":["practicos"]},{"location":"practicos/TP11_Motivos/#ejercicios-adicionales","title":"Ejercicios Adicionales","text":"","tags":["practicos"]},{"location":"practicos/TP11_Motivos/#ejercicio-adicional-1-un-poquito-mas-de-expresiones-regulares","title":"Ejercicio adicional 1. Un poquito m\u00e1s de expresiones regulares","text":"<p>La reparaci\u00f3n del ADN durante la replicaci\u00f3n ocurre por un proceso llamado Translesion synthesis (TLS). En este proceso, una polimerasa TLS, inserta un nucle\u00f3tido en la lesi\u00f3n del ADN y luego, una polimerasa de la familia B extiende el templado. La acci\u00f3n coordinada de estas polimerasas, se logra por la interacci\u00f3n de prote\u00ednas scaffold como PCNA (Proliferating  Cell Nuclear Antigen) y la polimerasa TLS Rev1.</p> <p>Existen estructuras cristalogr\u00e1ficas de distintos p\u00e9ptidos unidos a Rev1 (PDBs: 2N1G, 2LSK, 2LSJ, 4FJO, 2LSI y 4GK5) que permiten entender algunas caracter\u00edsticas de la interacci\u00f3n.</p> <p>La evidencia experimental recolectada de la literatura indica: * La interacci\u00f3n est\u00e1 mediada principalmente por dos residuos consecutivos de fenilalanina (Ohashi,2009). Las fenilaninas interact\u00faan con un bolsillo hidrof\u00f3bico en la superficie de Rev1 (Pozhidaeva, 2012; Zhao,2017). * Las fenilalaninas se encuentran en el primer giro de una h\u00e9lice \u03b1. * Se requieren al menos 4 residuos posteriores a las fenilalaninas que formen parte de una h\u00e9lice (Ohashi, 2009) * El resto de la regi\u00f3n de interacci\u00f3n se pliega formando h\u00e9lices \u03b1 de longitud variable (Pustovalova, 2016) * En general se observan residuos cargados positivamente en la 2da y/o 3ra posici\u00f3n luego de las fenilalaninas que median interacciones electrost\u00e1ticas con una superficie ac\u00eddica de Rev1. Aunque la posici\u00f3n de estos residuos puede variar.</p> <p>Los siguientes fragmentos de secuencia corresponden a regiones de distintas prote\u00ednas que participan en la reparaci\u00f3n del ADN y que se unen la prote\u00edna Rev1. La interacci\u00f3n se verific\u00f3 de manera experimental por distintos m\u00e9todos.</p> <pre><code>&gt;sp|Q03834|MSH6_YEAST|31-38\nSQKKMKQSSLLSFFSKQVPSGTPSKKVQ\n&gt;sp|Q04049|POLH_YEAST|625-632\nKKQVTSSKNILSFFTRKK   \n&gt;sp|Q60596|XRCC1_MOUSE|191-200\nDDSANSLKPGALFFSRINKTSSASTSDPAG\n&gt;sp|Q9H040|SPRTN_HUMAN|418-428\nRPRLEDKTVFDNFFIKKEQIKSSGNDPKYST\n&gt;sp|Q15054|DPOD3_HUMAN|236-245\nNKAPGKGNMMSNFFGKAAMNKFKVNLDSEQ\n&gt;sp|Q9UNA4|POLI_HUMAN|569-579\nSCPLHASRGVLSFFSKKQMQDIPINPRDHLS\n&gt;sp|Q9Y253|POLH_HUMAN|481-490\nTATKKATTSLESFFQKAAERQK VK EA SL SS \n&gt;sp|Q9Y253|POLH_HUMAN|529-539\nPFQTSQSTGTEPFFKQKSLLLKQKQLNNSSV\n&gt;sp|Q9QUG2|POLK_MOUSE|564-575\nLAKPLEMSHKKSFFDKKRSERISNCQDTSRCK\n&gt;sp|Q9UBT6|POLK_HUMAN|565-576\nFVKPLEMSHKKSFFDKKRSERKWSHQDTFKCE\n</code></pre> <ol> <li>Copie y pegue las secuencias en el recuadro de Test String en regex101 y prueba encontrar una expresi\u00f3n regular que permita identificar el motivo que media la interacci\u00f3n de estas prote\u00ednas con Rev1 y que cumpla con la evidencia experimental observada.</li> <li>Busque en ELM alguna de las prote\u00ednas. \u00bfTu expresi\u00f3n regular difiere mucho de la propuesta por ELM?</li> <li>SlimSearch es una herramienta que utilizando expresiones regulares permite buscar la presencia de motivos en las prote\u00edna almacenadas en Uniprot. Vaya a la web de SlimSearch (http://slim.ucd.ie/slimsearch/) e ingrese la expresi\u00f3n regular del motivo como figura en ELM.</li> <li>\u00bfCu\u00e1ntas prote\u00ednas obtuviste?</li> <li>\u00bfCu\u00e1l es la localizaci\u00f3n celular de Rev1 (Q9UBZ9)? Explore la lista de prote\u00ednas. \u00bfHay alguna que no tenga la misma localizaci\u00f3n?</li> <li>Encuentre en la lista la prote\u00edna Kinesin-like protein KIF11 (P52732). \u00bfCu\u00e1l es su localizaci\u00f3n?  ProViz es una herramienta que colecta y muestra informaci\u00f3n desde distintas fuentes facilitando la detecci\u00f3n de motivos lineales.</li> <li>Ingrese en el servidor de Proviz y busque la prote\u00edna Kinesin-like protein KIF11 (KIF11) (P52732). Ubique la regi\u00f3n donde se encuentra el posible motivo sugerido por SlimSearch. \u00bfEst\u00e1 conservado? \u00bfA qu\u00e9 se debe esa conservaci\u00f3n? \u00bfTe parece que es un posible motivo?</li> </ol>","tags":["practicos"]},{"location":"practicos/TP11_Motivos/#ejercicio-adicional-2-familiarizandose-con-la-base-de-datos-elm","title":"Ejercicio Adicional 2. Familiariz\u00e1ndose con la base de datos ELM.","text":"<ol> <li>Realice la b\u00fasqueda de la secuencia de la prote\u00edna Paxillina (P49023) en ELM, utilizando los par\u00e1metros por defecto. Compare los resultados con una b\u00fasqueda de la misma secuencia pero modificando el par\u00e1metro cellular compartment plasma membrane.</li> <li>Busque la prote\u00edna SRC_MOUSE (P05480) en ELM.</li> <li>\u00bfExisten instancias anotadas?</li> <li>Si no, \u00bfcu\u00e1l es la instancia anotada m\u00e1s cercana que se puede encontrar?. Investigue de d\u00f3nde proviene esta informaci\u00f3n.</li> <li>Busque en ELM la prote\u00edna MDM4_HUMAN y encuentre el motivo de uni\u00f3n a USP (DOC_USP7_MATH_1). \u00bfCu\u00e1ntas instancias del motivo se encuentran en esta secuencia?</li> <li>Busque en ELM la prote\u00edna AMPH_HUMAN y encuentre la clase LIG_Clathr_ClatBox_1.</li> <li>\u00bfCu\u00e1l es la relevancia biol\u00f3gica de cada una de estas instancias?</li> <li>\u00bfLa anotaci\u00f3n de la relevancia biol\u00f3gica coincide con la estructura globular?</li> <li>Busque todas las instancias anotadas para Homo sapiens que contienen el t\u00e9rmino cilium (pista: Usa http://elm.eu.org/elms/browse_instances.html).</li> <li>\u00bfCu\u00e1ntas instancias hay?</li> <li> <p>\u00bfQu\u00e9 evidencia experimental est\u00e1 anotada y cu\u00e1n confiable es esta evidencia?</p> </li> <li> <p>Busque todas las instancias anotadas que contienen el t\u00e9rmino \u201dretinoblastoma\u201d (Pista: usa http://elm.eu.org/elms/browse_instances.html)</p> </li> <li>Compare el n\u00famero de instancias humanas con el n\u00famero de instancias virales.</li> <li>\u00bfPor qu\u00e9 hay tantas prote\u00ednas virales que interact\u00faan con retinoblastoma? (Pista: La respuesta est\u00e1 en el abstract de la clase del motivo LIG_Rb_LxCxE_1)</li> </ol>","tags":["practicos"]},{"location":"practicos/TP12a_Modelado_Por_Homologia/","title":"Practico Doce","text":"","tags":["practicos"]},{"location":"practicos/TP12a_Modelado_Por_Homologia/#tp-12-modelado-por-homologia-y-alphafold2","title":"TP 12. Modelado por Homolog\u00eda y AlphaFold2","text":"","tags":["practicos"]},{"location":"practicos/TP12a_Modelado_Por_Homologia/#slides-mostrados-en-la-clase","title":"Slides mostrados en la clase","text":"<ul> <li> Slides</li> </ul> <p> Materiales</p>","tags":["practicos"]},{"location":"practicos/TP12a_Modelado_Por_Homologia/#ejercicio-1-modelado-por-homologia-de-una-proteina-de-rana","title":"Ejercicio 1. Modelado por homolog\u00eda de una prote\u00edna de Rana.","text":"<p>Usted es un famoso ec\u00f3logo que desde siempre sinti\u00f3 un especial inter\u00e9s por las ranas. Durante un viaje de campa\u00f1a se encontr\u00f3 con unas ranas muy inusuales que pose\u00edan una fascinante coloraci\u00f3n azul. Luego de a\u00f1os de investigaci\u00f3n y muchos subsidios invertidos, su becario descubri\u00f3 que esta coloraci\u00f3n se debe a la existencia de una prote\u00edna en la linfa de las ranas que es capaz de conjugar biliverdina. Luego de aislar la prote\u00edna, obtiene su secuencia:</p> <pre><code>&gt;Hypsiboas_punctatus_BP\nMRVLLILGVVVLSTLAFAHHEEGHHDDEDLKDDHDPFLPEDHKKALFVYQKPALNNINFA\nFKMYRQLARDHPTENIVISPVSISSALALLSLGAKGHTHSQIVERLGYNTSEIPEQQIHE\nSFHKQLDVVDDKDRDLEFEHGNALFTCKEHKIHQTFLDDAKKFYHSEVIPTDFKNTEEAK\nNQINSYVEKSTHGKITNILDSVDQDAMIALINFIYLRANWQHPFDEKLTKEGDFHVDKDT\nTVKVPFMRRRGIYKMAYTDDIIMVTIPYNGSVEMFLAMTKMGKLSELEQNLNRERSLKWR\nEIMQYQLIDLSLPKLSVSGILNLKETLSKLGIVDVFSNHADLSGITDESHLKVSKAIHKA\nMMSFDEHGTEAAPATAAEADPLMLPPHFKFDYPFIFRVQDLKTKNPLLVGRIANPQK\n</code></pre> <p>Utilizando la secuencia, el becario busca en las bases de datos y descubre que su prote\u00edna es hom\u00f3loga a una superfamilia de prote\u00ednas conocidas como serpinas compartiendo un 43% de identidad de secuencia con la prote\u00edna de humanos.  </p> <p>Para entender las diferencias con la prote\u00edna de humanos, estuvo muy interesado en obtener la estructura tridimensional de la prote\u00edna de rana. Sin embargo, todos los intentos de cristalizaci\u00f3n fallaron rotundamente. Su subsidio se est\u00e1 terminando r\u00e1pidamente pero afortunadamente, un becario muy interesado en bioinform\u00e1tica y el modelado por homolog\u00eda lo salva de su desesperaci\u00f3n.  </p> <p>1. Utilizando la herramienta HHPred modele la prote\u00edna.</p> <p>2. Haga click en Submit en la parte inferior de la p\u00e1gina y seleccione el hit que le parezca m\u00e1s conveniente:</p> <ul> <li>\u00bfpor qu\u00e9 es el m\u00e1s conveniente?</li> <li>\u00bfCu\u00e1l es el PDB ID y a qu\u00e9 cadena corresponde?</li> <li>\u00bfQue e-value tiene?</li> <li>\u00bfque porcentaje de identidad y qu\u00e9 porcentaje de similitud posee con su prote\u00edna (en la parte inferior de la web est\u00e1 el alineamiento)?</li> </ul> <p>Luego seleccione en la parte superior Model using selection. </p> <ul> <li>\u00bfQu\u00e9 se muestra en la nueva ventana? (Mueva la barra inferior para ver que hay en la ventana).</li> </ul> <p>3. Haga click en Forward to Modeller y luego en Submit. (De ser necesario ingrese la siguiente key: MODELIRANJE en el recuadro que dice Modeller key y luego haga click en Submit).</p> <ul> <li>\u00bfQu\u00e9 aparece en la nueva ventana?</li> </ul> <p>4. Descargue el archivo PDB (Download PDB File)</p> <p>5. La herramienta Verify3D permite determinar la compatibilidad de un modelo 3D de una prote\u00edna con su secuencia aminoac\u00eddica en base a cu\u00e1l es el ambiente en el cual se encuentra cada residuo y la compatibilidad con la estructura secundaria en la que se encuentra.  </p> <p>Vaya a la web de UCLA-DOE LAB, suba el archivo PDB obtenido en el paso anterior y clickee en Run programs.</p> <ul> <li>Seleccione Verify3D y espere por los resultados.</li> </ul> <p>El gr\u00e1fico reporta la calidad del modelo por posici\u00f3n y en \u00e9l se observan tres regiones: 1. Posiciones con score menor a cero est\u00e1n mal modeladas, 2. Posiciones con score entre cero y 0.2 est\u00e1n pobremente modeladas, 3. Posiciones con score mayor a 0.2 est\u00e1n modeladas con buena calidad.  </p> <p>Verify 3D asigna como aceptado a un modelo con m\u00e1s del 80% de las posiciones posiciones con un score promedio en el \u00e1rea bien modelada.</p> <ul> <li>Observe el resultado obtenido (Si tarda haga click en el bot\u00f3n Check status) y responda:  </li> <li>\u00bfCu\u00e1l es el porcentaje de residuos con un score promedio en el \u00e1rea de bien modelados?</li> <li>\u00bfQu\u00e9 regi\u00f3n est\u00e1 pobremente modelada seg\u00fan Verify 3D?</li> </ul> <p>6. La herramienta Procheck permite analizar la calidad de la geometr\u00eda de los residuos en una estructura proteica dada en comparaci\u00f3n a par\u00e1metros estereoqu\u00edmicos derivados de estructuras tridimensionales de alta resoluci\u00f3n ya conocidas.</p> <ul> <li> <p>En la parte superior de la p\u00e1gina de los resultados de Verify 3D vaya a Control Panel</p> </li> <li> <p>Seleccione Procheck y espere por los resultados.</p> </li> </ul> <p>a. Investigue el Ramachandran Plot. Reconozca las regiones a los distintos elementos de estructura secundaria y responda:</p> <ul> <li>\u00bfCu\u00e1ntas estructuras se utilizaron para construir este Ramachandran?</li> <li>\u00bfQu\u00e9 residuos no est\u00e1n en el \u00e1rea esperada?</li> <li>\u00bfQu\u00e9 criterio se utiliza para considerar que el modelo es de buena calidad?</li> <li>\u00bfQu\u00e9 porcentaje de residuos en la estructura modelada se encuentran en las regiones m\u00e1s favorecidas?</li> <li>\u00bfQu\u00e9 residuo est\u00e1 representado como tri\u00e1ngulos? \u00bfA qu\u00e9 cre\u00e9s que se debe?</li> </ul> <p>b. Mirando el PDF en \"All Ramachandrans\", investigue los gr\u00e1ficos de ramachandran para todos los residuos.</p> <ul> <li>\u00bfCu\u00e1ntas estructuras se utilizaron para construir este Ramachandran?</li> <li>\u00bfQu\u00e9 residuos no est\u00e1n en el \u00e1rea esperada?</li> <li>Observe el ramachandran te\u00f3rico de la Glicina \u00bfQu\u00e9 diferencias observa respecto al resto? \u00bfy el de la prolina?</li> </ul> <p>c. Investigue los gr\u00e1ficos de las longitudes de enlace en la cadena principal (M/c bond lengths) y los \u00e1ngulos de uni\u00f3n de la cadena principal (M/c bond angles).</p> <ul> <li>\u00bfExisten amino\u00e1cidos que se alejen significativamente de los resultados esperados?</li> </ul> <p>7. En base a los resultados obtenidos por Verify 3D y ProCheck responda: \u00bfEs bueno el modelo? \u00bfPor qu\u00e9?</p> <p>8. Abra chimera y busque el modelo que determin\u00f3 usted a\u00f1os atr\u00e1s:</p> <p>File \u2192 Fetch by ID \u2192 7RBW</p> <p>Si no funciona, el pdb se encuentra en su carpeta de datos y puede utilizar:</p> <p>File \u2192 Open</p> <p>9. Luego, cargue en la misma ventana de Chimera la estructura modelada</p> <p>File \u2192 Open</p> <p>10. Para tener una noci\u00f3n de cu\u00e1n similar es la estructura de dos prote\u00ednas, podemos realizar un Alineamiento Estructural, que consiste en superponer las estructuras de ambas prote\u00ednas en el espacio intentando alinear sus cadenas aminoac\u00eddicas. Para esto:  </p> <p>Vaya a Tools \u2192 Structure Comparison \u2192 MatchMaker</p> <p>Se abrir\u00e1 una nueva ventana.</p> <ul> <li> <p>En Structure(s) to match (el panel de la derecha) seleccione la estructura que ser\u00e1 superpuesta y alineada con la que se eligi\u00f3 como referencia, es decir el modelo.</p> </li> <li> <p>En Chain Pairing elija: Specific chain in reference structure with best aligning chain in match structure</p> </li> <li> <p>En Reference structure (el panel de la izquierda) seleccione la cadena correcta de la estructura utilizada como molde.</p> </li> </ul> <p>Antes de seguir...</p> <p>Piense y conteste:</p> <ul> <li>\u00bfPorqu\u00e9 est\u00e1 utilizando el PDB:7RBW?</li> <li>\u00bfQu\u00e9 cadena debe elegir?</li> </ul> <ul> <li> <p>En Matching asegur\u00e9se que Iterate by pruning long atom pairs untilo no pair exceeds est\u00e1 clickeado.</p> </li> <li> <p>Observe el resultado del alineamiento: \u00bfSon parecidas las estructuras? \u00bfEn donde se observan las mayores diferencias?</p> <p>Vaya a Favorites \u2192 Reply Log</p> </li> <li> <p>\u00bfCu\u00e1l es el RMSD global reportado? \u00bfy con pruned atoms?</p> </li> </ul> <p>11. Para ver c\u00f3mo se corresponde el grado de similitud estructural con el grado de similitud en secuencia podemos realizar un alineamiento de ambas secuencias guiado por el alineamiento estructural. Para esto, vaya a:</p> <p>Tools \u2192 Structure comparison \u2192 \u201cMatch-&gt;Align\u201d</p> <p>Aseg\u00farese que:</p> <ul> <li> <p>Est\u00e9n seleccionadas las cadenas correctas</p> </li> <li> <p>En Residue-residue distance cutoff (angstroms) diga 2.0</p> </li> </ul> <p>Ahora, observando la estructura y el alineamiento responda: </p> <p>I. \u00bfQu\u00e9 son las regiones marcadas en rosa en el alineamiento?  </p> <p>II. \u00bfEste alineamiento, identifica regiones que no alinean estructuralmente? \u00bfA qu\u00e9 se debe?</p> <p>III. En la parte superior de la ventana del alineamiento de secuencia vaya a Headers y seleccione RMSD:ca</p> <ul> <li>\u00bfQu\u00e9 regiones poseen mayor RMSD? \u00bfA qu\u00e9 elementos estructurales corresponden? Para responder esto, seleccione estas regiones con el mouse en el alineamiento y visual\u00edcelas en la estructura alineada.</li> </ul> <p>IV. Para calcular el RMSD manualmente es necesario tener ambas mol\u00e9culas en un mismo archivo y con un sistema de coordenadas relacionado.</p> <p>Para guardar el archivo pdb incluyendo ambas mol\u00e9culas vaya a File \u2192 Save PDB...</p> <p>En la ventana que se abre:</p> <ul> <li>En la secci\u00f3n Save models aseg\u00farese que ambos modelos est\u00e9n seleccionados.</li> <li>Chequee que la \u00fanica casilla tildada sea Save relative to model:</li> <li>Aseg\u00farese que en Save multiple models in est\u00e9 seleccionado a single file</li> <li>Elija la ubicaci\u00f3n y nombre para el archivo.</li> </ul> <p>Abra el archivo con el Leafpad o block de notas.</p> <ul> <li>\u00bfSe encuentran ambas mol\u00e9culas en el archivo? (Pista, \u00bfcuantas cadenas ve y como se llaman?)</li> </ul> <p>Calculo de RMSD</p> \\[ \\operatorname{RMSD(v,w)} = \\sqrt{\\frac{1}{n} \\sum_{i=1}^{n} \\, ((v_{ix} - w_{ix} )^2 + (v_{iy} - w_{iy} )^2 + (v_{iz} - w_{iz} )^2) \\, } \\] <ul> <li> <p>Calcule el RMSD entre los carbonos alpha del residuo leucina 38 del modelo obtenido y la leucina 38 de la cadena A de del templado utilizado.</p> </li> <li> <p>En la f\u00f3rmula de RMSD:</p> <ul> <li>\u00bfCu\u00e1nto vale n en este caso?</li> <li>\u00bfA qu\u00e9 corresponde v y a qu\u00e9 corresponde w?</li> </ul> </li> <li> <p>Verifique su resultado en chimera (en el alineamiento obtenido por match align debe seleccionar ambos residuos a la vez y el RMSD aparece en la parte inferior del recuadro) \u00bfObtuvo el mismo resultado?</p> </li> </ul> <p>12. Para cuantificar el alineamiento de secuencia obtenido, podemos calcular el % de identidad de secuencia. Para ello, en la ventana del alineamiento de secuencias vaya a:</p> <p>Info \u2192 Percent identity.</p> <p>Seleccione una estructura en Compare y la otra estructura en with. En Divide by seleccione longer sequence length. Presiona en Ok.  </p> <ul> <li> <p>\u00bfQu\u00e9 valor de identidad de secuencia obtiene? \u00bfPorque cree que difiere del reportado anteriormente?</p> </li> <li> <p>En la parte superior de la ventana del alineamiento de secuencia vaya a Headers y seleccione Conservation \u00bfLas sustituciones observadas en las secuencias son conservativas?  </p> </li> <li> <p>En base a los resultados obtenidos. \u00bfIntentar\u00eda obtener experimentalmente la estructura de la nueva prote\u00edna, o confiar\u00eda en el modelo?</p> </li> </ul>","tags":["practicos"]},{"location":"practicos/TP12a_Modelado_Por_Homologia/#alphafold2-af2","title":"AlphaFold2 (AF2)","text":"<p>En los \u00faltimos a\u00f1os, hubo un crecimiento continuo en el n\u00famero de estructuras de prote\u00ednas determinadas experimentalmente depositadas en el PDB (actualmente ~170.000). Esto, junto con la explosi\u00f3n de la secuenciaci\u00f3n (millones de secuencias) y el desarrollo de t\u00e9cnicas de deep learning benefici\u00f3 el desarrollo de algoritmos de predicci\u00f3n de estructura tridimensional de prote\u00ednas. Hasta el 2021, los algoritmos de predicci\u00f3n de estructura tridimensional de prote\u00ednas se basan en dos aspectos complementarios: las interacciones f\u00edsicas (o contactos) o la historia evolutiva de la prote\u00edna. Sin embargo, y a pesar de los avances, la mayor\u00eda de los algoritmos de predicci\u00f3n no son muy precisos si se carece de un hom\u00f3logo cercano con una estructura tridimensional resuelta experimentalmente. A partir de la secuencia primaria de una prote\u00edna (Fig 1), AlphaFold2 utiliza una red neuronal para la predicci\u00f3n estructural de alta precisi\u00f3n (en la mayor\u00eda de los casos), la cual aumenta con el uso de estructuras hom\u00f3logas. AlphaFold2 puede incluso predecir con alta precisi\u00f3n las cadenas laterales si el backbone es preciso.</p> <p> Fig 1. Algoritmo de predicci\u00f3n de estructuras AlphaFold2.</p>","tags":["practicos"]},{"location":"practicos/TP12a_Modelado_Por_Homologia/#arquitectura","title":"Arquitectura","text":"<p>AlphaFold2 utiliza una arquitectura de red que utiliza como inputs el alineamiento de secuencias (MSAs) y una representaci\u00f3n de todos los pares de residuos de la secuencia. Mediante un algoritmo iterativo que se basa en la arquitectura Evoformer, se procesan los inputs y en conjunto con un m\u00f3dulo estructural se genera una representaci\u00f3n tridimensional de la prote\u00edna query. </p>","tags":["practicos"]},{"location":"practicos/TP12a_Modelado_Por_Homologia/#metricas-de-confianza","title":"M\u00e9tricas de confianza","text":"<p>AlphaFold2 incorpora m\u00e9tricas de confianza de la predicci\u00f3n.</p> <ul> <li> <p>La principal m\u00e9trica de confianza es el test pLDDT (predicted local-distance difference test) el cual es un predictor confiable del test de diferencias en las distancias C\u03b1 (IDDT-C\u03b1) y eval\u00faa principalmente la correctitud del modelo a nivel local (estimando el error en distancias de un C\u03b1 con C\u03b1 vecinos en un rango de 15\u00c5).</p> </li> <li> <p>La segunda m\u00e9trica se denomina PAE (por Predicted Aligned error) y compara el error en la predicci\u00f3n de pares de residuos, esto es el error sobre el residuo y cuando las estructuras real y predicha son alineadas sobre el residuo x. Esta medida permite la identificaci\u00f3n global de unidades de plegamiento (dominios) y permite predecir si dos dominios guardan relaciones espaciales definidas, o si tienen variabilidad (por ejemplo, si est\u00e1n conectadas por un linker flexible.</p> </li> </ul> <p></p> <p></p> <p>Fig 2. Arriba. Se pueden observar dos dominios globulares, pero se desconoce la disposici\u00f3n espacial relativa entre ellos. Abajo. Se puede observar que adem\u00e1s de identificar los dominios globulares, se predien correctamente pares de residuos interdominios.</p>","tags":["practicos"]},{"location":"practicos/TP12a_Modelado_Por_Homologia/#costo-computacional","title":"Costo computacional","text":"<p>AlphaFold2 consume much\u00edsimos recursos. Por lo tanto, muchas prote\u00ednas de organismos modelos est\u00e1n siendo modeladas y puestas a disposici\u00f3n de la comunidad cient\u00edfica en una base de datos: https://alphafold.ebi.ac.uk/.</p> <p>Afortunadamente, la comunidad cient\u00edfica r\u00e1pidamente desarroll\u00f3 distintas \u201ccolabs\u201d o \u201cnotebooks\u201d que permiten correr AlphaFold2 en una m\u00e1quina remota. Una \u201cdesventaja\u201d es que se debe contar con una cuenta de mail de gmail, cada cuenta de gmail puede usar un colab a la vez.</p> <p>Otra desventaja es que en la versi\u00f3n gratuita de colab, debido al espacio en disco y capacidad de c\u00f3mputo que se adjudica, s\u00f3lo se pueden correr prote\u00ednas o complejos con menos de 1000 residuos y luego de estar corriendo unas cinco prote\u00ednas, hay que esperar a que se renueve el tiempo de c\u00f3mputo de esa cuenta. </p> <p>Otra desventaja, es que no se pueden modificar muchos par\u00e1metros del modelado al usar un colab, en comparaci\u00f3n con correr la simulaci\u00f3n desde un script en una computadora o server propio. Sin embargo, los par\u00e1metros usados en el ColabFold de AlphaFold2 son los que fueron m\u00e1s ampliamente validados durante el desarrollo del m\u00e9todo.</p> <p>Existen distintos colabs que implementan AlphaFold2. En este curso utilizaremos uno en particular: AlphaFold2 using MMseqs2.</p> <p>Todas las versiones de las distintas NoteBooks est\u00e1n disponibles en el github: https://github.com/sokrypton/ColabFold</p>","tags":["practicos"]},{"location":"practicos/TP12a_Modelado_Por_Homologia/#alphafold2-ejercicios","title":"AlphaFold2 - Ejercicios","text":"<p>Los papilomavirus (PVs) son virus desnudos icosa\u00e9dricos y poseen un genoma ADN doble cadena circular entre 5-8 Kb. Sus hospedadores incluyen una amplia variedad de vertebrados desde peces, reptiles, aves y mam\u00edferos. Los PV infectan el epitelio mucoso y queratinizado y producen lesiones denominadas condilomas o papilomas y verrugas respectivamente y en humanos algunos PVs est\u00e1n asociados al c\u00e1ncer cervical uterino, de la formaci\u00f3n de tumores en el tracto urogenital y en las v\u0131\u0301as a\u00e9reas superiores.</p> <p>La prote\u00edna E7 del papilomavirus comparte similitudes funcionales con la prote\u00edna E1A de adenovirus y el ant\u00edgeno T del poliomavirus SV40. Las tres prote\u00ednas poseen actividades transformantes e interaccionan con la prote\u00edna retinoblastoma.</p> <p>La interacci\u00f3n de la prote\u00edna E7 con Rb es responsable de la inducci\u00f3n de la s\u00edntesis de ADN y proliferaci\u00f3n celular. La inmortalizaci\u00f3n y transformaci\u00f3n de la c\u00e9lula infectada inducida por E7 es consecuencia de la interacci\u00f3n de E7 con Rb y numerosos blancos proteicos involucrados en crecimiento celular, transformaci\u00f3n, transcripci\u00f3n, apoptosis y s\u00edntesis de ADN.</p>","tags":["practicos"]},{"location":"practicos/TP12a_Modelado_Por_Homologia/#ejercicio-1-modelado-de-un-monomero-de-e7","title":"Ejercicio 1. Modelado de un Mon\u00f3mero de E7","text":"<ol> <li> <p>Ingrese al ColabFold que implementa MMseq2 Aqu\u00ed.</p> <p>Info</p> <pre><code>Si quiere que los cambios que realice sean guardados deber\u00e1 agregar la notebook a su drive. Pero esto no es necesario.\n</code></pre> </li> <li> <p>En la parte superior, haga click en Runtime \u2192 Change Runtime y aseg\u00farese que:</p> <ul> <li> <p>Runtime type: sea Python 3</p> </li> <li> <p>Hardware accelerator: este seleccionado T4 GPU</p> </li> </ul> </li> <li> <p>Preparando la corrida.</p> <p>En el campo sequence query ingrese la secuencia (sin el encabezado indicado por el signo <code>&gt;</code>) de la prote\u00edna E7 de HPV16.</p> <pre><code>&gt;sp|P03129|VE7_HPV16 Protein E7 OS=Human papillomavirus type 16 OX=333760 GN=E7 PE=1 SV=1\nMHGDTPTLHEYMLDLQPETTDLYCYEQLNDSSEEEDEIDGPAGQAEPDRAHYNIVTFCCKCDSTLRLCVQSTHVDIRTLEDLLMGTLGIVCPICSQKP\n</code></pre> <ul> <li> <p>En el campo jobname ingrese: E7_MONOMERO.</p> </li> <li> <p>En el campo num_relax elija: 1</p> </li> </ul> <p>Info</p> <p>num_relax es el n\u00famero de modelos a relajar con Amber. Esta notebook produce hasta 5 modelos m\u00e1ximo por prote\u00edna. </p> <p>Amber permite mejorar la geometr\u00eda de la uni\u00f3n pept\u00eddica y posici\u00f3n de rot\u00e1meros luego de la relajaci\u00f3n de la estructura. Si bien no mejora la predicci\u00f3n, remueve violaciones estereoqu\u00edmicas.</p> <ul> <li> <p>En template mode elija pdb100 \u00bfQu\u00e9 le parece que es este campo?</p> </li> <li> <p>Vaya a  Runtime \u2192  Run all, o presione <code>Ctrl</code>+<code>F9</code></p> </li> <li> <p>Como por defecto este ColabFold crea 5 modelos hay que esperar (unos 20 minutos).</p> </li> </ul> <p>IMPORTANTE</p> <p>No cierre la ventana y tampoco cierre la laptop porque la corrida entonces se detiene (no pasa nada si entra en suspensi\u00f3n).</p> <p>Al finalizar la corrida, los resultados ser\u00e1n descargados autom\u00e1ticamente como un archivo zip. Si esto no llegara a suceder, puede acceder al mismo haciendo click en el icono con forma de carpeta que se encuentra a la izquierda.</p> </li> <li> <p>Localice el archivo descargado y descompr\u00edmalo (el nombre del archivo comienza con <code>E7_MONOMERO</code>). Encontrar\u00e1 varios archivos, en particular:</p> <ul> <li><code>Cite.bibtex</code> Contiene todas las citas correspondientes a los papers relacionados.</li> <li><code>Config.json</code> Contiene todos los par\u00e1metros utilizados en la corrida.</li> <li><code>*.a3m</code> Alineamiento</li> <li><code>*_coverage.png</code> Gr\u00e1fico de la cobertura del alineamiento</li> <li><code>*_PAE.png</code> Gr\u00e1fico del PAE por pares de residuos para todos los modelos.</li> <li><code>*_plddt.png</code> Gr\u00e1fico del plddt por posici\u00f3n</li> <li><code>*_predicted_aligned_error_v1.json</code> Tiene los valores de PAE para todos los pares de todos los modelos.</li> <li><code>*_relaxed_*_model_*.pdb</code> Son los modelos generados y relajados.</li> <li><code>*_unrelaxed_*_model_*.pdb</code> Son los 5 modelos generados sin relajar.</li> <li><code>*_model_*.json</code> Son el PAE y pLDDT de cada modelo que se pueden utilizar para graficar.</li> <li>En la carpeta<code>*_env*</code> Tiene los templados utilizados por AlphaFold2 si es que se usaron.</li> </ul> </li> <li> <p>Abra Chimera y cargue el modelo relajado (relaxed) (si no recuerda File \u2192 Open \u2026).</p> </li> <li> <p>Abra el pdb: 2b9d. (Puede descargalo realizando File \u2192 Fetch by ID o bien yendo a la web de la rcsb)</p> <ul> <li>\u00bfEstaba esta estructura entre los templados?</li> <li>\u00bfPor qu\u00e9 m\u00e9todo fue determinada?</li> <li>\u00bfA qu\u00e9 prote\u00edna corresponde? \u00bfDe qu\u00e9 organismo?</li> </ul> </li> <li> <p>Alinee las estructuras utilizando Matchmaker (si no recuerda, Tools \u2192 Structure comparison \u2192 Matchmaker)</p> <ul> <li>\u00bfCu\u00e1l es el RMSD global?</li> </ul> <p>Si quieren ver el RMSD por posici\u00f3n sobre la estructura</p> <p>Structure Comparison \u2192 Match align</p> <p>Seleccione el par de modelos adecuado. En residue-residue distance cutoff seleccione el mismo umbral que utiliz\u00f3 en Matchmaker para pruned atoms (Por defecto es 2)</p> <p>Para colorear la estructura por RMSD para eso vaya a: Tools \u2192 Depiction \u2192 Render by Attribute</p> <p>En attributes of aseg\u00farese que est\u00e9 seleccionado residues</p> <p>En el recuadro de Models aseg\u00farese que est\u00e9n ambos modelos seleccionados.</p> <p>En la pesta\u00f1a Render seleccione mavRMSDca y luego haga clic en <code>Ok</code>.</p> </li> <li> <p>Cierre el modelo correspondiente al pdb 2b9d. Via terminal tiene que ingresar el comando close seguido del n\u00famero del modelo, por ejemplo:</p> <pre><code>close #0\n</code></pre> <p>cierra el modelo 0.</p> <p>O bien, en el model panel, seleccione el modelo correspondiente y haga clic en close.</p> </li> <li> <p>Ahora abra los 4 modelos restantes, para eso, File \u2192 Open\u2026 y con el mouse seleccione los modelos manteniendo la tecla ctrl presionada.</p> </li> <li> <p>Alinee los modelos ranqueados de 2 a 5 contra el modelo 1, </p> <ul> <li>Explore el Reply log \u00bfcu\u00e1l es el RMSD global de cada par alineado?</li> </ul> </li> <li> <p>Utilice Match Align para ver el alineamiento. Recuerde utilizar el umbral adecuado!.</p> <ul> <li>\u00bfQu\u00e9 observa?</li> <li>\u00bfPorque si las secuencias son todas iguales no aparece el n-terminal alineado?</li> </ul> </li> <li> <p>Los valores de pLDDT est\u00e1n almacenados en la columna del pdb que corresponde a los b-factors. Para colorear por b-factors, utilizaremos la command line que Chimera trae integrada. Para esto vaya a: Favorites \u2192 Command line. En la parte inferior de la pantalla se abrir\u00e1 un rengl\u00f3n donde puede ingresar los comandos necesarios.</p> <p>Para colorear los modelos seg\u00fan el atributo b-factor donde est\u00e1 almacenado el plDDT ingrese en la command line:</p> <pre><code>rangecolor bfactor min orange red mid white max dodger blue\n</code></pre> <ul> <li>\u00bfQu\u00e9 observa?</li> </ul> <p>En el reply log se reportan los valores m\u00ednimo, medio y m\u00e1ximo encontrados en la columna de b-factors.</p> <ul> <li>\u00bfCu\u00e1les son el m\u00ednimo y el m\u00e1ximo?</li> </ul> <p>Ahora en lugar de que Chimera elija los valores observados como m\u00ednimo y m\u00e1ximo de la escala, los vamos a configurar con el siguiente comando:</p> <pre><code>rangecolor bfactor 0 orange red 50 white 100 dodger blue\n</code></pre> <p>Ahora cambie el valor m\u00ednimo a min (se elige el valor m\u00ednimo presente en la columna de b-factors) y el valor intermedio que antes era 50, a 70:</p> <pre><code>rangecolor bfactor min orange red 70 white 100 dodger blue\n</code></pre> <ul> <li>\u00bfObserva diferencias con lo anterior? \u00bfCu\u00e1les?</li> </ul> <p>Ahora corra:</p> <pre><code>rangecolor bfactor 50 orange red 70 white 100 dodger blue\n</code></pre> <ul> <li> <p>\u00bfObserva diferencias con lo anterior? \u00bfCu\u00e1les?</p> </li> <li> <p>\u00bfPorqu\u00e9 considera que elegimos 50 como valor m\u00ednimo?</p> </li> <li> <p>\u00bfDe qu\u00e9 posici\u00f3n a qu\u00e9 posici\u00f3n considerar\u00eda que el modelo es de confianza?</p> </li> </ul> </li> <li> <p>Investigue el gr\u00e1fico de pLDDT que se descarg\u00f3 con el modelo.</p> <ul> <li> <p>\u00bfQu\u00e9 observa?</p> </li> <li> <p>\u00bfPuede identificar las regiones con un pLDDT mayor a 70?</p> </li> <li> <p>\u00bfPuede identificar las regiones con un pLDDT entre 50 a 70?</p> </li> </ul> </li> <li> <p>Abra R Studio. Ahora graficaremos los pLDDT por posici\u00f3n para cada uno de los modelos.</p> <pre><code>install.packages(\"bio3d\")\ninstall.packages(\"reshape2\")\nlibrary(bio3d)\nlibrary(ggplot2)\nlibrary(reshape2)\n\nsetwd(*DIRECTORIO DE TRABAJO DESEADO*)\n\ndirectorio &lt;- \"/directorio/donde/estan/los/modelos/\"\n\narchivos &lt;- list.files(path = directorio,pattern = \"_unrelaxed_\",)\n\nmiarchivo &lt;- paste(directorio,archivos[1],sep=\"\")\nmipdb &lt;- read.pdb(miarchivo)\n\ndatos &lt;- data.frame(Residue = mipdb$atom[mipdb$calpha,\"resno\"],\n                    Rank_1 = mipdb$atom[mipdb$calpha,\"b\"]\n)\n\nfor(i in 2:length(archivos)){\n    miarchivo2 &lt;- paste(directorio,archivos[i],sep=\"\")\n    mipdb2 &lt;- read.pdb(miarchivo2)\n    nuevaColumna &lt;- paste(\"Rank\",i,sep=\"_\")\n    datos[nuevaColumna] &lt;- mipdb2$atom[mipdb2$calpha,\"b\"]\n}\n\nfileOUT &lt;- paste(directorio,\"E7_Monomero.png\",sep=\"\")\n\ndatos2 &lt;- melt(datos, id=\"Residue\")\ndatos2$variable &lt;- as.factor(datos2$variable)\n\np1 &lt;- ggplot(datos2, mapping=aes(x=Residue,y=value,color=variable)) + \ngeom_line() + theme_bw() +\nscale_x_continuous(name = \"E7 Residue\", breaks = seq(5,100,by=5),limits = c(0,100),expand=c(0,0)) +\nscale_y_continuous(name = \"Predicted lDDT\", breaks = seq(5,100,by=5),limits = c(0,101),expand=c(0,0)) +\ngeom_hline(yintercept = 90,color=\"blue\")+\ngeom_hline(yintercept = 70,color=\"orange2\")+\ngeom_hline(yintercept = 50,color=\"red\")\np1\n\nggsave(filename = fileOUT,plot = p1,device = \"png\",width = 20,height = 10,units = \"cm\",dpi = 300)\n</code></pre> </li> <li> <p>Encuentre el archivo corespondiente al gr\u00e1fico del PAE.</p> <ul> <li>\u00bfQu\u00e9 interpreta?</li> </ul> </li> <li> <p>En base a los resultados obtenidos, </p> <ul> <li>\u00bfQu\u00e9 puede decir de la estructura de la prote\u00edna?</li> <li>\u00bfCu\u00e1ntos dominios posee? \u00bfordenados o desordenados?</li> <li>\u00bfPuede decir aproximadamente los l\u00edmites?</li> </ul> </li> <li> <p>Guarde la sesi\u00f3n (Save Session As... ) y cierre chimera.</p> </li> </ol>","tags":["practicos"]},{"location":"practicos/TP12a_Modelado_Por_Homologia/#ejercicios-adicionales","title":"Ejercicios adicionales","text":"","tags":["practicos"]},{"location":"practicos/TP12a_Modelado_Por_Homologia/#ejercicio-adicional-1-modelado-de-un-dimero-de-e7","title":"Ejercicio Adicional 1. Modelado de un d\u00edmero de E7","text":"<ol> <li> <p>En la parte superior, haga click en Runtime \u2192 Disconnect and delete Runtime</p> </li> <li> <p>Preparando la corrida.</p> <p>Para indicar que se quiere correr un mult\u00edmero se debe ingresar las secuencias separadas por <code>:</code>. En el campo sequence query ingrese las secuencias de la prote\u00edna E7 de HPV16. </p> <pre><code>MHGDTPTLHEYMLDLQPETTDLYCYEQLNDSSEEEDEIDGPAGQAEPDRAHYNIVTFCCKCDSTLRLCVQSTHVDIRTLEDLLMGTLGIVCPICSQKP:MHGDTPTLHEYMLDLQPETTDLYCYEQLNDSSEEEDEIDGPAGQAEPDRAHYNIVTFCCKCDSTLRLCVQSTHVDIRTLEDLLMGTLGIVCPICSQKP\n</code></pre> <ul> <li> <p>En el campo jobname ingrese: E7_DIMERO.</p> </li> <li> <p>En num_relax elija 1</p> </li> <li> <p>En template mode elija none</p> </li> <li> <p>Vaya a Runtime \u2192 Run all, o presione <code>Ctrl</code>+<code>F9</code></p> </li> <li> <p>Vuelta a esperar ... unos 20 minutos.</p> </li> </ul> <p>Atenci\u00f3n</p> <p>Antes de seguir adelante vaya al ejercicio 3 y ponga a correr el modelado siguiente!</p> </li> <li> <p>Abra Chimera. Y abra el pdb: 2F8B.</p> <p>Para eso ingrese en el command line:</p> <pre><code>open 2f8b\n</code></pre> <ul> <li> <p>\u00bfQu\u00e9 observa? \u00bfA qu\u00e9 se debe?</p> </li> <li> <p>Investigue en el rcsb la t\u00e9cnica por la que se obtuvo esta estructura y a qu\u00e9 prote\u00edna pertenece.</p> </li> <li> <p>\u00bfEste pdb es utilizado como templado para el modelado? \u00bfpor qu\u00e9?</p> </li> </ul> </li> <li> <p>Abra el model Panel: Favorites \u2192 Model Panel</p> <p>Para que sea m\u00e1s f\u00e1cil las observaciones vamos a trabajar con un \u00fanico submodelo de cada cadena. Para esto, ingrese en la l\u00ednea de comando:</p> <pre><code>close #0.2-15\n</code></pre> <ul> <li>\u00bfCu\u00e1l es el estado de oligomerizaci\u00f3n de E7?</li> </ul> </li> <li> <p>Coloree el modelo de blanco y oculte todos los residuos utilizando los siguientes comandos</p> <pre><code>color white #0\n~display\n</code></pre> </li> <li> <p>La prote\u00edna E7 en el dominio de dimerizaci\u00f3n contiene un sitio de uni\u00f3n a Zinc. Ubique el zn en la estructura.</p> <pre><code>display @ZN; color red @ZN\n</code></pre> <p>Ahora vamos a seleccionar los residuos m\u00e1s cercanos al zinc:</p> <pre><code>sel :@zn zr&lt;3\ndisplay sel; color red,a sel; color byhet sel;~sel\ndelete element.H\n</code></pre> <ul> <li>\u00bfQu\u00e9 residuos se encuentran coordinando la uni\u00f3n a zinc?</li> </ul> </li> <li> <p>Ubique el archivo zip que se gener\u00f3 con ColabFold y descompr\u00edmalo en su computadora. </p> </li> <li> <p>Identifique el archivo que corresponde al pLDDT.</p> <ul> <li>\u00bfQu\u00e9 regi\u00f3n est\u00e1 modelada con alta confianza y cual no?</li> </ul> </li> <li> <p>Identifique el archivo que corresponde al PAE.</p> <ul> <li>Interprete el gr\u00e1fico.</li> <li>\u00bfCu\u00e1l de los 4 gr\u00e1ficos muestra los valores correspondientes para los pares de residuos de la cadena A, cual para la cadena B y cual para los pares de residuos de de las cadenas A y B?</li> <li>\u00bfCu\u00e1les son los l\u00edmites el dominio globular, aproximadamente?</li> </ul> </li> <li> <p>Elija el modelo mejor mejor ranqueado y alineelo utilizando Matchmaker contra la estructura de 2F8B.</p> <ul> <li>\u00bfCu\u00e1l es el RMSD global?</li> </ul> </li> <li> <p>Abra en chimera los 5 modelos no relajados que se generaron. Luego, alinee utilizando matchmaker y seleccionaremos las ciste\u00ednas que coordinan la uni\u00f3n al zinc.</p> <pre><code>sel #1-5:58,61,91,94; display sel; color blue,a sel; color byhet sel; ~sel\n</code></pre> <p>Coloree las cadenas A y B de los modelos predichos de distinto color</p> <pre><code>sel #1-5:.A; color orange,r sel; ~sel\nsel #1-5:.B; color purple,r sel; ~sel\n</code></pre> <p>Observe de cerca la ubicaci\u00f3n de las ciste\u00ednas y responda:</p> <ul> <li>\u00bfConsidera que la predicci\u00f3n del sitio de uni\u00f3n de zinc es buena a\u00fan cuando no se incluye el i\u00f3n en el modelado?</li> </ul> </li> <li> <p>Coloree las cadenas de los modelos predichos seg\u00fan los valores de pLDDT.:</p> <pre><code>rangecolor bfactor 50 orange red 50 white 100 dodger blue\n</code></pre> <ul> <li>\u00bfQu\u00e9 observa?</li> </ul> <p>En base a todas las caracter\u00edsticas observadas: pLDDT, PAE, coordinaci\u00f3n de zinc,</p> <ul> <li> <p>\u00bfPudo AF2 predecir el estado de oligomerizaci\u00f3n?</p> </li> <li> <p>\u00bfPudo AF2 predecir la coordinaci\u00f3n del zinc?</p> </li> <li> <p>\u00bfQu\u00e9 opina del modelo?</p> </li> </ul> </li> <li> <p>Guarde la sesi\u00f3n y cierre chimera.</p> </li> </ol>","tags":["practicos"]},{"location":"practicos/TP12a_Modelado_Por_Homologia/#ejercicio-adicional-2-modelado-de-un-motivo-unido-a-un-dominio-globular-en-alphafold2","title":"Ejercicio Adicional 2. Modelado de un motivo unido a un dominio globular en Alphafold2","text":"<p>La prote\u00edna retinoblastoma (Rb) regula el avance del ciclo celular de la fase G1 \u2192 S. La prote\u00edna Rb posee un dominio globular llamado Dominio pocket que est\u00e1 formado por dos subdominios A y B unidos por un loop.</p> <p>Uno de los blancos celulares de Rb es la Histone desacetilasa 1 (HDAC) que posee el motivo lineal de interacci\u00f3n LxCxE. Sin embargo la afinidad de HDAC1 por Rb, es mucho menor (20\u00b5M) en comparaci\u00f3n a la afinidad del motivo de la prote\u00edna viral E7 de papilomavirus (5nM).</p> <p>Una estructura tridimensional permite entender desde el aspecto molecular las diferencias en las interacciones que podr\u00edan llevar a diferencias en afinidades. Sin embargo, hasta la fecha, no se posee una estructura del complejo Rb-HDAC1.</p> <ol> <li> <p>Modele el complejo utilizando el colab: AlphaFold2.</p> <p>Para tardar menos en el modelado vamos a realizar algunas modificaciones.</p> <p>En lugar de ingresar la secuencia completa de la prote\u00edna retinoblastoma, vamos a ingresar \u00fanicamente la correspondiente al dominio pocket de la prote\u00edna retinoblastoma, donde los loops se encuentran reemplazados por secuencias m\u00e1s cortas.</p> <p>Al final, indicaremos con el <code>:</code> el inicio de la cadena correspondiente al motivo HDAC (<code>DKRIACEEEFSD</code>).</p> <p>Obteniendo finalmente:</p> <pre><code>NTIQQLMMILNSASDQPSENLISYFNNCTVNPKESILKRVKDIGYIFKEKFAKAVGQGCVEIGSQRYKLGVRLYYRVMESMLKSEEERLSIQNFSKLLNDNIFHMSLLACALEVVMATYSRSTSQNLDSGTDLSFPWILNVLNLKAFDFYKVIESFIKAEGNLTREMIKHLERCEHRIMESLAWLSDSPLFDLIKQSKLVPRGSKSTSLSLFYKKVYRLAYLRLNTLCERLLSEHPELEHIIWTLFQHTLQNEYELMRDRHLDQIMMCSMYGICKVKNIDLKFKIIVTAYKDLPHAVQETFKRVLIKEEEYDSIIVFYNSVFMQRLKTNILQYASTRPPTLSPIPHIPR:DKRIACEEEFSD\n</code></pre> <ul> <li> <p>En num_relax elija 1.</p> </li> <li> <p>En template_mode elija: none.</p> </li> </ul> <p>Luego, corra todo con <code>ctrl+F9</code> o vaya a Runtime \u2192 Runall</p> </li> <li> <p>Abra el modelo relajado obtenido por AlphaFold2 en chimera.</p> </li> <li>Abra el pdb 1GUX</li> <li> <p>Alinee ambos complejos utilizando matchmaker.</p> <p>Los siguientes pasos se hacen en la command line de Chimera:</p> </li> <li> <p>Oculte las posiciones que se observan.</p> <pre><code>~display\n</code></pre> </li> <li> <p>Coloree por cadenas.</p> <pre><code>rainbow chain\n</code></pre> </li> <li> <p>Seleccione cada motivo y pongale un nombre (ojo, preste atenci\u00f3n a la numeraci\u00f3n de los modelos y los nombres de las cadenas, este comando es un ejemplo de como deber\u00eda ser)</p> <pre><code>sel #0:.E; namesel E7\nsel #1:.B; namesel HDAC\n</code></pre> </li> <li> <p>Represente ambos motivos en licorice (recuerde seleccionar cada cadena correspondiente antes!)</p> <pre><code>ribscale licorice E7\nribscale licorice HDAC\n</code></pre> </li> <li> <p>Elimine las aguas e hidr\u00f3genos ya que no los utilizaremos para analizar.</p> <pre><code>delete :HOH\ndelete element.H\n</code></pre> </li> <li> <p>Muestre las cadenas laterales de los motivos coloreando por heteroatomos.</p> <pre><code>display E7\ndisplay HDAC\ncolor byhet E7\ncolor byhet HDAC\n</code></pre> </li> <li> <p>Observe el modo de interacci\u00f3n, \u00bfSe encuentran conservado?</p> </li> <li> <p>\u00bfPor qu\u00e9 podr\u00eda tener m\u00e1s baja afinidad HDAC1 que E7?</p> </li> <li> <p>Coloree por b-factors el modelo obtenido por AlphaFold (Recuerde que contienen el plDDT y aseg\u00farese que su modelo es el indicado en el comando #1)</p> <pre><code>rangecolor bfactor 50 orange red 70 white 100 dodger blue #1\n</code></pre> <ul> <li>A ojo, \u00bfCu\u00e1l es la calidad del modelado del p\u00e9ptido que contiene el motivo (HDAC)?</li> </ul> </li> <li> <p>Investigue el gr\u00e1fico de PAE que se descarga con los modelos.</p> <ul> <li>\u00bfQu\u00e9 nivel de confianza observa en la ubicaci\u00f3n relativa del p\u00e9ptido HDAC respecto del dominio Rb?</li> </ul> </li> <li> <p>En base a las observaciones realizadas: \u00bfAlphaFold se puede utilizar para analizar la interacci\u00f3n de motivos con dominios globulares?</p> </li> </ol>","tags":["practicos"]},{"location":"practicos/TP12b_AlphaFold/","title":"Practico Doce","text":"","tags":["practicos"]},{"location":"practicos/TP12b_AlphaFold/#tp-12b-modelado-usando-alphafold2","title":"TP 12b. Modelado usando AlphaFold2","text":"","tags":["practicos"]},{"location":"practicos/TP12b_AlphaFold/#slides-mostrados-en-la-clase","title":"Slides mostrados en la clase","text":"<ul> <li> Slides</li> </ul>","tags":["practicos"]},{"location":"practicos/TP12b_AlphaFold/#videos-de-la-clase-grabada","title":"Videos de la clase grabada","text":"<ul> <li> Puesta en com\u00fan del TP</li> </ul> <p>Atenci\u00f3n: Este TP tiene informe.</p>","tags":["practicos"]},{"location":"practicos/TP12b_AlphaFold/#recursos-online","title":"Recursos Online","text":"<ul> <li>ColabFold For AlphaFold2 using MMseqs2: Aqu\u00ed</li> </ul>","tags":["practicos"]},{"location":"practicos/TP12b_AlphaFold/#requisitos","title":"Requisitos","text":"<p>Para este ejercicio es necesario poseer una cuenta de gmail para poder acceder a las notebooks del Colab.</p>","tags":["practicos"]},{"location":"practicos/TP12b_AlphaFold/#objetivos","title":"Objetivos","text":"<ul> <li>Familiarizarse con el uso del predictor AlphaFold2 y criterios que permiten evaluar los resultados obtenidos, los alcances y las limitaciones de las predicciones obtenidas.</li> </ul>","tags":["practicos"]},{"location":"practicos/TP12b_AlphaFold/#que-es-google-colab","title":"\u00bfQu\u00e9 es Google Colab?","text":"<p>Colab, o Colaboratory, permite escribir y ejecutar Python en nuestro navegador. Nos da acceso a una m\u00e1quina de manera remota.</p> <p>Las ventajas son:</p> <ul> <li> <p>No es necesaria ninguna configuraci\u00f3n</p> </li> <li> <p>Es f\u00e1cil de compartir</p> </li> <li> <p>Podemos utilizar f\u00e1cilmente procesadores GPU (**G**raphics **P**rocessing **U**nit) que se diferencia del procesador \u201ccom\u00fan\u201d, el CPU (**C**entral **P**rocessing **U**nit) porque tiene m\u00e1s n\u00facleos, m\u00e1s especializados y por lo tanto permite realizar c\u00f3mputos m\u00e1s complejos de manera m\u00e1s r\u00e1pida.</p> </li> </ul> <p>En esta clase, utilizaremos una Notebook donde ya est\u00e1 implementado AlphaFold2.</p>","tags":["practicos"]},{"location":"practicos/TP12b_AlphaFold/#alphafold2-af2","title":"AlphaFold2 (AF2)","text":"<p>En los \u00faltimos a\u00f1os, hubo un crecimiento continuo en el n\u00famero de estructuras de prote\u00ednas determinadas experimentalmente depositadas en el PDB (actualmente ~170.000). Esto, junto con la explosi\u00f3n de la secuenciaci\u00f3n (millones de secuencias) y el desarrollo de t\u00e9cnicas de deep learning benefici\u00f3 el desarrollo de algoritmos de predicci\u00f3n de estructura tridimensional de prote\u00ednas. Hasta el 2021, los algoritmos de predicci\u00f3n de estructura tridimensional de prote\u00ednas se basan en dos aspectos complementarios: las interacciones f\u00edsicas (o contactos) o la historia evolutiva de la prote\u00edna. Sin embargo, y a pesar de los avances, la mayor\u00eda de los algoritmos de predicci\u00f3n no son muy precisos si se carece de un hom\u00f3logo cercano con una estructura tridimensional resuelta experimentalmente. A partir de la secuencia primaria de una prote\u00edna (Fig 1), AlphaFold2 utiliza una red neuronal para la predicci\u00f3n estructural de alta precisi\u00f3n (en la mayor\u00eda de los casos), la cual aumenta con el uso de estructuras hom\u00f3logas. AlphaFold2 puede incluso predecir con alta precisi\u00f3n las cadenas laterales si el backbone es preciso.</p> <p></p> <p>Fig 1. Algoritmo de predicci\u00f3n de estructuras AlphaFold2.</p> <p> </p>","tags":["practicos"]},{"location":"practicos/TP12b_AlphaFold/#arquitectura","title":"Arquitectura","text":"<p>AlphaFold2 utiliza una arquitectura de red que utiliza como inputs el alineamiento de secuencias (MSAs) y una representaci\u00f3n de todos los pares de residuos de la secuencia. Mediante un algoritmo iterativo que se basa en la arquitectura Evoformer, se procesan los inputs y en conjunto con un m\u00f3dulo estructural se genera una representaci\u00f3n tridimensional de la prote\u00edna query. </p>","tags":["practicos"]},{"location":"practicos/TP12b_AlphaFold/#metricas-de-confianza","title":"M\u00e9tricas de confianza","text":"<p>AlphaFold2 incorpora m\u00e9tricas de confianza de la predicci\u00f3n.</p> <ul> <li> <p>La principal m\u00e9trica de confianza es el test pLDDT (predicted local-distance difference test) el cual es un predictor confiable del test de diferencias en las distancias C\u03b1 (IDDT-C\u03b1) y eval\u00faa principalmente la correctitud del modelo a nivel local (estimando el error en distancias de un C\u03b1 con C\u03b1 vecinos en un rango de 15\u00c5).</p> </li> <li> <p>La segunda m\u00e9trica se denomina PAE (por Predicted Aligned error) y compara el error en la predicci\u00f3n de pares de residuos, esto es el error sobre el residuo y cuando las estructuras real y predicha son alineadas sobre el residuo x. Esta medida permite la identificaci\u00f3n global de unidades de plegamiento (dominios) y permite predecir si dos dominios guardan relaciones espaciales definidas, o si tienen variabilidad (por ejemplo, si est\u00e1n conectadas por un linker flexible.</p> </li> </ul> <p></p> <p></p> <p>Fig 2. Arriba. Se pueden observar dos dominios globulares, pero se desconoce la disposici\u00f3n espacial relativa entre ellos. Abajo. Se puede observar que adem\u00e1s de identificar los dominios globulares, se predien correctamente pares de residuos interdominios.</p> <p> </p>","tags":["practicos"]},{"location":"practicos/TP12b_AlphaFold/#costo-computacional","title":"Costo computacional","text":"<p>AlphaFold2 consume much\u00edsimos recursos. Por lo tanto, muchas prote\u00ednas de organismos modelos est\u00e1n siendo modeladas y puestas a disposici\u00f3n de la comunidad cient\u00edfica en una base de datos: https://alphafold.ebi.ac.uk/.</p> <p>Afortunadamente, la comunidad cient\u00edfica r\u00e1pidamente desarroll\u00f3 distintas \u201ccolabs\u201d o \u201cnotebooks\u201d que permiten correr AlphaFold2 en una m\u00e1quina remota. Una \u201cdesventaja\u201d es que se debe contar con una cuenta de mail de gmail, cada cuenta de gmail puede usar un colab a la vez.</p> <p>Otra desventaja es que en la versi\u00f3n gratuita de colab, debido al espacio en disco y capacidad de c\u00f3mputo que se adjudica, s\u00f3lo se pueden correr prote\u00ednas o complejos con menos de 1000 residuos y luego de estar corriendo unas cinco prote\u00ednas, hay que esperar a que se renueve el tiempo de c\u00f3mputo de esa cuenta. </p> <p>Otra desventaja, es que no se pueden modificar muchos par\u00e1metros del modelado al usar un colab, en comparaci\u00f3n con correr la simulaci\u00f3n desde un script en una computadora o server propio. Sin embargo, los par\u00e1metros usados en el ColabFold de AlphaFold2 son los que fueron m\u00e1s ampliamente validados durante el desarrollo del m\u00e9todo.</p> <p>Existen distintos colabs que implementan AlphaFold2. En este curso utilizaremos uno en particular: AlphaFold2 using MMseqs2.</p> <p>Todas las versiones de las distintas NoteBooks est\u00e1n disponibles en el github: https://github.com/sokrypton/ColabFold</p>","tags":["practicos"]},{"location":"practicos/TP12b_AlphaFold/#alphafold2-ejercicios","title":"AlphaFold2 - Ejercicios","text":"<p>Los papilomavirus (PVs) son virus desnudos icosa\u00e9dricos y poseen un genoma ADN doble cadena circular entre 5-8 Kb. Sus hospedadores incluyen una amplia variedad de vertebrados desde peces, reptiles, aves y mam\u00edferos. Los PV infectan el epitelio mucoso y queratinizado y producen lesiones denominadas condilomas o papilomas y verrugas respectivamente y en humanos algunos PVs est\u00e1n asociados al c\u00e1ncer cervical uterino, de la formaci\u00f3n de tumores en el tracto urogenital y en las v\u0131\u0301as a\u00e9reas superiores.</p> <p>La prote\u00edna E7 del papilomavirus comparte similitudes funcionales con la prote\u00edna E1A de adenovirus y el ant\u00edgeno T del poliomavirus SV40. Las tres prote\u00ednas poseen actividades transformantes e interaccionan con la prote\u00edna retinoblastoma.</p> <p>La interacci\u00f3n de la prote\u00edna E7 con Rb es responsable de la inducci\u00f3n de la s\u00edntesis de ADN y proliferaci\u00f3n celular. La inmortalizaci\u00f3n y transformaci\u00f3n de la c\u00e9lula infectada inducida por E7 es consecuencia de la interacci\u00f3n de E7 con Rb y numerosos blancos proteicos involucrados en crecimiento celular, transformaci\u00f3n, transcripci\u00f3n, apoptosis y s\u00edntesis de ADN.</p>","tags":["practicos"]},{"location":"practicos/TP12b_AlphaFold/#ejercicio-1-modelado-de-un-monomero-de-e7","title":"Ejercicio 1. Modelado de un Mon\u00f3mero de E7","text":"<ol> <li> <p>Ingrese al ColabFold que implementa MMseq2 Aqu\u00ed.</p> <p>Info</p> <pre><code>Si quiere que los cambios que realice sean guardados deber\u00e1 agregar la notebook a su drive. Pero esto no es necesario.\n</code></pre> </li> <li> <p>En la parte superior, haga click en Runtime \u2192 Change Runtime y aseg\u00farese que:</p> <ul> <li> <p>Runtime type: sea Python 3</p> </li> <li> <p>Hardware accelerator: este seleccionado T4 GPU</p> </li> </ul> </li> <li> <p>Preparando la corrida.</p> <p>En el campo sequence query ingrese la secuencia (sin el encabezado indicado por el signo <code>&gt;</code>) de la prote\u00edna E7 de HPV16.</p> <pre><code>&gt;sp|P03129|VE7_HPV16 Protein E7 OS=Human papillomavirus type 16 OX=333760 GN=E7 PE=1 SV=1\nMHGDTPTLHEYMLDLQPETTDLYCYEQLNDSSEEEDEIDGPAGQAEPDRAHYNIVTFCCKCDSTLRLCVQSTHVDIRTLEDLLMGTLGIVCPICSQKP\n</code></pre> <ul> <li> <p>En el campo jobname ingrese: E7_MONOMERO.</p> </li> <li> <p>En el campo num_relax elija: 1</p> </li> </ul> <p>Info</p> <p>num_relax es el n\u00famero de modelos a relajar con Amber. Esta notebook produce hasta 5 modelos m\u00e1ximo por prote\u00edna. </p> <p>Amber permite mejorar la geometr\u00eda de la uni\u00f3n pept\u00eddica y posici\u00f3n de rot\u00e1meros luego de la relajaci\u00f3n de la estructura. Si bien no mejora la predicci\u00f3n, remueve violaciones estereoqu\u00edmicas.</p> <ul> <li> <p>En template mode elija pdb100 \u00bfQu\u00e9 le parece que es este campo?</p> </li> <li> <p>Vaya a  Runtime \u2192  Run all, o presione <code>Ctrl</code>+<code>F9</code></p> </li> <li> <p>Como por defecto este ColabFold crea 5 modelos hay que esperar (unos 20 minutos).</p> </li> </ul> <p>IMPORTANTE</p> <p>No cierre la ventana y tampoco cierre la laptop porque la corrida entonces se detiene (no pasa nada si entra en suspensi\u00f3n).</p> <p>Al finalizar la corrida, los resultados ser\u00e1n descargados autom\u00e1ticamente como un archivo zip. Si esto no llegara a suceder, puede acceder al mismo haciendo click en el icono con forma de carpeta que se encuentra a la izquierda.</p> </li> <li> <p>Una vez que termin\u00f3 de correr, comience con el Ejercicio 2 (La corrida en AlphaFold2) y vuelva a este ejercicio.</p> </li> <li> <p>Localice el archivo descargado y descompr\u00edmalo (el nombre del archivo comienza con <code>E7_MONOMERO</code>). Encontrar\u00e1 varios archivos, en particular:</p> <ul> <li><code>Cite.bibtex</code> Contiene todas las citas correspondientes a los papers relacionados.</li> <li><code>Config.json</code> Contiene todos los par\u00e1metros utilizados en la corrida.</li> <li><code>*.a3m</code> Alineamiento</li> <li><code>*_coverage.png</code> Gr\u00e1fico de la cobertura del alineamiento</li> <li><code>*_PAE.png</code> Gr\u00e1fico del PAE por pares de residuos para todos los modelos.</li> <li><code>*_plddt.png</code> Gr\u00e1fico del plddt por posici\u00f3n</li> <li><code>*_predicted_aligned_error_v1.json</code> Tiene los valores de PAE para todos los pares de todos los modelos.</li> <li><code>*_relaxed_*_model_*.pdb</code> Son los modelos generados y relajados.</li> <li><code>*_unrelaxed_*_model_*.pdb</code> Son los 5 modelos generados sin relajar.</li> <li><code>*_model_*.json</code> Son el PAE y pLDDT de cada modelo que se pueden utilizar para graficar.</li> <li>En la carpeta<code>*_env*</code> Tiene los templados utilizados por AlphaFold2 si es que se usaron.</li> </ul> </li> <li> <p>Abra Chimera y cargue el modelo relajado (relaxed) (si no recuerda File \u2192 Open \u2026).</p> </li> <li> <p>Abra el pdb: 2b9d. (Puede descargalo realizando File \u2192 Fetch by ID o bien yendo a la web de la rcsb)</p> <ul> <li>\u00bfEstaba esta estructura entre los templados?</li> <li>\u00bfPor qu\u00e9 m\u00e9todo fue determinada?</li> <li>\u00bfA qu\u00e9 prote\u00edna corresponde? \u00bfDe qu\u00e9 organismo?</li> </ul> </li> <li> <p>Alinee las estructuras utilizando Matchmaker (si no recuerda, Tools \u2192 Structure comparison \u2192 Matchmaker)</p> <ul> <li>\u00bfCu\u00e1l es el RMSD global?</li> </ul> <p>Si quieren ver el RMSD por posici\u00f3n sobre la estructura</p> <p>Structure Comparison \u2192 Match align</p> <p>Seleccione el par de modelos adecuado. En residue-residue distance cutoff seleccione el mismo umbral que utiliz\u00f3 en Matchmaker para pruned atoms (Por defecto es 2)</p> <p>Para colorear la estructura por RMSD para eso vaya a: Tools \u2192 Depiction \u2192 Render by Attribute</p> <p>En attributes of aseg\u00farese que est\u00e9 seleccionado residues</p> <p>En el recuadro de Models aseg\u00farese que est\u00e9n ambos modelos seleccionados.</p> <p>En la pesta\u00f1a Render seleccione mavRMSDca y luego haga clic en <code>Ok</code>.</p> </li> <li> <p>Cierre el modelo correspondiente al pdb 2b9d. Via terminal tiene que ingresar el comando close seguido del n\u00famero del modelo, por ejemplo:</p> <pre><code>close #0\n</code></pre> <p>cierra el modelo 0.</p> <p>O bien, en el model panel, seleccione el modelo correspondiente y haga clic en close.</p> </li> <li> <p>Ahora abra los 4 modelos restantes, para eso, File \u2192 Open\u2026 y con el mouse seleccione los modelos manteniendo la tecla ctrl presionada.</p> </li> <li> <p>Alinee los modelos ranqueados de 2 a 5 contra el modelo 1, </p> <ul> <li>Explore el Reply log \u00bfcu\u00e1l es el RMSD global de cada par alineado?</li> </ul> </li> <li> <p>Utilice Match Align para ver el alineamiento. Recuerde utilizar el umbral adecuado!.</p> <ul> <li>\u00bfQu\u00e9 observa?</li> <li>\u00bfPorque si las secuencias son todas iguales no aparece el n-terminal alineado?</li> </ul> </li> <li> <p>Los valores de pLDDT est\u00e1n almacenados en la columna del pdb que corresponde a los b-factors. Para colorear por b-factors, utilizaremos la command line que Chimera trae integrada. Para esto vaya a: Favorites \u2192 Command line. En la parte inferior de la pantalla se abrir\u00e1 un rengl\u00f3n donde puede ingresar los comandos necesarios.</p> <p>Para colorear los modelos seg\u00fan el atributo b-factor donde est\u00e1 almacenado el plDDT ingrese en la command line:</p> <pre><code>rangecolor bfactor min orange red mid white max dodger blue\n</code></pre> <ul> <li>\u00bfQu\u00e9 observa?</li> </ul> <p>En el reply log se reportan los valores m\u00ednimo, medio y m\u00e1ximo encontrados en la columna de b-factors.</p> <ul> <li>\u00bfCu\u00e1les son el m\u00ednimo y el m\u00e1ximo?</li> </ul> <p>Ahora en lugar de que Chimera elija los valores observados como m\u00ednimo y m\u00e1ximo de la escala, los vamos a configurar con el siguiente comando:</p> <pre><code>rangecolor bfactor 0 orange red 50 white 100 dodger blue\n</code></pre> <p>Ahora cambie el valor m\u00ednimo a min (se elige el valor m\u00ednimo presente en la columna de b-factors) y el valor intermedio que antes era 50, a 70:</p> <pre><code>rangecolor bfactor min orange red 70 white 100 dodger blue\n</code></pre> <ul> <li>\u00bfObserva diferencias con lo anterior? \u00bfCu\u00e1les?</li> </ul> <p>Ahora corra:</p> <pre><code>rangecolor bfactor 50 orange red 70 white 100 dodger blue\n</code></pre> <ul> <li> <p>\u00bfObserva diferencias con lo anterior? \u00bfCu\u00e1les?</p> </li> <li> <p>\u00bfPorqu\u00e9 considera que elegimos 50 como valor m\u00ednimo?</p> </li> <li> <p>\u00bfDe qu\u00e9 posici\u00f3n a qu\u00e9 posici\u00f3n considerar\u00eda que el modelo es de confianza?</p> </li> </ul> </li> <li> <p>Investigue el gr\u00e1fico de pLDDT que se descarg\u00f3 con el modelo.</p> <ul> <li> <p>\u00bfQu\u00e9 observa?</p> </li> <li> <p>\u00bfPuede identificar las regiones con un pLDDT mayor a 70?</p> </li> <li> <p>\u00bfPuede identificar las regiones con un pLDDT entre 50 a 70?</p> </li> </ul> </li> <li> <p>Abra R Studio. Ahora graficaremos los pLDDT por posici\u00f3n para cada uno de los modelos.</p> <pre><code>install.packages(\"bio3d\")\ninstall.packages(\"reshape2\")\nlibrary(bio3d)\nlibrary(ggplot2)\nlibrary(reshape2)\n\nsetwd(*DIRECTORIO DE TRABAJO DESEADO*)\n\ndirectorio &lt;- \"/directorio/donde/estan/los/modelos/\"\n\narchivos &lt;- list.files(path = directorio,pattern = \"_unrelaxed_\",)\n\nmiarchivo &lt;- paste(directorio,archivos[1],sep=\"\")\nmipdb &lt;- read.pdb(miarchivo)\n\ndatos &lt;- data.frame(Residue = mipdb$atom[mipdb$calpha,\"resno\"],\n                    Rank_1 = mipdb$atom[mipdb$calpha,\"b\"]\n)\n\nfor(i in 2:length(archivos)){\n    miarchivo2 &lt;- paste(directorio,archivos[i],sep=\"\")\n    mipdb2 &lt;- read.pdb(miarchivo2)\n    nuevaColumna &lt;- paste(\"Rank\",i,sep=\"_\")\n    datos[nuevaColumna] &lt;- mipdb2$atom[mipdb2$calpha,\"b\"]\n}\n\nfileOUT &lt;- paste(directorio,\"E7_Monomero.png\",sep=\"\")\n\ndatos2 &lt;- melt(datos, id=\"Residue\")\ndatos2$variable &lt;- as.factor(datos2$variable)\n\np1 &lt;- ggplot(datos2, mapping=aes(x=Residue,y=value,color=variable)) + \ngeom_line() + theme_bw() +\nscale_x_continuous(name = \"E7 Residue\", breaks = seq(5,100,by=5),limits = c(0,100),expand=c(0,0)) +\nscale_y_continuous(name = \"Predicted lDDT\", breaks = seq(5,100,by=5),limits = c(0,101),expand=c(0,0)) +\ngeom_hline(yintercept = 90,color=\"blue\")+\ngeom_hline(yintercept = 70,color=\"orange2\")+\ngeom_hline(yintercept = 50,color=\"red\")\np1\n\nggsave(filename = fileOUT,plot = p1,device = \"png\",width = 20,height = 10,units = \"cm\",dpi = 300)\n</code></pre> </li> <li> <p>Encuentre el archivo corespondiente al gr\u00e1fico del PAE.</p> <ul> <li>\u00bfQu\u00e9 interpreta?</li> </ul> </li> <li> <p>En base a los resultados obtenidos, </p> <ul> <li>\u00bfQu\u00e9 puede decir de la estructura de la prote\u00edna?</li> <li>\u00bfCu\u00e1ntos dominios posee? \u00bfordenados o desordenados?</li> <li>\u00bfPuede decir aproximadamente los l\u00edmites?</li> </ul> </li> <li> <p>Guarde la sesi\u00f3n (Save Session As... ) y cierre chimera.</p> </li> </ol>","tags":["practicos"]},{"location":"practicos/TP12b_AlphaFold/#ejercicio-2-modelado-de-un-dimero-de-e7","title":"Ejercicio 2. Modelado de un d\u00edmero de E7","text":"<ol> <li> <p>En la parte superior, haga click en Runtime \u2192 Disconnect and delete Runtime</p> </li> <li> <p>Preparando la corrida.</p> <p>Para indicar que se quiere correr un mult\u00edmero se debe ingresar las secuencias separadas por <code>:</code>. En el campo sequence query ingrese las secuencias de la prote\u00edna E7 de HPV16. </p> <pre><code>MHGDTPTLHEYMLDLQPETTDLYCYEQLNDSSEEEDEIDGPAGQAEPDRAHYNIVTFCCKCDSTLRLCVQSTHVDIRTLEDLLMGTLGIVCPICSQKP:MHGDTPTLHEYMLDLQPETTDLYCYEQLNDSSEEEDEIDGPAGQAEPDRAHYNIVTFCCKCDSTLRLCVQSTHVDIRTLEDLLMGTLGIVCPICSQKP\n</code></pre> <ul> <li> <p>En el campo jobname ingrese: E7_DIMERO.</p> </li> <li> <p>En num_relax elija 1</p> </li> <li> <p>En template mode elija none</p> </li> <li> <p>Vaya a Runtime \u2192 Run all, o presione <code>Ctrl</code>+<code>F9</code></p> </li> <li> <p>Vuelta a esperar ... unos 20 minutos.</p> </li> </ul> <p>Atenci\u00f3n</p> <p>Antes de seguir adelante vaya al ejercicio 3 y ponga a correr el modelado siguiente!</p> </li> <li> <p>Abra Chimera. Y abra el pdb: 2F8B.</p> <p>Para eso ingrese en el command line:</p> <pre><code>open 2f8b\n</code></pre> <ul> <li> <p>\u00bfQu\u00e9 observa? \u00bfA qu\u00e9 se debe?</p> </li> <li> <p>Investigue en el rcsb la t\u00e9cnica por la que se obtuvo esta estructura y a qu\u00e9 prote\u00edna pertenece.</p> </li> <li> <p>\u00bfEste pdb es utilizado como templado para el modelado? \u00bfpor qu\u00e9?</p> </li> </ul> </li> <li> <p>Abra el model Panel: Favorites \u2192 Model Panel</p> <p>Para que sea m\u00e1s f\u00e1cil las observaciones vamos a trabajar con un \u00fanico submodelo de cada cadena. Para esto, ingrese en la l\u00ednea de comando:</p> <pre><code>close #0.2-15\n</code></pre> <ul> <li>\u00bfCu\u00e1l es el estado de oligomerizaci\u00f3n de E7?</li> </ul> </li> <li> <p>Coloree el modelo de blanco y oculte todos los residuos utilizando los siguientes comandos</p> <pre><code>color white #0\n~display\n</code></pre> </li> <li> <p>La prote\u00edna E7 en el dominio de dimerizaci\u00f3n contiene un sitio de uni\u00f3n a Zinc. Ubique el zn en la estructura.</p> <pre><code>display @ZN; color red @ZN\n</code></pre> <p>Ahora vamos a seleccionar los residuos m\u00e1s cercanos al zinc:</p> <pre><code>sel :@zn zr&lt;3\ndisplay sel; color red,a sel; color byhet sel;~sel\ndelete element.H\n</code></pre> <ul> <li>\u00bfQu\u00e9 residuos se encuentran coordinando la uni\u00f3n a zinc?</li> </ul> </li> <li> <p>Ubique el archivo zip que se gener\u00f3 con ColabFold y descompr\u00edmalo en su computadora. </p> </li> <li> <p>Identifique el archivo que corresponde al pLDDT.</p> <ul> <li>\u00bfQu\u00e9 regi\u00f3n est\u00e1 modelada con alta confianza y cual no?</li> </ul> </li> <li> <p>Identifique el archivo que corresponde al PAE.</p> <ul> <li>Interprete el gr\u00e1fico.</li> <li>\u00bfCu\u00e1l de los 4 gr\u00e1ficos muestra los valores correspondientes para los pares de residuos de la cadena A, cual para la cadena B y cual para los pares de residuos de de las cadenas A y B?</li> <li>\u00bfCu\u00e1les son los l\u00edmites el dominio globular, aproximadamente?</li> </ul> </li> <li> <p>Elija el modelo mejor mejor ranqueado y alineelo utilizando Matchmaker contra la estructura de 2F8B.</p> <ul> <li>\u00bfCu\u00e1l es el RMSD global?</li> </ul> </li> <li> <p>Abra en chimera los 5 modelos no relajados que se generaron. Luego, alinee utilizando matchmaker y seleccionaremos las ciste\u00ednas que coordinan la uni\u00f3n al zinc.</p> <pre><code>sel #1-5:58,61,91,94; display sel; color blue,a sel; color byhet sel; ~sel\n</code></pre> <p>Coloree las cadenas A y B de los modelos predichos de distinto color</p> <pre><code>sel #1-5:.A; color orange,r sel; ~sel\nsel #1-5:.B; color purple,r sel; ~sel\n</code></pre> <p>Observe de cerca la ubicaci\u00f3n de las ciste\u00ednas y responda:</p> <ul> <li>\u00bfConsidera que la predicci\u00f3n del sitio de uni\u00f3n de zinc es buena a\u00fan cuando no se incluye el i\u00f3n en el modelado?</li> </ul> </li> <li> <p>Coloree las cadenas de los modelos predichos seg\u00fan los valores de pLDDT.:</p> <pre><code>rangecolor bfactor 50 orange red 50 white 100 dodger blue\n</code></pre> <ul> <li>\u00bfQu\u00e9 observa?</li> </ul> <p>En base a todas las caracter\u00edsticas observadas: pLDDT, PAE, coordinaci\u00f3n de zinc,</p> <ul> <li> <p>\u00bfPudo AF2 predecir el estado de oligomerizaci\u00f3n?</p> </li> <li> <p>\u00bfPudo AF2 predecir la coordinaci\u00f3n del zinc?</p> </li> <li> <p>\u00bfQu\u00e9 opina del modelo?</p> </li> </ul> </li> <li> <p>Guarde la sesi\u00f3n y cierre chimera.</p> </li> </ol>","tags":["practicos"]},{"location":"practicos/TP12b_AlphaFold/#ejercicio-3-modelado-de-un-motivo-unido-a-un-dominio-globular-en-alphafold2","title":"Ejercicio 3. Modelado de un motivo unido a un dominio globular en Alphafold2","text":"<p>La prote\u00edna retinoblastoma (Rb) regula el avance del ciclo celular de la fase G1 \u2192 S. La prote\u00edna Rb posee un dominio globular llamado Dominio pocket que est\u00e1 formado por dos subdominios A y B unidos por un loop.</p> <p>Uno de los blancos celulares de Rb es la Histone desacetilasa 1 (HDAC) que posee el motivo lineal de interacci\u00f3n LxCxE. Sin embargo la afinidad de HDAC1 por Rb, es mucho menor (20\u00b5M) en comparaci\u00f3n a la afinidad del motivo de la prote\u00edna viral E7 de papilomavirus (5nM).</p> <p>Una estructura tridimensional permite entender desde el aspecto molecular las diferencias en las interacciones que podr\u00edan llevar a diferencias en afinidades. Sin embargo, hasta la fecha, no se posee una estructura del complejo Rb-HDAC1.</p> <ol> <li> <p>Modele el complejo utilizando el colab: AlphaFold2.</p> <p>Para tardar menos en el modelado vamos a realizar algunas modificaciones.</p> <p>En lugar de ingresar la secuencia completa de la prote\u00edna retinoblastoma, vamos a ingresar \u00fanicamente la correspondiente al dominio pocket de la prote\u00edna retinoblastoma, donde los loops se encuentran reemplazados por secuencias m\u00e1s cortas.</p> <p>Al final, indicaremos con el <code>:</code> el inicio de la cadena correspondiente al motivo HDAC (<code>DKRIACEEEFSD</code>).</p> <p>Obteniendo finalmente:</p> <pre><code>NTIQQLMMILNSASDQPSENLISYFNNCTVNPKESILKRVKDIGYIFKEKFAKAVGQGCVEIGSQRYKLGVRLYYRVMESMLKSEEERLSIQNFSKLLNDNIFHMSLLACALEVVMATYSRSTSQNLDSGTDLSFPWILNVLNLKAFDFYKVIESFIKAEGNLTREMIKHLERCEHRIMESLAWLSDSPLFDLIKQSKLVPRGSKSTSLSLFYKKVYRLAYLRLNTLCERLLSEHPELEHIIWTLFQHTLQNEYELMRDRHLDQIMMCSMYGICKVKNIDLKFKIIVTAYKDLPHAVQETFKRVLIKEEEYDSIIVFYNSVFMQRLKTNILQYASTRPPTLSPIPHIPR:DKRIACEEEFSD\n</code></pre> <ul> <li> <p>En num_relax elija 1.</p> </li> <li> <p>En template_mode elija: none.</p> </li> </ul> <p>Luego, corra todo con <code>ctrl+F9</code> o vaya a Runtime \u2192 Runall</p> </li> <li> <p>Abra el modelo relajado obtenido por AlphaFold2 en chimera.</p> </li> <li>Abra el pdb 1GUX</li> <li> <p>Alinee ambos complejos utilizando matchmaker.</p> <p>Los siguientes pasos se hacen en la command line de Chimera:</p> </li> <li> <p>Oculte las posiciones que se observan.</p> <pre><code>~display\n</code></pre> </li> <li> <p>Coloree por cadenas.</p> <pre><code>rainbow chain\n</code></pre> </li> <li> <p>Seleccione cada motivo y pongale un nombre (ojo, preste atenci\u00f3n a la numeraci\u00f3n de los modelos y los nombres de las cadenas, este comando es un ejemplo de como deber\u00eda ser)</p> <pre><code>sel #0:.E; namesel E7\nsel #1:.B; namesel HDAC\n</code></pre> </li> <li> <p>Represente ambos motivos en licorice (recuerde seleccionar cada cadena correspondiente antes!)</p> <pre><code>ribscale licorice E7\nribscale licorice HDAC\n</code></pre> </li> <li> <p>Elimine las aguas e hidr\u00f3genos ya que no los utilizaremos para analizar.</p> <pre><code>delete :HOH\ndelete element.H\n</code></pre> </li> <li> <p>Muestre las cadenas laterales de los motivos coloreando por heteroatomos.</p> <pre><code>display E7\ndisplay HDAC\ncolor byhet E7\ncolor byhet HDAC\n</code></pre> </li> <li> <p>Observe el modo de interacci\u00f3n, \u00bfSe encuentran conservado?</p> </li> <li> <p>\u00bfPor qu\u00e9 podr\u00eda tener m\u00e1s baja afinidad HDAC1 que E7?</p> </li> <li> <p>Coloree por b-factors el modelo obtenido por AlphaFold (Recuerde que contienen el plDDT y aseg\u00farese que su modelo es el indicado en el comando #1)</p> <pre><code>rangecolor bfactor 50 orange red 70 white 100 dodger blue #1\n</code></pre> <ul> <li>A ojo, \u00bfCu\u00e1l es la calidad del modelado del p\u00e9ptido que contiene el motivo (HDAC)?</li> </ul> </li> <li> <p>Investigue el gr\u00e1fico de PAE que se descarga con los modelos.</p> <ul> <li>\u00bfQu\u00e9 nivel de confianza observa en la ubicaci\u00f3n relativa del p\u00e9ptido HDAC respecto del dominio Rb?</li> </ul> </li> <li> <p>En base a las observaciones realizadas: \u00bfAlphaFold se puede utilizar para analizar la interacci\u00f3n de motivos con dominios globulares?</p> </li> </ol>","tags":["practicos"]},{"location":"practicos/TP12b_AlphaFold/#ejercicio-a-informar","title":"Ejercicio a informar","text":"<p>Fecha L\u00edmite de Entrega: Viernes, 27 de Octubre 2023, 23:59hs</p>","tags":["practicos"]},{"location":"practicos/TP12b_AlphaFold/#enunciado","title":"Enunciado","text":"<p>Su jefe sigue interesado en la prote\u00edna N que forma la nucleoc\u00e1pside viral de SARS-CoV2 y empaqueta el genoma viral de ARN formando una ribonucleoc\u00e1pside. Usted ya comprob\u00f3 que la estructura de la prote\u00edna N es altamente desordenada y posee dos dominios globulares peque\u00f1os en el N-terminal (Dominio N) y C terminal (Dominio C). Dada la importancia de la prote\u00edna en la replicaci\u00f3n viral, consideran que es un blanco posible de drogas. Por lo tanto, decide realizar un modelado por homolog\u00eda del dominio N-terminal de la prote\u00edna N del aislamiento original utilizando las herramientas que conoce.</p> <p>1. Modele por homolog\u00eda el dominio N-terminal. Eval\u00fae seg\u00fan las herramientas que conoce si su modelo es bueno y recuerde incluir el molde que seleccion\u00f3 para crearlo justificando la elecci\u00f3n e indicando a qu\u00e9 virus pertenece (incluir en el reporte el screenshot de la lista devuelta por HHPred porque los resultados var\u00edan).</p> <p>2. Elija una estructura contra la cual comparar\u00e1 su modelo y justifique brevemente la elecci\u00f3n. Recuerde reportar el RMSD global y que regiones alinean mejor.</p> <p>3. Usted sin embargo, es muy ambicioso y quiere obtener la estructura de la prote\u00edna completa. Modele utilizando AlphaFold2 la prote\u00edna N.</p> <p>4. Seg\u00fan los valores de pLDDT predichos por AlphaFold \u00bfque puede decir acerca de las distintas regiones de la prote\u00edna y la calidad del modelado? </p> <p>Recordatorio</p> <p>Para analizar la calidad del modelado deber\u00edan comparar su modelo contra un modelo conocido de cada dominio, pero el infomre se har\u00eda ya muy largo.</p> <p>6. Seg\u00fan los an\u00e1lisis realizados con ambas herramientas, si desear\u00eda cristalizar el dominio N \u00bfQu\u00e9 regiones no incluir\u00eda?</p> <p>Extra! (y por ende opcional)</p> <p>Compare el resultado de pLDDT con los predicho por IUPred2A.</p> <p>Distintas formas de hacerlo:</p> <p>1. Graficar en el mismo plot por posici\u00f3n los valores de IUpred y de plDDT</p> Pista <pre><code>ggplot(data=iupred) + \n    geom_line(mapping=aes(x=posicion,y=iupred)) +\n    geom_line(data=AlphaFold, mapping=aes(x=posicion, y=plddt))\n</code></pre> <p>2. Graficar en el eje x el valor de IUPred (va entre 0 y 1 donde 1 es desordenado) y en el eje y los valores de plDDT que van entre 0 (menor confianza o sea desordenado) y 100 (mayor confianza o sea ordenado). </p> Pista <p>Den vuelta los l\u00edmites del eje y y dividen los valores de plDDT por 100.</p> <p>\u00bfSon similares los perfiles de IUpred y plDDT?</p>","tags":["practicos"]},{"location":"practicos/TP12b_AlphaFold/#otros-recursos","title":"Otros Recursos","text":"","tags":["practicos"]},{"location":"practicos/TP12b_AlphaFold/#how-to-interpret-alphafold2-structures","title":"How to interpret AlphaFold2 structures","text":"<p>https://www.youtube.com/watch?v=UqeQfRDA8Yk</p>","tags":["practicos"]},{"location":"practicos/TP12b_AlphaFold/#alphafold-protein-structure-database","title":"AlphaFold Protein structure database","text":"<p>https://alphafold.ebi.ac.uk/</p>","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/","title":"Practico Introducci\u00f3n a la Programaci\u00f3n en R","text":"","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/#tpp-r-programando-en-biologia-parte-1","title":"TPP. R - Programando en biolog\u00eda - Parte 1","text":"<p> Slides </p> <p>Atenci\u00f3n: Este TP NO tiene informe.</p>","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/#software-a-usar","title":"Software a usar","text":"<ul> <li>R</li> <li>RStudio</li> </ul>","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/#recursos-online","title":"Recursos Online","text":"<ul> <li>Curso online de R de Coursera (se puede hacer gratis) (en ese caso no da certificado)</li> <li>R for Data Science (Libro de acceso gratuito)</li> <li>Tips de comandos b\u00e1sicos de R</li> <li>Data Tables: Introducci\u00f3n oficial y otra p\u00e1gina con m\u00e1s info</li> <li>ggplot2: Vistazo r\u00e1pido, otra p\u00e1gina con cada plot detallando sus par\u00e1metros y cheatsheet</li> </ul>","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/#objetivos","title":"Objetivos","text":"<ul> <li>Familiarizarse en el lenguaje de programaci\u00f3n R.</li> <li>Ver como los mismos conceptos de programaci\u00f3n se transladan de un lenguaje a otro.</li> <li>Utilizar herramientas de programaci\u00f3n para resolver problemas biol\u00f3gicos.</li> </ul>","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/#introduccion-a-r","title":"Introduccion a R","text":"<p>En este trabajo pr\u00e1ctico vamos a aprender R, uno de los lenguajes de programaci\u00f3n m\u00e1s utilizados hoy en d\u00eda al momento de analizar datos biol\u00f3gicos (junto a Python). Esto se debe a su practicidad al momento de leer, modificar o hacer estad\u00edstica con tablas de gran tama\u00f1o, asi como la gran variedad de figuras (o plots) que permite crear.</p> Un poco de historia <ul> <li> <p>En 1976 se crea S, un lenguaje de programaci\u00f3n dise\u00f1ado para an\u00e1lisis estad\u00edsticos. S fue creado en Bell Labs, que es el mismo lugar mismo lugar donde se creo Unix (pero por otras personas).</p> </li> <li> <p>En 1991, Ross Ihaka (estad\u00edstico) y Robert Gentleman (estad\u00edstico y bioinform\u00e1tico) empiezan a trabajar en una versi\u00f3n gratis y de c\u00f3digo abierto de S. Debido a sus nombres le ponen R a dicho lenguaje.</p> </li> <li> <p>La primera versi\u00f3n oficial de R fue publicada en 1995 bajo una licencia de c\u00f3digo abierto GNU General Public License. Esta licencia fue creada originalmente para el desarrollo de GNU y Linux, pero hoy en d\u00eda es muy com\u00fan al momento de distribuir programas gratis o de c\u00f3digo abierto.</p> </li> <li> <p>En 1997 se crea CRAN (Comprehensive R Archive Network), un repositorio oficial para R. Originalmente hab\u00eda solo 12 paquetes (los cuales agregaban nuevas funcionalidades a R), y a principios del 2022 ya exist\u00edan m\u00e1s de 18.500 diferentes paquetes de R en CRAN.</p> </li> </ul>","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/#rstudio-empezamos-con-el-tp","title":"RStudio - Empezamos con el TP","text":"<p>RStudio es el entorno de desarrollo o IDE (Integrated Development Environment) m\u00e1s conocido del lenguaje de programaci\u00f3n R y nos va a ayudar a programar en dicho lenguaje. Los IDEs son programas que permiten programar, encontrar errores (debuguear) y correr el script todo desde un mismo lugar. Adem\u00e1s, varios IDEs tambi\u00e9n ayudan en el proceso de programar, insertando estructuras vac\u00edas (ifs, fors) o autocompletando los comandos o par\u00e1metros mientras uno los escribe.</p> <p>Antiguamente los IDEs funcionaban casi exclusivamente para un solo lenguaje de programaci\u00f3n, pero los IDEs m\u00e1s recientes suelen funcionar para varios lenguajes (tras un poco de configuraci\u00f3n).</p> <p>1) Abran RStudio en sus computadoras (acceso directo en el escritorio, o desde Inicio Programaci\u00f3n RStudio).</p> <p>Importante</p> <p>Si les pregunta si quieren actualizar pongan \"Ignore Update\".</p> Si no est\u00e1n usando la M\u00e1quina Virtual de Introducci\u00f3n a la Bioinform\u00e1tica lean esto: <p>R y RStudio estan ya instalados en la m\u00e1quina virtual que les pasamos. Si no estas usando la m\u00e1quina virtual ten\u00e9s que instalar ambos siguiendo la gu\u00eda de la p\u00e1gina de RStudio.</p> <p>Tambi\u00e9n hay algunos paquetes de R ya instalados en la m\u00e1quina virtual que van a necesitar instalar cuando aparezcan en las gu\u00edas. Los paquetes se pueden instalar desde R corriendo por ejemplo:</p> <pre><code>install.packages(\"data.table\", repos=\"https://cloud.r-project.org\")\n</code></pre> <p>Diferentes versiones de R pueden llegar a usar diferentes versiones de paquetes (y algunos paquetes pueden no ser triviales de instalar en algunas versiones).</p> <p>RStudio se divide en 4 paneles, pero probablemente s\u00f3lo vean 3 ya que todav\u00eda no hemos abierto ning\u00fan archivo.</p> <p>2) Creen un nuevo script haciendo click en File New File R Script</p> <p>Ahora s\u00ed, deber\u00edan ver lo siguiente:</p> <p></p> <ul> <li>Paneles de R</li> </ul> Panel superior izquierdo: Editor de Scripts <p>En este panel est\u00e1 el script que acabamos de crear. Igual que en Bash, un script no es m\u00e1s que un archivo de texto con instrucciones para un lenguaje de programaci\u00f3n espec\u00edfico, que en este caso es R.</p> <p>Este panel puede contener varias pesta\u00f1as al mismo tiempo, cada una con un script diferente. Tambi\u00e9n puede contener pesta\u00f1as con visualizaciones de tablas..</p> Panel inferior izquierdo: Consola <p>La consola (pesta\u00f1a Console) es similar a la terminal, pero para el lenguaje de programaci\u00f3n R. En ella podemos escribir comandos en R directamente y ser\u00e1n corridos. Tamb\u00eden es donde vamos a ver la salida de nuestro script de correrlo dentro de RStudio.</p> Panel superior derecho: Variable <p>La pesta\u00f1a Environment tiene una lista de todas las variables cargadas en el \"entorno\" que est\u00e1n trabajando, o sea, todas las variables que crearon desde que abrieron RStudio (esto va a quedar m\u00e1s claro cuando corramos c\u00f3digo). </p> <p>De ser posible va a mostrar el valor de la variable y de no serlo va a mostrar alguna informaci\u00f3n al respecto (como el largo de una lista). Para el caso de tablas, pueden hacer click sobre ellas y se abrir\u00e1n en una nueva pesta\u00f1a del panel superior izquierdo.</p> <p>Tener esta lista de variables es muy \u00fatil para aprender a programar en R, as\u00ed como para encontrar errores (o debugear).</p> <p>La pesta\u00f1a History tiene una lista de los \u00faltimos comandos usados y la pesta\u00f1a Connections se usa para unir bases de datos. No vamos a utilizar ninguna de estas pesta\u00f1as en esta materia.</p> Panel inferior derecho: Archivos, Plots y Ayuda <p>La pesta\u00f1a Files es simplemente un explorador de archivos donde pueden navegar entre las carpetas disponibles y visualizar los archivos que encuentren. Es especialmente \u00fatil cuando estan trabajando en proyectos grandes con varios scripts.</p> <p>La pesta\u00f1a Plots es donde apareceran todos los gr\u00e1ficos que vayan generando (o plots). M\u00e1s adelante veremos m\u00e1s informaci\u00f3n sobre los diferentes botones de esta pesta\u00f1a.</p> <p>Desde la pesta\u00f1a Help podr\u00e1n acceder a toda la ayuda disponible de R y de todos los paquetes y funciones que quieran usar (similar a <code>man</code> en Bash). Pueden buscar informaci\u00f3n sobre una funci\u00f3n desde la caja de texto junto a la lupa o seleccionando dicho comando en el editor de scripts y apretando F1.</p> <p>La pesta\u00f1a Packages tiene informaci\u00f3n sobre los paquetes de R instalados y la pesta\u00f1a Viewer es usada para visualizar contenido web local. No vamos a utilizar ninguna de estas pesta\u00f1as en esta materia.</p> <p>Archivos .RHistory</p> <p>En la pesta\u00f1a Files pueden ver un archivo llamado .RHistory. Este es un archivo creado por RStudio que guarda los \u00faltimos comandos corridos (que pueden recorrer en la consola con Up y Down). Estos archivos pesan poco, pero se van a crear en varios directorios donde trabajemos con R. Si les molesta y no les importa guardar los \u00faltimos comandos usados pueden borrarlos sin problema.</p>","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/#programando-en-rstudio","title":"Programando en RStudio","text":"<p>Ahora que tenemos una idea de la interfaz de RStudio vamos a ver como se crean los programas.</p> <p>3) En la consola (pesta\u00f1a Console) escriban lo siguiente y aprieten Enter:</p> <pre><code>print(\"Hello World!\")\n</code></pre> <p><code>print</code> es equivalente al <code>echo</code> de bash y cuando lo usamos decimos que imprimimos a la variable. Puede ser que usemos las frases \"imprimir por terminal\", \"imprimir por consola\", o \"imprimir por por pantalla\" de forma intercambiable.</p> <p>Como muestra el c\u00f3digo anterior, en R los argumentos van pegados a la funci\u00f3n y entre par\u00e9ntesis; de haber mas de un argumento se separan con comas (dentro de los par\u00e9ntesis).</p> <p>Al correr el c\u00f3digo deber\u00edan ver algo como:</p> <pre><code>[1] \"Hello World!\"\n</code></pre> <p>El <code>[1]</code> lo est\u00e1 agregando RStudio y se debe a que en R todo es un vector, pero por ahora pueden ignorarlo.</p> <p>Lo que hicimos hasta ahora fue similar a correr un comando en la terminal. Vamos ahora a crear un script de R. </p> <p>4) En la editor de scripts (que deber\u00eda tener una p\u00e1gina vac\u00eda) escriban:</p> <pre><code>print(\"Hola Mundo!\")\n</code></pre> <p>Hay varias formas de ejecutar c\u00f3digo desde el editor de scripts, algunas de ellas son:</p> <ul> <li>Ejecutar una l\u00ednea: poner el cursor sobre la l\u00ednea a correr  Ctrl+Enter</li> <li>Ejecutar varias l\u00edneas: seleccionar o pintar las l\u00edneas a correr  Ctrl+Enter</li> <li>Ejecutar todas las l\u00edneas hasta el cursor: poner el cursor en la \u00faltima l\u00ednea que quiero correr  Ctrl+Alt+B</li> <li>Ejecutar todas las l\u00edneas en el script: Ctrl+Alt+R</li> </ul> <p>5) Elijan uno de los m\u00e9todos y corran la l\u00ednea que acabamos de escribir en el editor de scripts. Esto tambi\u00e9n lo pueden hacer a mano desde el men\u00fa Code, pero es recomendado usar los atajos de teclado ya que es algo que van a hacer bastante seguido mientras programan.</p> <p>6) Por \u00faltimo vamos a guardar nuestro script.</p> <ul> <li>Vayan a File Save (o aprieten Ctrl+S)</li> <li>Creen donde prefieran una carpeta para el TP</li> <li>Ponganle un nombre al script y gu\u00e1rdenlo</li> </ul> <p>Van a ver que Rstudio le agrega autom\u00e1ticamente la extensi\u00f3n .R, que es la extensi\u00f3n usada por los scripts de R y asocia autom\u00e1ticamente dichos scripts con RStudio.</p> <p>Tip - Ejecutando scripts de R desde la terminal</p> <p>Ahora que creamos un archivo en disco, es posible tambi\u00e9n ejecutar nuestro script de R desde la terminal. De querer hacerlo, tendr\u00edan que correr:</p> <pre><code>Rscript ARCHIVO_SCRIPT.R\n</code></pre> <p>Como siempre, reemplazando ARCHIVO_SCRIPT.R por el nombre de su archivo.</p>","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/#working-directory","title":"Working Directory","text":"<p>Establecer el directorio de trabajo antes de empezar a trabajar es una pr\u00e1ctica que nos va a ayudar a mantener nuestros archivos y scripts ordenados. El Working Directory es el path en donde estoy trabajando y compar\u00e1ndolo con lo que hicimos en Bash se puede pensar como en que carpeta est\u00e1 ahora la terminal.</p> <p>En R el comando para saber en que path estoy \"parado\" es la funci\u00f3n <code>getwd()</code>.</p> <p>Si quiero cambiar este path, tengo que usar la funci\u00f3n <code>setwd(\"PATH_ABSOLUTO\")</code>.</p> <p>1) Creen una carpeta donde van a trabajar, por ejemplo ~/Documentos/TP_08</p> <p>2) Usen la funci\u00f3n <code>getwd()</code> para ver el Working Directory actual</p> <p>3) Usen la funci\u00f3n <code>setwd()</code> para asignar la carpeta creada en 1) como Working Directory (recuerden que tienen que pasarle como par\u00e1metro el path absoluto de dicha carpeta)</p>","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/#r-variables","title":"R: Variables","text":"<p>Como dijimos cuando vimos Bash, diferentes lenguajes tienen elementos similares, pero se usan ligeramente diferente. Vamos a entonces a aprender como se usan las variables en R.</p> <p>1) Escriban en el editor de scripts la siguiente l\u00ednea y corranl\u00e1:</p> <pre><code>saludo &lt;- \"Hola Mundo!\"\n</code></pre> <p>En R las variables se asignan con el s\u00edmbolo <code>&lt;-</code> (o \"flecha a la izquierda\") y se usan mencionando el nombre de la variable. En RStudio se puede insertar el s\u00edmbolo <code>&lt;-</code> rapidamente usando el atajo de teclado Alt+- (signo \"menos\").</p> <p>\u00bfSe acuerdan de la pesta\u00f1a Environment de la que hablamos antes? Si la ven ahora va a tener la variable saludo y su valor.</p> <p>2) Agreguen entonces la siguiente l\u00ednea al editor de scripts y corran solo esta l\u00ednea:</p> <pre><code>print(saludo)\n</code></pre> <p>Est\u00e1n imprimiendo en la consola el valor de una variable que declararon previamente. Esto es un gran beneficio de RStudio, que nos permite guardar valores de variables y usarlos en el futuro, sin tener que correr todo el script de arriba a abajo cada vez que queremos modificar algo. Sin embargo, un gran poder conlleva una gran responsabilidad, ya que este sistema tambi\u00e9n hace posible estar usando un valor \"viejo\" o \"equivocado\" en una variable.</p> <p>La forma correcta de trabajar es ir dejando en nuestro script un registro de las \u00f3rdenes correctas para llegar al output deseado. Tambi\u00e9n es buena pr\u00e1ctica comentar las instrucciones m\u00e1s importantes para que se pueda entender por quien tenga que reutilizar el c\u00f3digo. Es algo as\u00ed como el cuaderno de laboratorio bioinform\u00e1tico.</p> <p>Poner solo el nombre de una variable es equivalente a hacer un <code>print</code>, o sea los siguiente dos comandos son equivalentes:</p> <pre><code>print(saludo)\nsaludo\n</code></pre> <p>Sin embargo, en el c\u00f3digo es recomendable usar <code>print</code> para dejar clara nuestra intenci\u00f3n y evitar ciertos escenarios donde la variable sola no funcionar\u00eda como queremos. Dicho esto, este m\u00e9todo es muy \u00fatil para ver r\u00e1pidamente lo que contiene una variable (hagan doble click en una variable, lo que la selecciona o pinta, y luego aprieten Ctrl+Enter).</p> <p>Asignar variables con =</p> <p>R tambi\u00e9n permite asignar variables usando el s\u00edmbolo <code>=</code>, por ejemplo, <code>a = \"Hola Mundo!\"</code> funcionar\u00eda perfecto en el c\u00f3digo anterior. Sin embargo, el s\u00edmbolo <code>=</code> tambi\u00e9n es el usado para pasar argumentos y es similar al usado en los condicionales, por lo que se recomienda usar el <code>&lt;-</code> al momento de asignar valores a variables en R.</p>","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/#comentarios","title":"Comentarios","text":"<p>Los comentarios en R se hacen de la misma forma que para Bash, ignorando todo lo que est\u00e1 despues de un <code>#</code>.</p> <pre><code>saludo &lt;- \"Hola Mundo!\"\n# saludo &lt;- \"Esto no va a hacer nada\"\n\nprint(saludo) # print(\"Esto tampoco\")\n</code></pre> <p>Tip - Comentar en masa</p> <p>Es posible comentar o descomentar grandes secciones de texto. Para esto hay que seleccionar o pintar las lineas y apretar Ctrl+Shift+C.</p>","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/#numeros","title":"N\u00fameros","text":"<p>En R hay 2 tipos principales de variables num\u00e9ricas, numeros enteros (o integer) y numeros reales (o numeric). Por temas de simplicidad, es bastante com\u00fan trabajar con variables del tipo numeric por m\u00e1s que esten usando n\u00fameros enteros (y de hecho es lo que hace R por defecto).</p> <p>3) Prueben correr el pr\u00f3ximo c\u00f3digo l\u00ednea a l\u00ednea y vean como se va modificando el valor de n en el Environment:</p> <pre><code>n &lt;- 2 # *n* es una variable *numeric*\n\n# pueden hacer diferentes operaciones matem\u00e1ticas con las variables num\u00e9ricas\nn &lt;- ((n + 2) * 2) ^ 2\n\nn &lt;- ((n - 2) / 2) ^ (1/2)\n\nprint(n)\n</code></pre> <p>Tip - Averiguar el tipo de una variable</p> <p>Si uno no sabe el tipo de una variable puede usar la funci\u00f3n <code>class()</code> la cual devuelve por consola el tipo de dicha variable. Por ejemplo, en este caso <code>class(n)</code> devolver\u00eda \"numeric\".</p> <p>Tipos de variables</p> <p>Si bien al momento de trabajar con R vamos a aceptar usar numeric incluso cuando trabajamos con integer, en otros lenguajes de programaci\u00f3n esta diferencia puede ser m\u00e1s estricta por lo que habr\u00eda que usar integer al trabajar con n\u00fameros enteros. Otro factor a considerar es que los integer ocupan menos tama\u00f1o en memoria, lo que puede ser relevante en ciertos casos.</p>","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/#cadenas-de-caracteres-o-strings","title":"Cadenas de caracteres o Strings","text":"<p>En R las cadenas de caracteres, comunmente llamadas strings, tienen el tipo de variable character.</p> <p>4) Prueben correr el pr\u00f3ximo c\u00f3digo l\u00ednea a l\u00ednea, lean los comentarios y vean como se va modificando el valor de la variable frase en el Environment:</p> C\u00f3digoC\u00f3digo con comentarios <pre><code>frase &lt;- \"Hab\u00eda\"\n\nfrase &lt;- paste(frase, \"una\")\n\nfrase &lt;- paste(frase, \"vez\", sep = \" \")\n\nfrase &lt;- paste(frase, \"...\", sep = \"\")\n\nprint(frase)\n</code></pre> <pre><code>frase &lt;- \"Hab\u00eda\" # *frase* es una variable *character*\n\n# paste es una funcion de R que concatena strings\nfrase &lt;- paste(frase, \"una\")\n\n# Las funciones de R tienen argumentos\n# *sep* es el argumento que indica que caracter va a ponerse entre las palabras que paste esta pegando\n# Varios argumentos en R tienen valores por defecto, que son el valor que van a tener si no los aclaro\n# En el caso de *sep*, el valor por defecto es \" \", por lo que en la siguiente linea podr\u00eda haberlo omitido\nfrase &lt;- paste(frase, \"vez\", sep = \" \")\n\n# Quiero agregar tres puntos, pero no quiero un espacio entre \"vez\" y los puntos\n# Uso la funcion paste y cambio el argumento *sep* al valor \"\" (que es el string vacio, lo que significa\n# no agregarle ningun separador)\nfrase &lt;- paste(frase, \"...\", sep = \"\")\n\nprint(frase)\n</code></pre> <p>Tip - paste0</p> <p>Tambi\u00e9n existe en R una funci\u00f3n llamada <code>paste0</code>, que es igual a <code>paste</code>, pero en la cual el valor por defecto de <code>sep</code> es <code>\"\"</code> (string vacio).</p> <p>Se pueden hacer muchas m\u00e1s cosas con strings en R, como por ejemplo extraer un substrings (<code>substr</code> o <code>substring</code>) o buscar si un substring existe dentro del string (<code>grep</code>, <code>grepl</code>, <code>gsub</code>), pero las vamos a ir viendo cuando las necesitemos.</p>","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/#ejercicio-1-variables-simples","title":"Ejercicio 1 - Variables simples","text":"<p>En este ejercicio vamos a practicar el uso de variables num\u00e9ricas y strings en R:</p> <ol> <li>Creen un nuevo script que declare 2 variables, asigne un n\u00famero a cada una, calcule la suma de ambos n\u00fameros y la imprima por la consola.</li> <li>Editen el script anterior agregando 2 otras operaciones matem\u00e1ticas e impriman sus resultados.</li> <li>En el mismo script, creen una nueva variable y as\u00edgnenle el valor 0. F\u00edjense que pasa si quieren dividir alguno de los otros n\u00fameros por esta nueva variable.</li> <li> <p>Creen un nuevo script que declare 2 variables, asigne un string a cada una, imprima la longitud de cada variable, concatene ambas variables (sin espacio entre ellas) e imprima la concatenaci\u00f3n.</p> <p>Para este \u00faltimo punto van a necesitar la funci\u00f3n <code>nchar()</code>. Pueden ver que hace desde la pesta\u00f1a Help.</p> </li> </ol> <p>Tip - Carpetas para los ejercicios</p> <p>Como ya mencionamos varias veces en la materia es recomendado utilizar diferentes carpetas para los diferentes TPs y Ejercicios. Esto es especialmente cierto al momento de trabajar con scripts de R ya que no es raro que un programa real tenga archivos de entrada (/input), archivos finales o de salida (/output) y archivos temporales (/temp). Por ahora probablemente no necesiten crear subcarpetas de este estilo, pero t\u00e9nganlo en cuenta.</p>","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/#r-vectores-y-plots","title":"R: Vectores y Plots","text":"","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/#vectores","title":"Vectores","text":"<p>R tiene la variable de tipo vector, que son vectores o arreglos, es decir, listas ordenadas de elementos de un mismo tipo. Vendr\u00edan a ser el equivalente de las listas que vimos de costado en Bash. Es importante ir aclarando que R tambi\u00e9n tiene variables del tipo list que vamos a ver en un rato, y que si bien son similares no son lo mismo.</p> <pre><code># Los vectores se declaran con c() y sus elementos se separan con \",\"\n\n# Este es un vector con 3 elementos de tipo *character*\nvector_frase &lt;- c(\"Hab\u00eda\", \"una\", \"vez...\") \n\n# Este es un vector con 10 elementos de tipo *numeric*\nvector_numeros &lt;- c(1,2,3,4,5,6,7,8,9,10) \n\n# Este vector es igual al anterior\n# R permite usar rangos al momento de definir vectores usando el simbolo \":\"\nvector_numeros_rango &lt;- c(1:10)\n\n# Este vector es igual al anterior\n# Escribir solo el rango tambi\u00e9n devuelve un vector\nvector_numeros_rango2 &lt;- 1:10\n\n# Es posible combinar \",\" y \":\"\n# Este vector tiene los valores c(1,2,3,7,8,9,10)\nvector_numeros_hueco &lt;- c(1:3,7:10)\n</code></pre> <p>Los vectores son una parte esencial de R; de hecho, la mayor\u00eda de las variables son vectores de l\u00f3ngitud 1 (raz\u00f3n por la que aparece el <code>[1]</code> al imprimirlas con <code>print</code>). Como consecuencia, la mayor\u00eda de las funciones u operaciones de R aceptan reemplazar n\u00fameros o strings por vectores de ellos.</p> <p>1) Ejecuten el c\u00f3digo anterior para crear los vectores y corran las siguientes l\u00edneas una a la vez. Vean que pasa en cada caso.</p> <pre><code>print(vector_frase)\n\nprint(vector_numeros)\n\nprint(vector_frase[2])\n\n# *paste* se puede usar tambien con vectores\n# En este caso no se usa *sep*, sino *collapse*, pero cumplen la misma funci\u00f3n\nprint(paste(vector_frase, collapse = \" \"))\n\nprint(vector_numeros + 2)\n\nprint(vector_numeros_rango * vector_numeros_rango)\n</code></pre> <p>Como pueden ver, en R se puede trabajar con vectores de una forma muy similar a que si trabajaramos con un solo n\u00famero o string, lo que abre la puerta a grandes posibilidades. Otra cosa a destacar de lo anterior es que es posible acceder a una variable individual del vector usando corchetes, donde por ejemplo <code>vector_frase[2]</code> es el segundo valor del vector <code>vector_frase</code>.</p> <p>\u00cdndices de los vectores</p> <p>En R el \u00edndice del primer elemento de los vectores, listas y tablas es el 1. En muchos lenguajes de programaci\u00f3n (incluyendo Python) el \u00edndice del primer item de un vector es el 0. Esto es algo que es importante acordarse de checkear cuando estas usando vectores en un nuevo lenguaje de programaci\u00f3n.</p> <p>Lo \u00faltimo que queremos volver a remarcar sobre los vectores es que son listas de elementos del mismo tipo. Sin embargo R probablemente no les tire un error si mezclan tipos de variables, sino que va a transformar autom\u00e1ticamente todas las variables a un mismo tipo.</p> <p>2) Vean que pasa al correr:</p> <pre><code>vector_mixto &lt;- c(1, 2, \"asd\")\nprint(vector_mixto) # Aca los n\u00fameros tienen comillas en el *print*, indicando que ya no son m\u00e1s n\u00fameros\nprint(vector_mixto[1] + 2) # Esto les va a tirar error ya que no puede sumar el n\u00famero 2 al *string* \"1\"\n</code></pre>","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/#plots-simples","title":"Plots simples","text":"<p>R tiene muchas formas de hacer plots, especialmente usando paquetes externos. Sin embargo, para empezar vamos a ver las formas que vienen por defecto con R, que si bien crean plots m\u00e1s simples, tambi\u00e9n son m\u00e1s f\u00e1ciles de usar y sirven para hacer una inspecci\u00f3n r\u00e1pida de sus datos.</p> <p>3) Creen un nuevo script, escriban el siguiente c\u00f3digo y corranl\u00f3:</p> <pre><code>x &lt;- c(1:100)\ny &lt;- x ^ 2\n\nplot(x, y)\n</code></pre> <p>Si todo funcion\u00f3 bien les deber\u00eda haber aparecido el siguiente plot en la pesta\u00f1a Plots del panel de abajo a la derecha (puede estar mas o menos achatado). La funci\u00f3n <code>plot</code> por defecto hace lo que se denomina \"dot plot\" o \"scatter plot\", donde dibuja un punto para cada valor <code>(x, y)</code>.</p> <p></p> <p>4) En unos minutos vamos a hablar de los botones de la ventana Plots, pero antes corran el siguiente c\u00f3digo:</p> <pre><code># rnorm es una funci\u00f3n que crea numeros random (o aleatorios) que siguen una distribuci\u00f3n normal\n# En este caso esta devolviendo 1000 n\u00fameros sacados de una distribuci\u00f3n normal con \n# media de 15 y un desv\u00edo est\u00e1ndar de 2.5\nvector_numeros &lt;- rnorm(mean = 15, sd = 2.5, n = 1000)\n\nhist(vector_numeros)\n</code></pre> <p>Si todo funcion\u00f3 bien el plot de la pesta\u00f1a Plots deber\u00eda haber cambiado al siguiente plot (como <code>rnorm</code> devuelve valores aleatorios puede no ser id\u00e9ntico). La funci\u00f3n <code>hist</code> hace un histograma de frecuencias a partir de un vector de valores.</p> <p></p> <p>En la pesta\u00f1a Plots hay varios botones que van a ser muy \u00fatiles al momento de trabajar con plots:</p> <ul> <li>Flechas hacia la izquierda y derecha: nos permiten navegar entre los \u00faltimos plots que creamos.</li> <li>Zoom: nos permite abrir una nueva ventana para ver una versi\u00f3n mas grande del plot.</li> <li>Export: nos permite salvar el plot a varios formatos de imagen (PNG, SVG, etc.) o a PDF. De trabajar con varios plots es com\u00fan salvar las im\u00e1genes desde el c\u00f3digo mismo, pero cuando se trabaja con pocas im\u00e1genes este m\u00e9todo es bastante \u00fatil.</li> <li>Remove the current plot: elimina el plot actual de la lista de plots guardados.</li> <li>Clear all Plots: vac\u00eda la lista de plots guardados.</li> </ul> <p>5) Prueben entonces salvar el plot actual como una imagen PNG usando el bot\u00f3n Export. En la ventana que les va a aparecer pueden cambiar el formato de la imagen y tambi\u00e9n su tama\u00f1o, ya sea ingresando el ancho (Width) y el alto (Height) o a mano usando el \"triangulo\" de abajo a la derecha (ver figura).</p> <p></p>","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/#ejercicio-2-vectores-y-plots","title":"Ejercicio 2 - Vectores y plots","text":"<p>Para valores enteros de <code>x</code> entre 1 y 200, calculen el <code>y</code> correspondiente a una recta con pendiente 3 y ordenada al origen 5 y hagan el plot de dicha recta usando el comando <code>plot</code>.</p> <p>Una vez creado el plot, guardenlo en un archivo con extensi\u00f3n SVG.</p> <p>Tip - Plotear una l\u00ednea</p> <p>Al momento de usar <code>plot</code> pueden agregar el par\u00e1metro <code>type = \"l\"</code> al final para que plotee l\u00edneas en vez de puntos.</p>","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/#r-estructuras-logicas","title":"R: Estructuras l\u00f3gicas","text":"","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/#condicionales-y-booleanos","title":"Condicionales y Booleanos","text":"<p>De igual forma que en Bash, en R tambi\u00e9n existen los condicionales ifs, pero se escriben ligeramente diferente:</p> C\u00f3digoC\u00f3digo con comentarios <pre><code>numero &lt;- 42\n\nprint(paste(numero, \"es un numero\"))\n\nif (numero &gt; 10) {\n    print(paste(numero, \"es mayor a 10\"))    \n} else {\n    print(paste(numero, \"es menor o igual a 10\"))\n}\n</code></pre> <pre><code>numero &lt;- 42\n\nprint(paste(numero, \"es un numero\"))\n\n# *if* es la estructura m\u00e1s usada para condicionales.\n# Adentro de los par\u00e9ntesis va la condici\u00f3n.\n# &gt; es el comparador, o sea, estamos preguntando si la variable *numero* es mayor que 10\nif (numero &gt; 10) {\n    # El codigo entre *{* y el primer *}* solo si ejecuta si la condici\u00f3n es verdad, de otra forma se saltea\n    # Este codigo esta m\u00e1s a la derecha, o *indentado*. Esto se hace con tab y en la mayor\u00eda de los lenguajes\n    # es solo para entender m\u00e1s f\u00e1cil el c\u00f3digo (RStudio lo va a hacer autom\u00e1ticamente de pegar c\u00f3digo)\n    print(paste(numero, \"es mayor a 10\"))    \n} else {\n    # El c\u00f3digo entre *else {* y *}* se ejecuta solo cuando la condici\u00f3n no es verdad\n    print(paste(numero, \"es menor o igual a 10\"))\n}\n# Este *}* indica donde termina el condicional\n</code></pre> <p>Es bastante similar a lo que conoc\u00edan, pero ac\u00e1 no esta then ni fi y los diferentes bloques l\u00f3gicos se marcan con llaves (en R esto tambi\u00e9n va a pasar en fors y en muchas otras estructuras).</p> <p>Las condiciones del if existen m\u00e1s alla de los condicionales y de hecho la comparaci\u00f3n <code>numero &gt; 10</code> es una variable en s\u00ed misma. A estas variables las vamos a llamar booleanos y pueden tener 1 de 2 valores: o TRUE (verdadero) o FALSE (falso).</p> <p>Hay 3 formas principales de generar variables booleanas:</p> <pre><code># D\u00e1ndoles el valor TRUE o FALSE a mano\nbooleano1 &lt;- TRUE\n\n# Usando un comparador, en este caso el *&gt;*\nnumero1 &lt;- 5\nbooleano2 &lt;- numero1 &gt; 10\n\n# Combinando booleanos con operadores l\u00f3gicos, en este caso con *and*\nbooleano3 &lt;- booleano1 &amp; booleano2\n</code></pre> <p>Como mostramos en la tercer forma de generar variables booleanas, se pueden hacer operaciones entre los booleanos usando la llamada algebra booleana. Esto es un mundo en s\u00ed mismo, pero por suerte al momento de programar solo nos van a importar las tres operaciones b\u00e1sicas de la algebra booleana: el AND, el OR y el NOT.</p> <p>El AND y el OR son operaciones entre dos booleanos, mientras que NOT es una operaci\u00f3n que se le aplica a un solo booleano.</p> <ul> <li>El AND es el \"Y\", devolviendo TRUE solo cuando ambos booleanos eran TRUE. Se escribe en R con &amp;</li> <li>El OR es el \"O\", devolviendo TRUE cuando por lo menos uno de ambos booleanos era TRUE. Se escribe en R con | (pipe)</li> <li>El NOT es el \"NO\", invirtiendo el valor del booleano (o sea, devuelve TRUE solo si el booleano era FALSE). Se escribe en R con !</li> </ul> Detalles de AND, OR y NOT Booleano1 Booleano2 AND (Booleano1 &amp; Booleano2) OR (Booleano1 | Booleano2) TRUE TRUE TRUE TRUE TRUE FALSE FALSE TRUE FALSE TRUE FALSE TRUE FALSE FALSE FALSE FALSE Booleano1 NOT (!Booleano1) TRUE FALSE FALSE TRUE <p>Las variables booleanas se pueden usar directamente en las condiciones de los ifs. Si bien se pueden comparar contra TRUE y FALSE, de poner solo la variable en la condici\u00f3n del if, es equivalente a preguntar si esa variable es TRUE. Vean las siguientes tres pesta\u00f1as para entenderlo mejor:</p> C\u00f3digoC\u00f3digo con comentariosC\u00f3digo - Versi\u00f3n m\u00ednima <pre><code>llueve &lt;- TRUE\ntengo_paraguas &lt;- TRUE\n\nif ((llueve == TRUE) &amp; (tengo_paraguas == FALSE)) {\n    print(\"Me mojo\")\n} else {\n    print(\"No me mojo\")\n}    \n</code></pre> <pre><code>llueve &lt;- TRUE\ntengo_paraguas &lt;- TRUE\n\nif ((llueve == TRUE) &amp; (tengo_paraguas == FALSE)) {\n    # Aca solo voy a entrar si llueve y no tengo paraguas\n    # Si una o ambas de esas afirmaciones son falsas, entonces se imprime el c\u00f3digo en el *else*\n    print(\"Me mojo\")\n} else {\n    print(\"No me mojo\")\n}\n</code></pre> <pre><code># T es equivalente a escribir TRUE\n# F es equivalente a escribir FALSE\nllueve &lt;- T\ntengo_paraguas &lt;- T\n\n# *llueve* es equivalente a *llueve == TRUE*\n# *!tengo_paraguas* es equivalente a *(!tengo_paraguas) == TRUE*, o sea, *tengo_paraguas == FALSE*\nif ((llueve) &amp; (!tengo_paraguas)) {\n    print(\"Me mojo\")\n} else {\n    print(\"No me mojo\")\n}\n</code></pre> <p>Par\u00e9ntesis en las condiciones</p> <p>En la versi\u00f3n m\u00ednima los par\u00e9ntesis internos no son estrictamente necesarios, es decir, que podr\u00edan haber puesto:</p> <pre><code>if (llueve &amp; !tengo_paraguas) {\n</code></pre> <p>De hecho, la versi\u00f3n del c\u00f3digo que tiene los <code>==</code> tambi\u00e9n andar\u00eda bien de sacarle los par\u00e9ntesis internos, pero esto es mucho m\u00e1s peligroso. Al momento de encadenar condiciones con AND (<code>&amp;</code>) u OR (<code>|</code>) les recomendamos poner cada condici\u00f3n entre par\u00e9ntesis para evitar errores, especialmente si las condiciones tienen <code>&lt;</code>, <code>&gt;</code>, <code>==</code>, etc.</p>","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/#ciclos","title":"Ciclos","text":"","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/#ciclo-for","title":"Ciclo For","text":"<p>En R todos los ciclos for tienen una estructura similar a lo que nosotros llamamos anteriormente ciclos for each. Se escribe de la siguiente forma:</p> C\u00f3digoC\u00f3digo con comentarios <pre><code>for (i in 1:10) {\n    print(i)\n}\n</code></pre> <pre><code># *for* es una de las estructuras m\u00e1s usadas para hacer ciclos\n# *i* es el nombre de la variable que va a cambiar de valor en cada ciclo. Se le podria poner cualquier nombre a \n# \u00e9sta variable, por ejemplo *numero* en nuestro caso, pero es costumbre ponele *i*\n# En este caso, *i* va a recorrer cada valor del rango 1:10 (es decir, del n\u00famero 1 al n\u00famero 10)\nfor (i in 1:10) {\n    # El c\u00f3digo entre las llaves se va a ejecutar una vez para cada posible *i* en el rango\n    print(i)\n}\n</code></pre> <p>En este caso el for va a recorrer todos los elementos de un vector de n\u00fameros que v\u00e1 entre 1 y 10 e imprimir el valor de i en cada ciclo. Tambi\u00e9n podemos recorrer en el for los elementos de un vector previamente declarado, por ejemplo:</p> C\u00f3digoC\u00f3digo con comentarios <pre><code>vector_colores &lt;- c(\"rojo\", \"amarillo\", \"verde\")\nfor (color in vector_colores) {\n    print(color)\n}\n</code></pre> <pre><code>vector_colores &lt;- c(\"rojo\", \"amarillo\", \"verde\")\nfor (color in vector_colores) {\n    # *color* es la variable que va cambiando en cada iteraci\u00f3n del *for* (como antes era *i*)\n    # En este caso va a ir tomando los valores de los diferentes elementos de *vector_colores*\n    print(color)\n}\n</code></pre>","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/#ciclo-while","title":"Ciclo While","text":"<p>El for es muy \u00fatil, pero tiene el problema de que uno necesita saber cuantas iteraciones va a realizar antes de empezar el ciclo, lo que no es siempre posible. Para casos donde desconocemos el n\u00famero de iteraciones, existen herramientas como el ciclo while que se puede pensar como una combinaci\u00f3n entre el for y el if. El c\u00f3digo dentro de este ciclo se va a repetir mientras se cumpla una condici\u00f3n. Por ejemplo:</p> C\u00f3digoC\u00f3digo con comentarios <pre><code>contador &lt;- 1\n\nwhile(contador &lt;= 10) {\n    print(contador)\n\n    contador &lt;- contador + 1\n}\n</code></pre> <pre><code># Estamos declarando una variable *contador* que vale 1\ncontador &lt;- 1\n\n# Todo lo que esta adentro del ciclo *while* se va a repetir mientras la condici\u00f3n *contador &lt;= 1000* sea TRUE\nwhile(contador &lt;= 10) {\n    # Imprimo la variable *contador* en la terminal\n    print(contador)\n\n    # Le sumo uno a la variable *contador*\n    # Esto es equivalente al *contador++* de Bash\n    contador &lt;- contador + 1\n}\n</code></pre> <p>Tal vez no se dan cuenta, pero este programa va a hacer lo mismo que el <code>for (i in 1:10)</code> que usamos arriba: La variable <code>contador</code> va a empezar en 1 y al final de cada ciclo va a aumentarse en 1 gracias al comando <code>contador &lt;- contador + 1</code>. Cuando <code>contador</code> llegue a 11, la condici\u00f3n <code>contador &lt;= 10</code> va a ser FALSE y el while va a terminar (es decir, el n\u00famero 11 nunca se imprime en la terminal).</p> <p>Ahora bien, para el caso anterior no tiene mucho sentido usar un ciclo while ya que se podr\u00eda haber hecho perfectamente con un for. Supongamos entonces que queremos escribir las potencias de 2 que son menores a 1.000, en ese caso podemos hacer:</p> C\u00f3digoC\u00f3digo con comentarios <pre><code>numero &lt;- 1\n\nwhile(numero &lt; 1000) {\n    print(numero)\n\n    numero &lt;- numero * 2\n}\n</code></pre> <pre><code># Declaro una variable *numero* con el valor 1 (que es 2^0)\nnumero &lt;- 1\n\n# El loop este va a seguir mientras *numero* sea menor a mil\nwhile(numero &lt; 1000) {\n    # Imprimo *numero* en la terminal\n    print(numero)\n\n    # Multiplico a *numero* por 2, lo que me va a dar la pr\u00f3xima potencia de 2\n    # 2^1 = 2\n    # 2^2 = 2 * 2 = 4\n    # 2^3 = 2 * 2 * 2 = 8 \n    # 2^4 = 2 * 2 * 2 * 2 = 16\n    # etc\n    numero &lt;- numero * 2\n}\n</code></pre> <p>Si bien hay formas de hacer este \u00faltimo loop con un for, esto es m\u00e1s que nada un ejemplo para que entiendan el concepto de que el while nos permite repetir algo una cantidad indeterminada de veces.</p> <p>Loops Infinitos</p> <p>Al usar el ciclo while hay que prestar mucha atenci\u00f3n de no escribir un c\u00f3digo que genere un loop infinito, es decir, un loop donde la condici\u00f3n del while siempre va a ser TRUE. Si pasa esto probablemente se cuelgue R y tendr\u00e1n que reiniciarlo o interrumpirlo para volver a programar. En el ejemplo anterior esto habr\u00eda ocurrido si no hubiesemos puesto la l\u00ednea que aumenta el valor de <code>numero</code>.</p>","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/#ejercicio-3-estructuras-logicas","title":"Ejercicio 3 - Estructuras l\u00f3gicas","text":"<p>El objetivo de este ejercicio es hacer un script de R que:</p> <ul> <li>Cree una variable llamada <code>resultado</code> y le asigne el valor 0</li> <li>Cree un for que defina una variable <code>i</code> que recorra los n\u00fameros de 1 a 50</li> <li>En cada iteraci\u00f3n vamos a sumarle o restarle algo a <code>resultado</code> (guardando el nuevo valor en <code>resultado</code>):<ul> <li>Para todo <code>i</code> menor a 5 o mayor a 47  Restarle <code>i</code> a <code>resultado</code></li> <li>Para todo <code>i</code> mayor a 20 y menor a 30  Sumarle <code>i</code> a <code>resultado</code></li> </ul> </li> <li>Imprima el valor final de <code>resultado</code> por la consola</li> </ul> <p>Tip</p> <p>Aca van a necesitar usar diferentes estructuras ifs adentro del for teniendo en cuenta que hay varias condiciones.</p>","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/#r-tablas","title":"R: Tablas","text":"","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/#data-frames","title":"Data Frames","text":"<p>El Data Frame es el tipo de variable que viene por defecto con R para usar tablas. Hay varias formas de crearlas, pero la m\u00e1s simple es con la funci\u00f3n <code>data.frame()</code>. Por ejemplo:</p> <pre><code>genes &lt;- c(\"ERT2\", \"TTR4\", \"REC1\")\nesencialidad &lt;- c(F, F, T)\nexpresiones &lt;- c(100 ,1000, 10000)\n\ndf &lt;- data.frame(gen = genes,\n                 esencial = esencialidad,\n                 expresion = expresiones)\n</code></pre> <p>Aca estamos creando una variable llamada <code>df</code> que contiene 3 columnas, gen, esencial y expresion, cada una conteniendo los valores de los vectores que declaramos previamente. Noten que los tres vectores tienen la misma cantidad de elementos. El primer elemento de cada vector corresponde a los valores de las columnas para la primera fila de la tabla, y as\u00ed.</p> <p>Tip</p> <p>Una cosa que les puede llamar la atenci\u00f3n es que pusimos los diferentes par\u00e1metros de la funci\u00f3n <code>data.frame</code> en tres l\u00edneas diferentes. Para R es equivalente poner todo en la misma l\u00ednea o como lo hicimos en el ejemplo anterior, lo que ayuda a leer m\u00e1s f\u00e1cil cada uno de los par\u00e1metros. Sin embargo, es importante notar que los saltos de l\u00ednea tienen que ir inmediatamente despu\u00e9s de una coma.</p> <p>Podemos ver los contenidos de la tabla usando el comando:</p> <p></p><pre><code>print(df)\n</code></pre> <pre><code>   gen esencial expresion\n1 ERT2    FALSE       100\n2 TTR4    FALSE      1000\n3 REC1     TRUE     10000\n</code></pre>","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/#data-tables","title":"Data Tables","text":"<p>Si bien los Data Frames tienen bastantes funcionalidades, existe un tipo de variable llamada Data Table que b\u00e1sicamente es un Data Frame con muchas mejoras, por lo que va a ser la variable que vamos a usar nosotros al momento de trabajar con tablas.</p> <p>El problema es que las variables Data Tables no vienen por defecto con R, sino que necesitamos usar un paquete externo llamado data.table. Este paquete de R ya est\u00e1 preinstalado en sus m\u00e1quinas virtuales, pero pueden ver como se instala de 0 en la secci\u00f3n RStudio al principio de esta guia.</p> <p>Por m\u00e1s que est\u00e9 instalado el paquete, es necesario cargarlo cada vez que abramos R. Es com\u00fan cargar al principio de cada script todos los paquetes que uno va a usar (no hay problemas al intentar cargar un paquete ya cargado):</p> <p></p><pre><code>install.packages(\"data.table\") #Esto instala el paquete data.table, solo lo tienen que hacer una vez en caso de que no lo tengan instalado\nlibrary(data.table) # Esto carga el paquete data.table para poder usar el tipo de variable Data Tables\n\ngenes &lt;- c(\"ERT2\", \"TTR4\", \"REC1\")\nesencialidad &lt;- c(F, F, T)\nexpresiones &lt;- c(100 ,1000, 10000)\n\ndt &lt;- data.table(gen = genes,\n                 esencial = esencialidad,\n                 expresion = expresiones)\n\nprint(dt)\n</code></pre> <pre><code>   gen esencial expresion\n1 ERT2    FALSE       100\n2 TTR4    FALSE      1000\n3 REC1     TRUE     10000\n</code></pre> <p>En los Data Tables vamos a usar el s\u00edmbolo <code>$</code> para acceder a las diferentes columnas (en cuyo caso va a devolver un vector con los contenidos de dicha columna):</p> <p></p><pre><code>print(dt$gen)\n</code></pre> <pre><code>[1] \"ERT2\" \"TTR4\" \"REC1\"\n</code></pre> <p>Por otro lado, podemos usar los corchetes <code>[]</code> de forma similar a como los usabamos en los vectores para devolver una fila espec\u00edfica.</p> <p></p><pre><code>print(dt[1])\n</code></pre> <pre><code>    gen esencial expresion\n1: ERT2    FALSE       100\n</code></pre> <p>Otra funci\u00f3n que les puede ser util es el comando <code>summary</code>, quien devuelve informaci\u00f3n de las diferentes columnas de la tabla:</p> <p></p><pre><code>summary(dt)\n</code></pre> <pre><code>     gen             esencial         expresion    \n Length:3           Mode :logical   Min.   :  100  \n Class :character   FALSE:2         1st Qu.:  550  \n Mode  :character   TRUE :1         Median : 1000  \n                                    Mean   : 3700  \n                                    3rd Qu.: 5500  \n                                    Max.   :10000\n</code></pre> Fijense que <code>summary</code> va a devolver informaci\u00f3n en base a que contiene la columna (gen tiene strings, por lo que devuelve info general; esencial tiene booleanos, por lo que devuelve la cantidad de cada uno; expresion tiene n\u00fameros, por lo que devuelve varios estad\u00edsticos). <p>Lo \u00faltimo que vamos a aprender hoy sobre Data Tables es a filtar filas, por ejemplo si quisieramos quedarnos solo con aquellas no esenciales ser\u00eda:</p> <p></p><pre><code>dt[esencial == FALSE]\n</code></pre> <pre><code>    gen esencial expresion\n1: ERT2    FALSE       100\n2: TTR4    FALSE      1000\n</code></pre> Algunas ventajas de Data Tables vs Data Frames <ul> <li>Lee tablas m\u00e1s r\u00e1pido</li> <li>L\u00edmita autom\u00e1ticamente la s\u00e1lida por terminal al usar <code>print()</code> con tablas muy grandes    </li> <li>Permite filtrar sin repetir el nombre de la tabla varias veces</li> <li>Tiene variables internas que facilitan calcular el n\u00famero de filas o el \u00edndice de cada fila</li> <li>Tiene funciones internas que permiten calcular promedio por grupos, por ejemplo</li> <li>\u00a1Y muchas m\u00e1s!</li> </ul>","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/#escribir-tablas","title":"Escribir Tablas","text":"<p>Hay varias funciones para escribir tablas, pero la que vamos a usar nosotros es <code>write.table</code>, por ejemplo:</p> <pre><code>write.table(dt, file = \"ARCHIVO_DT\", col.names = T, row.names = F, sep = \"\\t\", quote = T)\n</code></pre> <p>Los par\u00e1metros de <code>write.table</code> que estamos usando son:</p> <ul> <li><code>dt</code> es el Data Table que estamos guardando</li> <li><code>file</code> es donde se escribe el nombre del archivo. Si es un path absoluto se guarda en dicho path, y si es un path relativo es relativo al Working Directory<ul> <li><code>\"ARCHIVO_DT\"</code> suele tener extensi\u00f3n .tsv de separar las columnas con tabs, o extensi\u00f3n .csv de separarlas con comas</li> </ul> </li> <li><code>col.names</code> pregunta si queremos o n\u00f3 guardar el nombre de nuestras columnas en el archivo de salida (puede ser T o F)</li> <li><code>row.names</code> pregunta si queremos o n\u00f3 guardar el nombre de nuestras filas en el archivo de salida, el cual generalmente es el n\u00famero de fila (puede ser T o F)</li> <li><code>sep</code> indica cual es el separador de columnas. En este caso es <code>\"\\t\"</code>, es decir, Tab</li> <li><code>quote</code> indica si queremos colocar comillas bordeando a los strings que tengamos en la tabla. Puede ser T o F, o tamb\u00eden puede ser un vector num\u00e9rico que indica a las columnas a las que hay que ponerle comillas (con la primera siendo la n\u00famero 1)</li> </ul> <p>4) Existen algunas tablas en R que estan siempre cargadas en memoria y sirven para probar cosas. Una de estas tablas es iris. Usen <code>print</code> para ver esta tabla y luego usen <code>help(iris)</code> para ver la ayuda relacionada a esta tabla (que explica un poco las columnas).</p> <p>5) Guarden la tabla iris en un archivo llamado iris.tsv dentro de la carpeta creada al principio de esta gu\u00eda. Usen los par\u00e1metros usados en el ejemplo de arriba. Confirmen que se creo el archivo.</p> <p>Comillas en los archivos .tsv</p> <p>Si abren con Editor de Texto el archivo iris.tsv reci\u00e9n creado van a ver que los nombres de las columnas y todos los valores de la columna Species estan rodeados por comillas. Estas comillas no son parte de los nombres o valores de las columnas, sino que es la forma que usamos para indicar que lo que est\u00e1 dentro de ellas es un string. Estas comillas aparecen por haber usado el par\u00e1metro <code>quote = T</code> y son \u00fatiles para varios casos, por ejemplo de trabajar con strings con espacios.</p> <p>Data Tables y nombres de las filas</p> <p>Es medio t\u00e9cnico, pero a diferencia de los Data Frames, los Data Tables no pueden tener nombres en las filas (raz\u00f3n por la que estoy usando <code>row.names = F</code> en el c\u00f3digo anterior). Esta es una decisi\u00f3n consciente de los creadores de los Data Tables ya que cualquier informaci\u00f3n que uno quiera almacenar en los nombres de las filas tambi\u00e9n se puede almacenar en una nueva columna, lo que hace mucho m\u00e1s f\u00e1cil trabajar con esa informaci\u00f3n (filtrar, ordenar, etc).</p>","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/#leer-tablas","title":"Leer Tablas","text":"<p>Hay varias funciones para leer tablas, pero la que vamos a usar nosotros es <code>fread</code>, por ejemplo:</p> <pre><code>nuevo_dt &lt;- fread(\"ARCHIVO_DT\", header = T, sep = \"\\t\")\n</code></pre> <p>Esta funci\u00f3n es una de las funciones del paquete data.table. Los par\u00e1metros de <code>fread</code> que estamos usando son:</p> <ul> <li><code>nuevo_dt</code> es el nombre de la variable donde se va a cargar la tabla</li> <li><code>\"ARCHIVO_DT\"</code> es el nombre del archivo a leer. Si es un path absoluto se lee dicho path, y si es un path relativo es relativo al Working Directory</li> <li><code>header</code> pregunta si nuestro archivo tiene el nombre de nuestras columnas (puede ser T o F)</li> <li><code>sep</code> indica cual es el separador de columnas. En este caso es <code>\"\\t\"</code>, es decir, Tab</li> </ul> <p>6) Creen una variable llamada nuevo_dt_iris y carguen la tabla creada en el punto 5). Usen <code>print</code> para confirmar visualmente que se la tabla se ley\u00f3 bien.</p> <p>Info</p> <p>No se si lo notaron, pero de imprimir iris y nuevo_dt_iris por consola van a ver que se imprimen de forma ligeramente diferente. Esto se debe a que iris es un Data Frame (ya que viene por defecto con R), mientras que nuevo_dt_iris es un Data Table (por haber sido le\u00eddo con <code>fread</code>).</p>","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/#ejercicio-4-tablas","title":"Ejercicio 4 - Tablas","text":"<ol> <li>Creen un vector de 5 strings (cualquiera, pero no muy largos) y otro vector de 5 numeros (entre 1 a 10)</li> <li>Creen un Data Table con 2 columnas llamadas col1 y col2<ol> <li>col1 va a contener el vector de strings</li> <li>col2 va a contener el vector de numeros</li> </ol> </li> <li>Impriman por pantalla los valores de la columna col1</li> <li>Impriman por pantalla los valores de la tercera fila de la tabla</li> <li>Impriman por pantalla el valor de col2 de la cuarta fila de la tabla</li> <li>Impriman por pantalla todas las filas donde col2 sea menor o igual a 7</li> </ol>","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/#r-funciones","title":"R: Funciones","text":"<p>Como ya mencionamos cuando hablamos de los ciclos, es com\u00fan en programaci\u00f3n querer realizar una tarea varias veces en condiciones ligeramente diferentes. Otra herramienta que tenemos a nuestra disposici\u00f3n son las funciones, que ademas de ser parte de R y de los paquetes, pueden ser creadas por nosotros desde 0.</p> <p>Supongamos que por alguna raz\u00f3n es com\u00fan para nosotros querer calcular \\(y = 2x + x^2\\), podemos entonces hacer:</p> <pre><code>myFunction &lt;- function(x) {\n    output &lt;- 2 * x + x ^ 2\n\n    return(output)\n}\n\nx1 &lt;- 5\nx2 &lt;- 7\nvector_x3 &lt;- c(1:100)\n\ny1 &lt;- myFunction(x = x1)\ny2 &lt;- myFunction(x = x2)\nvector_y3 &lt;- myFunction(x = vector_x3)\n\n# Ya que estamos hacemos un plot de los vectores (a x1, x2, y1 e y2 no los estoy usando para nada por ahora)\nplot(x = vector_x3, y = vector_y3)\n</code></pre> <p></p> <p>Si bien en este caso puede no ser super necesario, van viendo como me ahorro bastante c\u00f3digo al usar funciones. Imaginenese ahora si lo que est\u00e1 adentro de la funci\u00f3n es algo mas complejo que ocupa 20 l\u00edneas de c\u00f3digo.</p> <p>Tambi\u00e9n es posible darle m\u00e1s de un par\u00e1metro a una funci\u00f3n, por ejemplo:</p> <pre><code>myFunction &lt;- function(x, exp = 2) {\n    output &lt;- 2 * x + x ^ exp\n\n    return(output)\n}\n\nx1 &lt;- 5\nx2 &lt;- 7\nvector_x3 &lt;- c(1:100)\n\n# El parametro *exp* tiene por defecto el valor 2\n# Estas dos lineas de c\u00f3digo devuelven lo mismo\ny1 &lt;- myFunction(x = x1)\ny1 &lt;- myFunction(x = x1, exp = 2)\n\ny4 &lt;- myFunction(x = x2, exp = 4)\nvector_y5 &lt;- myFunction(x = vector_x3, exp = 10)\n\nplot(x = vector_x3, y = vector_y5)\n</code></pre> <p></p>","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/#r-plots-mas-complejos","title":"R: Plots m\u00e1s complejos","text":"<p>Si bien la funciones <code>plot</code> e <code>hist</code> se pueden usar para hacer muchos tipos de plots, la mayor\u00eda de los plots hechos por R que uno puede llegar a ver en papers o similar estan hechos con paquetes de R que se especializan en plots.</p> <p>El paquete <code>ggplot2</code> es uno de los m\u00e1s usados, debido a su gran variedad de plots y a que le permite al usuario modificar practicamente cualquier detalle del plot (con m\u00e1s o menos dificultad).</p> <p>1) La funci\u00f3n principal del paquete <code>ggplot2</code> se llama <code>ggplot</code> y com\u00fanmente es usada con Data Frames o Data Tables. Entonces, corran el siguiente c\u00f3digo que usa la tabla iris para hacer un ejemplo de un plot simple con <code>ggplot</code>:</p> <pre><code>install.packages(\"ggplot2\")\nlibrary(ggplot2)\n\nggplot(data = iris, aes(x = Sepal.Length, y = Petal.Length)) +\n    geom_point()\n</code></pre> <ul> <li><code>data</code> es el par\u00e1metro que indica la tabla de la que se va a sacar la informaci\u00f3n</li> <li><code>aes</code> es una subfunci\u00f3n a la que le pasamos cual columna es el <code>x</code> y cual el <code>y</code></li> <li><code>geom_point()</code> est\u00e1 indicando uno de los varios plots posibles con ese <code>x</code> e <code>y</code>, en este caso es un \"dot plot\" o \"scatter plot\"</li> <li>Si bien es medio extra\u00f1o, las diferentes opciones que le pasamos a <code>ggplot</code> se van a unir con el signo <code>+</code></li> </ul> <p>2) Existen varias otras funciones de plots y cada una de ellas tiene sus propios par\u00e1metros. Vean como cambia el plot el siguiente c\u00f3digo:</p> <pre><code>ggplot(data = iris, aes(x = Sepal.Length, y = Petal.Length)) +\n    geom_point(shape = 3, color = \"red\") +\n    geom_line(linetype = \"dashed\", color = \"blue\", alpha = 0.25)\n</code></pre> <p>Como dijimos antes hay muchas funciones de ploteo, cada una con muchos par\u00e1metos posibles. Lo m\u00e1s normal al usar <code>ggplot</code> es googlear el uso espec\u00edfico que uno quiere hacer en ese momento y ver c\u00f3mo se hace.</p> <p>3) El siguiente c\u00f3digo es un ejemplo m\u00e1s \"completo\" de un plot hecho con <code>ggplot</code>. Corran el siguiente c\u00f3digo y vean el plot. Fijense si pueden inferir en base a su nombre que hacen algunos de los par\u00e1metros que le pasamos a <code>ggplot</code> (pueden ver el cheatsheet):</p> C\u00f3digoC\u00f3digo con comentarios <pre><code>ggplot(data = iris, aes(x = Sepal.Length, y = Petal.Length, color = Species)) +\n    geom_point(size = 1.5) +\n    xlim(c(1, 8)) +\n    ylim(c(1, 8)) +\n    theme_bw() +\n    xlab(\"Sepal Length\") +\n    ylab(\"Petal Length\") +\n    ggtitle(\"Sepal vs Petal Length per Species\") +\n    theme(plot.title = element_text(size = 16, hjust = 0.5),\n        axis.title = element_text(size = 14),\n        axis.text = element_text(size = 12)) +\n    scale_color_discrete(labels = c(\"Setosa\", \"Versicolor\", \"Virginica\"))\n</code></pre> <pre><code>ggplot(data = iris, aes(x = Sepal.Length, y = Petal.Length, color = Species)) +\n    #con data especifico la tabla que voy a graficar\n    #en aes selecciono las columnas para los datos en los ejes x e y, \n    #tambien determino que columna se va a usar para colorear los puntos\n    geom_point(size = 1.5) +\n    #tama\u00f1o del punto\n    xlim(c(1, 8)) +\n    ylim(c(1, 8)) +\n    #limites de los ejes\n    theme_bw() +\n    #tema del grafico\n    xlab(\"Sepal Length\") +\n    ylab(\"Petal Length\") +\n    #etiquetas de los ejes\n    ggtitle(\"Sepal vs Petal Length per Species\") +\n    #titulo del grafico\n    theme(plot.title = element_text(size = 16, hjust = 0.5),\n            axis.title = element_text(size = 14),\n            axis.text = element_text(size = 12)) +\n    #personalizo el titulo y los ejes\n    scale_color_discrete(labels = c(\"Setosa\", \"Versicolor\", \"Virginica\"))\n    #agrego etiquetas a la leyenda\n</code></pre> <p></p>","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/#r-variables-mas-complejas","title":"R: Variables m\u00e1s complejas","text":"","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/#factores","title":"Factores","text":"<p>Los factores son un tipo de variable que es usada para cuando tenemos variables categ\u00f3ricas, por ejemplo la columna Species en la tabla iris que vimos anteriormente era una variable de tipo factor. Para entenderlo mejor supongamos que tenemos 5 individuos que fueron tratados con diferentes niveles de una droga y mostraron diferentes resultados. Queremos entonces plotear boxplots mostrando los resultados por cada nivel de tratamiento:</p> <p>1) Prueben correr el pr\u00f3ximo c\u00f3digo y vean si funciona (spoiler: no va a funcionar).</p> <pre><code>niveles_tratamiento &lt;- c(\"bajo\", \"medio\", \"alto\", \"alto\", \"bajo\")\nresultados_tratamiento &lt;- c(2, 5, 8, 9, 4)\n\nplot(x = niveles_tratamiento, y = resultados_tratamiento)\n</code></pre> <p>El problema con el c\u00f3digo anterior es que <code>plot</code> no sabe que hacer cuando uno le pasa un vector de strings, es decir, no entiende que son categor\u00edas. Necesitamos entonces transformar nuestros datos en factores.</p> <p>2) Vean que pasa de correr el siguiente c\u00f3digo:</p> <pre><code>niveles_tratamiento &lt;- c(\"bajo\", \"medio\", \"alto\", \"alto\", \"bajo\")\nresultados_tratamiento &lt;- c(2, 5, 8, 9, 4)\n\nfactor_niveles_tratamiento &lt;- factor(niveles_tratamiento)\n\nplot(x = factor_niveles_tratamiento, y = resultados_tratamiento)\n</code></pre> <p>En este momento aunque sea vemos un plot, pero si se fijan en el eje X tenemos un problema: los niveles de tratamiento no est\u00e1n en un \u00f3rden l\u00f3gico. Cuando uno crea factores puede asignar este orden a mano.</p> <p>3) Cambien entonces el c\u00f3digo anterior al c\u00f3digo siguiente y corranl\u00f3:</p> <pre><code>niveles_tratamiento &lt;- c(\"bajo\", \"medio\", \"alto\", \"alto\", \"bajo\")\nresultados_tratamiento &lt;- c(2, 5, 8, 9, 4)\n\nfactor_niveles_tratamiento &lt;- factor(niveles_tratamiento, levels = c(\"bajo\", \"medio\", \"alto\"))\n\nplot(x = factor_niveles_tratamiento, y = resultados_tratamiento)\n</code></pre> <p>Como ven el par\u00e1metro <code>levels</code> nos permite indicar a mano el orden de los factores.</p> <p>4) Impriman por consola a niveles_tratamiento y a factor_niveles_tratamiento y vean las diferencias.</p> <p>Factores y ggplot2</p> <p>La funci\u00f3n <code>ggplot</code> transforma lista de strings a factores automaticamente al momento de plotear, por lo que no va a dar error de haber usado niveles_tratamiento (en una columna de un Data Table). Sin embargo, los factores siguen siendo \u00fatiles en estos casos para controlar el \u00f3rden en los que se plotean las variables categ\u00f3ricas.</p> <p>Estructura interna de los factores</p> <p>Esto es un poco t\u00e9cnico, pero otro beneficio de los factores es que ahorran memoria. Esto se debe a que en realidad no se guardan como una lista de strings, sino que R le asigna un n\u00famero a cada <code>level</code> y eso es lo que realmente guarda para todos los datos. Esto se puede ver con la funci\u00f3n <code>as.numeric()</code>:</p> <p></p><pre><code>as.numeric(factor_niveles_tratamiento)\n</code></pre> <pre><code>[1] 1 2 3 3 1\n</code></pre>","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/#listas","title":"Listas","text":"<p>El concepto de las listas es similar al de los vectores, solo que las listas pueden contener elementos de diferentes tipos (incluyendo vectores, plots, tablas u otras listas). Sin embargo, las listas son estructuras un poco m\u00e1s complejas, por lo que de querer multiplicar cada elemento de una lista por dos no alcanza con hacer <code>lista * 2</code>.</p> <p>Las listas se crean de la siguiente forma:</p> <pre><code>lista_numeros &lt;- list(3,4,7,13,45.3)\nlista_strings &lt;- list(\"hola\",\"chau\",\"perro\")\nlista_mixta &lt;- list(3,4,7,\"perro\")\n</code></pre> <p>Si bien los nombres indicar\u00edan que creamos tres \"tipos\" de lista, en realidad a las listas les da lo mismo si todos sus elementos son del mismo tipo o no. </p> <p>5) Impriman por pantalla a la <code>lista_mixta</code>. Deber\u00edan ver lo siguiente:</p> <pre><code>[[1]]\n[1] 3\n\n[[2]]\n[1] 4\n\n[[3]]\n[1] 7\n\n[[4]]\n[1] \"perro\"\n</code></pre> <p>Hay 2 cosas de inter\u00e9s. Primero que cada elemento esta en su propia fila con un encabezado con su \u00edndice <code>[[i]]</code>, y segundo que los n\u00fameros aca no tienen comillas (como pasaba en los vectores al mezclar tipos de datos) por lo que siguen siendo n\u00fameros.</p> <p>Como sospecharan por los \u00edndices que aparecen, al momento de querer un elemento espec\u00edfico de una lista hay que usar doble corchete, por ejemplo:</p> C\u00f3digoC\u00f3digo con comentarios <pre><code>lista_super_mixta &lt;- list(3,4,7,\"perro\",c(20:30))\n\nprint(lista_super_mixta[[1]])\n\nprint(lista_super_mixta[[2]] + lista_super_mixta[[3]]) \n\nprint(lista_super_mixta[[5]][7])\n</code></pre> <pre><code>lista_super_mixta &lt;- list(3,4,7,\"perro\",c(20:30))\n\n# Imprimo el primer elemento de la lista\nprint(lista_super_mixta[[1]])\n\n# Esto funciona por ser una lista. Si fuera un vector mixto los n\u00fameros se habr\u00edan transformado en *strings*\n# y tirar\u00eda un error al tratar de sumarlos\nprint(lista_super_mixta[[2]] + lista_super_mixta[[3]]) \n\n# El quinto elemento de la lista es un vector conteniendo los n\u00fameros de 20 a 30\n# Estoy imprimiendo el s\u00e9ptimo elemento de dicho vector\nprint(lista_super_mixta[[5]][7])\n</code></pre> <p>Si bien las listas tienen sus usos, en esta materia nos vamos a enfocar m\u00e1s en usar vectores. Dicho esto, existen funciones de R que van a devolver listas por defecto. Para transformar estas listas en vectores pueden usar la funci\u00f3n <code>unlist</code>. </p> <p>6) Prueben usar <code>unlist</code> con la variable <code>lista_super_mixta</code> y vean que pasa.</p>","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/#averiguar-el-tipo-de-las-variables","title":"Averiguar el tipo de las variables","text":"<p>Muchas veces queremos operar con variables y obtenemos errores puesto que son de un tipo distinto al que esper\u00e1bamos. \u00bfC\u00f3mo podemos averiguar entonces de que tipo son las variables? Sabemos que si tienen comillas es texto, pero esto no alcanza.</p> <p>La forma correcta de saber que tipo de variable es una variable es usando las funciones <code>class()</code> o <code>typeof()</code>. No vamos a detallar mucho estas funciones, pero <code>class()</code> suele devolver el nombre de la variable a la que estamos acostumbrados (numeric, factor, etc), mientras que <code>typeof()</code> devuelve como se almacena esa variable internamente.</p> <p>7) Vean que devuelve <code>class()</code> y <code>typeof()</code> para las siguientes variables (en algunos casos <code>typeof()</code> va a ser un poco raro):</p> <pre><code>library(data.table)\n\nnumero &lt;- 2\ncadena &lt;- \"uno dos tres\"\nbooleano &lt;- TRUE\nvector_numeros &lt;- c(1, 2, 3)\nvector_strings &lt;- c(\"uno\", \"dos\", \"tres\")\ndf &lt;- data.frame(numeros = vector_numeros, strings = vector_strings)\ndt &lt;- data.table(numeros = vector_numeros, strings = vector_strings)\nfactor_vector_strings &lt;- factor(vector_strings, levels = c(\"dos\", \"tres\", \"uno\"))\n\nclass(numero)\ntypeof(numero)\n</code></pre>","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/#ejercicio-adicional-1","title":"Ejercicio Adicional 1","text":"<p>En este Ejercicio vamos a ver si los n\u00fameros aleatorios de R se portan como deber\u00edan. Para esto vamos a hacer un script que:</p> <ul> <li>Tire una moneda</li> <li>Anote si sali\u00f3 cara o seca</li> <li>Repita los pasos anteriores hasta tener 100 caras o 100 secas (o dicho de otra forma, repita los pasos mientras no tenga 100 caras ni 100 secas)</li> <li>Imprima por pantalla cuantas secas y cuantas caras obtuvo (usar <code>paste</code> para que que en la salida se entienda bien que n\u00famero corresponde a quien)</li> </ul> <p>Una cosa que van a necesitar para hacer esto es la siguiente funci\u00f3n:</p> <pre><code>moneda &lt;- sample(x = c(\"Cara\", \"Seca\"), size = 1)\n</code></pre> <p>Donde <code>sample</code> devuelve un sampleo al azar de <code>size</code> elementos (en este caso <code>1</code>) del vector <code>x</code> (en este caso <code>c(\"Cara\", \"Seca\")</code>). En definitiva esto quiere decir que cada vez que ejecuten esa l\u00ednea <code>moneda</code> va a recibir el valor \"Cara\" o el valor \"Seca\" al azar.</p> <p>Ejecuten el c\u00f3digo anterior varias veces y vean si los n\u00fameros aleatorios funcionan bien en R o si est\u00e1 todo arreglado.</p>","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/#ejercicio-adicional-2","title":"Ejercicio Adicional 2","text":"<p>En este ejercicio vamos a crear, parecido a lo que vimos en el TP1, una funci\u00f3n que nos diga como hacer una chocotorta. Para estoy vamos a hacer un script que:</p> <ul> <li>Use una funcion</li> <li>Considere en que vamos a remojar las galletitas y el numero de capas</li> <li>Imprima todos los pasos necesarios para armar la chocotorta</li> </ul>","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/#ejercicio-adicional-3","title":"Ejercicio Adicional 3","text":"<p>En R hay much\u00edsimos paquetes que nos pueden servir para distintos tipos de an\u00e1lisis. Para que se den una idea de la variedad de paquetes, vamos a mostrarles el paquete CatterPlots, que como su nombre lo indica, hace gr\u00e1ficos con gatitos. Primero prueben correr esto en RStudio:</p> <p></p><pre><code>install.packages(\"remotes\")\nremotes::install_github(\"Gibbsdavidl/CatterPlots\")\nlibrary(CatterPlots)\n\n# Datos de muestra\nx &lt;- seq(0, 15, 0.5)\ny &lt;- sin(x)\n\ncatplot(x, y,\n        cat = 2,       # Tipo de gato\n        catcolor = \"blue\",  # Color del gato\n        type = \"line\", # \"line\" o \"justcats\"\n        linecolor = 1) # Color de la l\u00ednea\n</code></pre> Pueden ver mas informaci\u00f3n sobre CatterPlots en esta p\u00e1gina <p>Ahora prueben crear su propio gr\u00e1fico de gatitos. Armen dos vectores x e y, y prueben graficarlos cambiando alguno/s de los par\u00e1metros de catplot, como el tipo de gato o el color.</p>","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/#bibliografia","title":"Bibliograf\u00eda","text":"","tags":["practicos"]},{"location":"practicos/TPPa_Programando_en_Biologia/#consola-de-r","title":"Consola de R","text":"<ul> <li>Comando <code>help()</code></li> </ul>","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/","title":"Practico Programaci\u00f3n en R","text":"","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#tpp-r-programando-en-biologia-parte-2","title":"TPP. R - Programando en biolog\u00eda - Parte 2","text":"<p> Materiales</p> <p>Atenci\u00f3n: Este TP NO tiene informe.</p>","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#software-a-usar","title":"Software a usar","text":"<ul> <li>R</li> <li>RStudio</li> </ul>","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#recursos-online","title":"Recursos Online","text":"<ul> <li>Curso online de R de Coursera (se puede hacer gratis) (en ese caso no da certificado)</li> <li>Tips de comandos b\u00e1sicos de R</li> <li>Data Tables: Introducci\u00f3n oficial y otra p\u00e1gina con m\u00e1s info</li> <li>ggplot2: Vistazo r\u00e1pido, otra p\u00e1gina con cada plot detallando sus par\u00e1metros y cheatsheet</li> </ul>","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#objetivos","title":"Objetivos","text":"<ul> <li>Familiarizarse en el lenguaje de programaci\u00f3n R.</li> <li>Ver como los mismos conceptos de programaci\u00f3n se trasladan de un lenguaje a otro.</li> <li>Utilizar herramientas de programaci\u00f3n para resolver problemas biol\u00f3gicos.</li> </ul>","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#introduccion-al-tema","title":"Introducci\u00f3n al Tema","text":"<p>Es muy normal que en trabajos de biolog\u00eda sea necesario trabajar con datos provenientes de servicios o equipos que no generan outputs de formato est\u00e1ndar (separados por tabs, comas, etc). Esto hace que cuando queramos cargar estos outputs en cualquier programa de an\u00e1lisis de datos vamos a tener que darles formato manualmente, algo que puede no ser muy complicado cuando se trata de unos pocos archivos o un solo ensayo, pero se vuelve un problema en grandes cantidades.</p> <p>En la materia ya vimos varios archivos de salida con patrones propios, por ejemplo los archivos FASTA, donde el marcador <code>&gt;</code> es usado para indicar el comienzo del header una secuencia. Diferentes programas van a tener diferentes patrones de salida, pero suelen haber ciertos caracteres bastante usados como <code>#</code>, <code>!</code>, <code>*</code>, <code>|</code>, etc.</p> <p>En este trabajo pr\u00e1ctico vamos a usar el lenguaje de programaci\u00f3n R para leer datos generados por un lector de placas de wells. Vamos a parsear dichos datos para que est\u00e9n en un formato con el que podamos trabajar, y vamos a procesarlos como necesitemos para calcular estad\u00edsticos y plots que contengan informaci\u00f3n sobre el experimento realizado.</p>","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#experimento","title":"Experimento","text":"","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#objetivo","title":"Objetivo","text":"<p>En el TP de hoy vamos a querer encontrar un compuesto que funcione de inhibidor para una enzima de inter\u00e9s, a la que vamos a denominar enzima Z. No solo nos va a interesar que compuestos funcionan como inhibidores para ella, sino que tambi\u00e9n queremos calcular el IC 50 de cada uno de dichos compuestos (que en nuestro caso ser\u00eda la concentraci\u00f3n a la cual el inhibidor produce una reacci\u00f3n un 50% m\u00e1s lenta que sin inhibidor).</p> <p>Por suerte nuestra enzima de inter\u00e9s tiene como producto un compuesto fluorescente. Sabiendo esto podemos estimar la velocidad de la reacci\u00f3n calculando una regresi\u00f3n lineal de la abundancia de dicho producto a lo largo del tiempo (esto lo vamos a explicar un poco m\u00e1s detalladamente cuando lo hagamos). Si un compuesto funciona como inhibidor en algunas de las concentraciones evaluadas, la velocidad de la reacci\u00f3n deber\u00eda caer.</p>","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#filtermax","title":"FilterMax","text":"<p>Una forma de analizar varios compuestos y concentraciones a la vez es usar el equipo FilterMax F5. Este equipo permite hacer mediciones puntuales de absorbancia y fluorescencia (entre otros) en placas de wells de 96, 384 y 1536. Incluso permite hacer mediciones a distintos tiempos (por ejemplo, se le puede programar para hacer mediciones cada ciertos intervalos temporales).</p> <p>En nuestro ejemplo (datos reales, nombres ficticios), vamos a utilizar el FilterMax F5 para evaluar varias placas de 384 wells y vamos a hacer 4 evaluaciones por placa, una cada 5 minutos. Cada columna de la placa corresponde compuesto distinto (22 compuestos, 1 por columna) y cada fila tiene concentraciones diferentes de cada compuesto (16 concentraciones, diluciones seriadas). Un esquema de este experimento se puede ver en esta planilla.</p>","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#paso-1-familiarizarnos-con-el-archivo","title":"Paso 1 - Familiarizarnos con el Archivo","text":"<p>El primer paso cuando uno empieza a trabajar con un archivo nuevo es siempre mirarlo y deducir su formato. Los resultados reales de este experimento pueden verlos en el archivo 00_datos_filtermax.txt que se encuentra en sus materiales de trabajo.</p> <p>Abran el archivo 00_datos_filtermax.txt con Editor de Texto, vean su estructura y respondan las siguientes preguntas:</p> <p>1) \u00bfSe parece un poco a alg\u00fan .csv (columnas separadas por comas) o .tsv (columnas separadas por tabs) que hayan visto antes? \u00bfQue diferencias tiene? Teniendo en cuenta esas diferencias y considerando que vamos a querer leerlo como una tabla en R \u00bfLes parece que hay filas que est\u00e1n de m\u00e1s?</p> <p>2) Mirando el archivo y la planilla del experimento:</p> <ul> <li> <p>\u00bfQu\u00e9 hay en la celda A1?</p> </li> <li> <p>\u00bfQu\u00e9 posiciones contienen las diferentes diluciones del compuesto \"Umbrella2\"?</p> </li> <li> <p>\u00bfCu\u00e1ntos datos hay para cada diluci\u00f3n del compuesto \"Umbrella2\"? \u00bfPor qu\u00e9?</p> </li> </ul> <p>3) Ahora abra el archivo en una Hoja de C\u00e1lculo (Click derecho sobre el archivo  Abrir con). Al final de cada placa hay varias celdas sin datos. \u00bfHay algo en la planilla del experimento que explique por qu\u00e9 pasa esto?</p>","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#paso-2-limpiar-y-parsear-el-archivo","title":"Paso 2 - Limpiar y Parsear el Archivo","text":"<p>En este paso queremos hacer 2 cosas:</p> <ul> <li> <p>Primero, queremos sacar cualquier fila extra de 00_datos_filtermax.txt que nos impida leer el archivo usando <code>fread</code>. Si bien en este caso esto se podr\u00eda hacer a mano, como programadores queremos soluciones que escalen bien con el n\u00famero de datos, asi que lo vamos a hacer en un script.</p> </li> <li> <p>Segundo, queremos reorganizar los datos para poder trabajar con ellos m\u00e1s f\u00e1cil, y para eso queremos una tabla con la siguiente estructura:</p> </li> </ul> time temperature fila columna signal \"00:00:00\" 30 \"A\" 1 417246 \"00:04:59\" 30 \"A\" 1 595504 \"00:10:00\" 30 \"A\" 1 789920 \"00:15:00\" 30 \"A\" 1 985947 \"00:00:00\" 30 \"A\" 2 389328 ... ... ... ... ... <p>Si bien este paso es importante, tambi\u00e9n es bastante espec\u00edfico a la salida del FilterMax F5. Por esta raz\u00f3n les vamos a dar el archivo ya parseado para que pasemos directamente al an\u00e1lisis de datos m\u00e1s general. Este es el archivo 02_datos_filtermax_parseados.tsv que se encuentra en sus materiales de trabajo.</p> <p>Dicho esto, si completan el resto del TP a tiempo y quieren aprender c\u00f3mo llegar del archivo original a \u00e9ste archivo pueden hacer el Ejercicio Adicional 1 abajo de todo.</p> <p>1) Abran el archivo 02_datos_filtermax_parseados.tsv con el Editor de Texto y vean la columna signal. \u00bfQu\u00e9 piensan que significan los NA en esa columna?</p>","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#paso-3-agregar-la-informacion-que-necesito","title":"Paso 3 - Agregar la informaci\u00f3n que necesito","text":"<p>En este momento tenemos una tabla donde cada fila es una se\u00f1al independiente, pero tenemos algunos problemas:</p> <ul> <li> <p>No tengo informaci\u00f3n de los compuestos en la tabla, solo de los n\u00fameros de las columnas</p> </li> <li> <p>No tengo informaci\u00f3n de las diluciones en la tabla, solo de las letras de las filas</p> </li> <li> <p>M\u00e1s adelante vamos a querer calcular la velocidad de reacci\u00f3n, es decir, c\u00f3mo var\u00eda la signal seg\u00fan el time. Sin embargo, ac\u00e1 time es un string, por lo que necesito transformarlo a n\u00famero</p> </li> </ul> <p>Estas son las cosas que queremos arreglar. Por suerte tenemos tambi\u00e9n otras dos tablas, una indicando que compuesto hay en cada columna (00_datos_compuestos.tsv) y otra indicando que diluci\u00f3n hay en cada fila (00_datos_concentraciones.tsv).</p> <p>Esto se podr\u00eda hacer a mano, pero llevar\u00eda mucho tiempo y podr\u00eda haber errores de tipeo. Por esta raz\u00f3n vamos a crear un programa que haga todo esto por nosotos. Sin embargo, antes de crear este programa necesitamos aprender algunas cosas nuevas:</p>","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#herramientas-necesarias","title":"Herramientas necesarias","text":"","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#filtrar-filas-en-data-table","title":"Filtrar filas en Data Table","text":"<p>Algo de esto vimos en el TP anterior, pero es posible filtrar filas de un Data Table seg\u00fan el valor de las diferentes columnas en dicha fila.</p> <p>Vamos a volver a usar el data set iris que est\u00e1 siempre cargado en memoria; sin embargo, iris es un Data Frame, por lo que lo vamos a tener que convertir en Data Table.</p> <pre><code>library(data.table) #tenemos que cargar el paquete data.table en memoria cada vez que cerramos RStudio\n\ndt_iris &lt;- as.data.table(iris)\n</code></pre> <p>Ahora supongamos que queremos solo las filas donde la columna Species es versicolor \u00f3 virginica. Hay varias formas de hacer esto y todas les van a ser \u00fatiles para lo que tenemos que hacer hoy.</p> <p>1) Corran por lo menos dos de las l\u00edneas de c\u00f3digo siguientes y vean lo que devuelven:</p> <pre><code># Cualquiera de estas 5 l\u00edneas de c\u00f3digo devuelve el mismo *Data Table*\ndt_iris[(Species == \"versicolor\") | (Species == \"virginica\")]\ndt_iris[Species %in% c(\"versicolor\", \"virginica\")]\ndt_iris[Species != \"setosa\"]\ndt_iris[!(Species == \"setosa\")]\ndt_iris[!(Species %in% c(\"setosa\"))]\n</code></pre>","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#mergear-data-tables","title":"Mergear Data Tables","text":"<p>Por mergear nos referimos a juntar dos Data Tables horizontalmente, es decir, agregar de alguna forma las columnas de uno al otro. </p> <p>2) Corran el siguiente ejemplo y vean lo que devuelve.</p> <pre><code>genes &lt;- c(\"ERT2\", \"TTR4\", \"REC1\")\nesencialidad &lt;- c(F, F, T)\nexpresiones &lt;- c(100 ,1000, 10000)\n\ndt_info_de_esencialidad &lt;- data.table(gen = genes,\n                                      esencial = esencialidad)\ndt_info_de_expresion &lt;- data.table(gen = genes,\n                                   expresion = expresiones)\n\ndt_toda_la_info &lt;- merge(dt_info_de_esencialidad,\n                         dt_info_de_expresion,\n                         by = \"gen\")\n\nprint(dt_toda_la_info)\n</code></pre> <p>Como ven, la funci\u00f3n <code>merge</code> toma 2 Data Tables y los une por la columna definida en el par\u00e1metro <code>by</code>. Una cosa interesante es que no es necesario que ambos Data Frames tengan el mismo tama\u00f1o.</p> <p>3) Corran el siguiente ejemplo y vean lo que devuelve.</p> <pre><code>especies &lt;- c(\"setosa\", \"virginica\", \"versicolor\")\nempieza_con_S &lt;- c(T, F, F)\n\ndt_info_S &lt;- data.table(Species = especies,\n                        empieza_con_S = empieza_con_S)\n\nnueva_dt_iris &lt;- merge(dt_iris,\n                       dt_info_S,\n                       by = \"Species\")\n\nprint(nueva_dt_iris)\n</code></pre> <p>Para cada fila de dt_iris el <code>merge</code> agrego el valor de empieza_con_S seg\u00fan la columna Species. Van a ver que se desordenaron las filas y las columnas. Esto sucede ya que <code>merge</code> va a mover a la columna usada en el <code>by</code> al principio. Uno despu\u00e9s tiene que reordenarlas como prefiera.</p>","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#agregar-filas-a-data-tables","title":"Agregar filas a Data Tables","text":"<p>Ahora que aprendimos a agregar columnas en masa tambi\u00e9n queremos hacer lo mismo con una o m\u00e1s filas.</p> <p>4) Corran el siguiente ejemplo y vean lo que devuelve.</p> <pre><code>genes &lt;- c(\"ERT2\", \"TTR4\", \"REC1\")\nesencialidad &lt;- c(F, F, T)\nexpresiones &lt;- c(100 ,1000, 10000)\n\ndt_toda_la_info &lt;- data.table(gen = genes,\n                              esencial = esencialidad,\n                              expresion = expresiones)\n\ndt_nueva_fila &lt;- data.table(gen = \"AFK5\",\n                            esencial = T,\n                            expresion = 50)\n\ndt_toda_la_info &lt;- rbindlist(list(dt_toda_la_info,\n                                  dt_nueva_fila))\n\nprint(dt_toda_la_info)\n</code></pre> <p>El comando <code>rbindlist</code> concatena dos Data Tables, donde el segundo puede ser una sola fila o algo m\u00e1s grande. Es importante que ambos Data Tables tengan la misma estructura para que el comando no devuelva errores.</p>","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#crear-data-table-vacio","title":"Crear Data Table vac\u00edo","text":"<p>Ahora que sabemos agregar filas a un Data Table, puede ser entonces \u00fatil tener un Data Table vac\u00edo al que le voy a agregando filas que voy calculando (por ejemplo en un ciclo).</p> <p>5) Corran el siguiente ejemplo y vean lo que devuelve.</p> <pre><code>dt_toda_la_info_vacio &lt;- data.table(gen = character(),\n                                    esencial = logical(),\n                                    expresion = numeric())\n\nprint(dt_toda_la_info_vacio)\n\ndt_nueva_fila &lt;- data.table(gen = \"AFK5\",\n                            esencial = T,\n                            expresion = 50)\n\ndt_toda_la_info &lt;- rbindlist(list(dt_toda_la_info_vacio,\n                                  dt_nueva_fila))\n\nprint(dt_toda_la_info)\n</code></pre> <p>Como ven, al crear un Data Table vac\u00edo tengo que asignar a cada columna el tipo de datos que va a contener. Aca estoy usando <code>character()</code> (strings), <code>logical()</code> (booleano) y <code>numeric()</code> (n\u00fameros reales). El \u00fanico otro tipo que puede ser que usen en esta materia es el <code>integer()</code> que son n\u00fameros enteros, pero como dijimos en el TP anterior es com\u00fan usar <code>numeric()</code> para estos tambi\u00e9n.</p>","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#reordenar-columnas-en-data-tables","title":"Reordenar columnas en Data Tables","text":"<p>Como mencionamos antes, el <code>merge</code> nos va a desordenar las columnas de la tabla. Adem\u00e1s, es posible querer quedarnos con solo algunas de las columnas de una tabla porque ya no tenemos m\u00e1s usos para otras. Una forma de hacer esto es:</p> <pre><code>dt_iris &lt;- as.data.table(iris)\n\n#Los tres siguientes bloques hacen lo mismo, qued\u00e1ndonos solo con las \n#columnas Species, Sepal.Length y Sepal.Width\n\ndt_iris[, .(Species, Sepal.Length, Sepal.Width)]\n\ndt_iris[, c(\"Species\", \"Sepal.Length\", \"Sepal.Width\")]\n\ncolumnas_a_quedarnos &lt;- c(\"Species\", \"Sepal.Length\", \"Sepal.Width\")\ndt_iris[, columnas_a_quedarnos, with = F]\n</code></pre> <p>Esto es \u00fatil cuando queremos quedarnos con pocas columnas, pero \u00bfqu\u00e9 pasa cuando tenemos muchas y solo queremos sacar algunas? Ah\u00ed podemos hacer:</p> <pre><code>dt_iris &lt;- as.data.table(iris)\n\n#Los dos siguientes bloques hacen lo mismo, sacando las columnas Species, Sepal.Length y Sepal.Width\n\ndt_iris[, -c(\"Species\", \"Sepal.Length\", \"Sepal.Width\")]\n\ncolumnas_a_borrar &lt;- c(\"Species\", \"Sepal.Length\", \"Sepal.Width\")\ndt_iris[, -columnas_a_borrar, with = F]\n</code></pre>","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#splitear-strings","title":"Splitear strings","text":"<p>Hay varias funciones en R que nos permiten parsear texto y una de las m\u00e1s f\u00e1ciles de entender es <code>strsplit</code>. Como su nombre lo indica esta funci\u00f3n splitea (o corta) un string (o cadena de caracteres). Veamos un ejemplo:</p> <p></p><pre><code>frase &lt;- \"Habia-una-vez\"\nfrase_spliteada &lt;- strsplit(frase, split = \"-\")\nprint(frase_spliteada)\n</code></pre> <pre><code>[[1]]\n[1] \"Habia\" \"una\"   \"vez\"\n</code></pre> Como ven la funci\u00f3n <code>strsplit</code> toma un string y lo divide en diferentes fragmentos seg\u00fan el par\u00e1metro <code>split</code>. <p>No s\u00e9 si lo recuerdan, pero en el TP anterior hablamos de las variables llamadas listas, que se pueden pensar como vectores que pueden contener variables de distinto tipo dentro de ellas (mientras que todos los elementos de un vector son de un mismo tipo).</p> <p>Ese <code>[[1]]</code> en el output anterior nos est\u00e1 indicando que <code>strsplit</code> nos est\u00e1 devolviendo una variable de tipo <code>list</code> donde el primer elemento es el vector con la frase spliteada.</p> <p>6) Si bien el par\u00e1metro <code>split</code> suele ser un caracter, en realidad puede ser un string cualquiera. Prueben el c\u00f3digo anterior usando <code>split = \"-una-\"</code> y vean que pasa.</p> <p>7) Vean que pasa cuando usan <code>split = \"\"</code>.</p> <p>8) P\u00e1senle ahora a <code>strsplit</code> el siguiente vector de strings: <code>frases &lt;- c(\"Aqu\u00ed me pongo a cantar\", \"al comp\u00e1s de la vig\u00fcela\")</code>.</p> <p>Sabiendo que queremos splitear las diferentes palabras,</p> <ul> <li>\u00bfcu\u00e1l ser\u00eda el valor de <code>split</code> en este caso?</li> <li>\u00bfCu\u00e1ntos elementos tiene la lista que devuelve <code>strsplit</code>? \u00bfPor qu\u00e9?</li> <li>\u00bfCu\u00e1l es la tercera palabra de la segunda frase? (impr\u00edmanla por pantalla usando <code>print</code>)</li> </ul>","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#eliminar-elementos-repetidos-en-vectores","title":"Eliminar elementos repetidos en vectores","text":"<p>En los Data Tables es com\u00fan tener columnas con categor\u00edas, por ejemplo la columna Species en la tabla iris. Es normal al momento de programar no saber previamente cu\u00e1les van a ser esas categor\u00edas (especies en este caso), por lo que muchas veces se extraen de la columna misma. Una forma de hacer esto es usar la funci\u00f3n <code>unique()</code>, la cual toma un vector y saca los elementos repetidos, dejando uno de cada uno.</p> <p>9) Corran el siguiente ejemplo y vean lo que devuelve.</p> <pre><code>vector_especies &lt;- iris$Species\n\nvector_especies_unicas &lt;- unique(vector_especies)\n\nprint(vector_especies)\nprint(vector_especies_unicas)\n</code></pre> <p>La columna <code>iris$Species</code> es t\u00e9cnicamente un factor, pero estos son simplemente vectores con propiedades extras. La funci\u00f3n <code>unique()</code> va a funcionar igual de pasarle un vector de caracteres; de hecho, esta funci\u00f3n tambi\u00e9n puede remover filas repetidas de un Data Table.</p>","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#usar-fread-con-datos-faltantes","title":"Usar <code>fread</code> con datos faltantes","text":"<p>Es com\u00fan que un set de datos tenga datos faltantes, lo que en nuestro caso vendr\u00eda a ser wells sin se\u00f1al. Diferentes tablas los van a indicar de diferentes maneras, pero es com\u00fan verlos como nada (o sea veo los separadores de columnas, pero no hay informaci\u00f3n en el medio), NaN (Not a Number), ND (No Data) o como NA (Not Available). En esta caso vamos a usar NA.</p> <p>Es importante al momento de leer un archivo saber si mi archivo tiene o no estos datos faltantes, ya que de no tenerlo en cuenta puedo terminar leyendo a NA como el string \"NA\", lo cual puede insertar datos falsos y hasta forzar a R a leer una columna num\u00e9rica como si fueran todos strings.</p> <p>Podemos indicarle a <code>fread</code> si hay celdas sin valores y como est\u00e1n escritas con el par\u00e1metro <code>na.strings</code>:</p> <pre><code>dt &lt;- fread(\"ARCHIVO_DT\", header = T, sep = \"\\t\", na.strings = \"NA\")\n</code></pre> <p>En este caso le estamos indicando que hay celdas sin valores y que est\u00e1n escritas en la tabla como \"NA\" (pueden estar con o sin comillas en el archivo). De querer indicarle a <code>fread</code> que los datos faltantes est\u00e1n como nada se usa <code>na.strings = \"\"</code>, aunque en este caso cualquier columna con un string vac\u00edo tambi\u00e9n va a ser considerada dato faltante.</p> <p>Tip - Carga m\u00e1s r\u00e1pida de los datos</p> <p>Si estamos seguros que no hay celdas sin valores en nuestros datos, le podemos pasar <code>na.strings = NULL</code> para indicarle que no busque celdas vac\u00edas, lo que acelera la carga de la tabla.</p>","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#usar-fread-con-decimales-espanoles","title":"Usar <code>fread</code> con decimales espa\u00f1oles","text":"<p>Otro problema com\u00fan al momento de trabajar con datos es que por alguna diab\u00f3lica raz\u00f3n el separador de decimales y el separador de miles no son iguales para algunos pa\u00edses que para otros, de hecho, son exactamente al rev\u00e9s.</p> <p>Es posible entonces que tengan una tabla que hizo alguien en Argentina donde uso comas como separador de decimales, pero que al cargarla en R, el cual fue creado en Estados Unidos, piense que dichas comas son separador de miles, lo que rompe completamente los n\u00fameros pasados.</p> <p>Por suerte algo de consideraci\u00f3n tienen y existe un par\u00e1metro de <code>fread</code> que nos permite especificar cual es el separador de decimales (que por defecto es el punto):</p> <pre><code>dt &lt;- fread(\"ARCHIVO_DT\", header = T, sep = \"\\t\", dec = \",\")\n</code></pre>","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#paso-3-ejercicio","title":"Paso 3 - Ejercicio","text":"<p>10) Creen un nuevo script de R, copien el siguiente c\u00f3digo y guardenlo en su carpeta de trabajo. Vayan avanzando por el script y cambien las secciones que dicen <code>@@EDITAR@@</code> por lo que corresponda (esto puede ser un valor, una variable, una operaci\u00f3n matem\u00e1tica, una comparaci\u00f3n o una funci\u00f3n de R).</p> <p>Warning - Working Directory</p> <p>Cada vez que lean o escriban un archivo recuerden que el path que le pasen debe ser un path absoluto o un path relativo al Working Directory. Para cambiar el Working Directory pueden usar la funci\u00f3n <code>setwd()</code> que aprendimos en el TP anterior.</p> <p>Tip - \u00d1 y acentos</p> <p>Van a ver que en los c\u00f3digos tratamos de no usar la letra \u00d1 o acentos. Esto es as\u00ed ya que cuando uno comparte c\u00f3digo entre varias personas suele pasar que algunas de esos caracteres se \"rompen\" y se ven feo (por ejemplo un texto que era dise\u00f1o_compuestos se ve\u00eda como dise\u00c3\u00b1o_compuestos en otra PC).</p> <p>Si bien es posible poner est\u00e1ndares de codificaci\u00f3n de texto en grupos, la realidad es que solemos programar en ingl\u00e9s por lo que el problema se evita solo.</p> <p>Este tip es especialmente importante para los nombres de las variables. Ah\u00ed si que recomendamos nunca usar acentos o \u00d1 (o espacios).</p> <pre><code>#Aca hay que poner el Path Absoluto que apunta a su carpeta de trabajo\n#Por ej: \"/home/ibioinfo/Documentos/data_TPPb\"\nsetwd(@@EDITAR@@)\n\nlibrary(data.table)\n\n#Uso fread para cargar los datos parseados teniendo en cuenta que tienen NAs\ndt_parsed_data &lt;- fread(@@EDITAR@@)\n\n#Primero que nada se que las columnas de los wells 23 y 24 estan vac\u00edas, asi que saco las filas\n#donde *columna* sea 23 o 24 (o sea, me quedo con las filas donde *columna* es 1 a 22)\ndt_parsed_data &lt;- dt_parsed_data[@@EDITAR@@]\n\n#Ahora, la fila y la columna no me esta dando mucha informacion de lo que esta pasando, \n#por lo que quiero agregar informacion de los compuestos y de concentraciones\n\n#Agrego informacion compuestos\ndt_datos_compuestos &lt;- fread(\"00_datos_compuestos.tsv\", header = T, sep = \"\\t\", na.strings = NULL)\ndt_parsed_data &lt;- merge(dt_parsed_data,\n                        dt_datos_compuestos,\n                        by = \"columna\")\n\n#Agrego informacion concentraciones (ojo que en *00_datos_concentraciones.tsv* el separador decimal es la coma)\ndt_datos_concentraciones &lt;- fread(@@EDITAR@@)\ndt_parsed_data &lt;- merge(@@EDITAR@@)\n\n#Para cada combinaci\u00f3n de compuesto y concentraci\u00f3n quiero saber la velocidad de la reacci\u00f3n, es decir, \n#la pendiente de la recta que sale de hacer una regresi\u00f3n lineal por los 4 tiempos ensayados\n\n#El primer problema que tengo es que la variable time es un *string*, por lo que no puedo usarla \n#como X en una ecuacion. Por esta razon vamos a convertir a time en cantidad de segundos\n\n#Si bien hay 1408 filas, en si solo hay 4 tiempos que se repiten:\n#\"00:00:00\", \"00:04:59\", \"00:10:00\" y \"00:15:00\"\n\n#Voy entonces a hacer una tabla llamada dt_times_in_seconds que va a empezar vac\u00eda y una vez corrido el \n#siguiente *for* va a tener 4 filas, una por cada uno de los 4 tiempos\n#Esta tabla va a tener dos columnas, la columna *time* indicando el tiempo en string que estamos analizando\n#y la columna *segundos_totales* que contiene ese tiempo transformado en numero y en segundos\n\n#Extraigo entonces los diferentes tiempos y creo una tabla vac\u00eda donde voy a guardar la cantidad de segundos \n#para cada *time*\nunique_times &lt;- unique(dt_parsed_data$time)\ndt_times_in_seconds &lt;- data.table(time = character(),\n                                  segundos_totales = numeric())\nfor (time_for in unique_times) {\n    # Esta siguiente linea comentada la uso para debuggear, es decir, para cuando estoy creando el programa\n    # Si la ejecutan a mano (sin el #) pueden entonces ir paso a paso en el *for* viendo que funcione todo\n    # Recuerden que pueden usar CTRL + ENTER para ejecutar el codigo seleccionado o ver el valor de una variable\n\n    # time_for &lt;- unique_times[2]\n\n    #Divido las horas, minutos y segundos y las transformo a numeros\n    time_spliteado &lt;- strsplit(time_for, \":\")\n\n    #*strsplit* devuelve una lista, que es como un vector, pero mas complicado\n    #Voy a sobreescribir la variable quedandome solo con el primer elemento de la lista, que es un vector\n    time_spliteado &lt;- time_spliteado[[1]] \n\n    #Guardo cada uno de los tres numeros en otra variable. Como ahora son *strings* uso as.numeric() para\n    #convertirlos en numeros\n    horas &lt;- as.numeric(@@EDITAR@@)\n    minutos &lt;- as.numeric(@@EDITAR@@)\n    segundos &lt;- as.numeric(@@EDITAR@@)\n\n    #Calculo los segundos totales, es decir, del paso anterior transformo las horas y los minutos en segundos \n    #y sumo las tres variables\n    segundos_totales &lt;- @@EDITAR@@\n\n    #Guardo esta info en la tabla que acabo de crear\n    dt_new_row_times_in_seconds &lt;- data.table(time = @@EDITAR@@,\n                                              segundos_totales = @@EDITAR@@)\n\n    dt_times_in_seconds &lt;- rbindlist(list(dt_times_in_seconds,\n                                          dt_new_row_times_in_seconds))\n}\n\n#Agrego la informacion de los segundos totales (guardada en dt_times_in_seconds) a mi tabla original\ndt_parsed_data &lt;- merge(@@EDITAR@@)\n\n#Ahora van a ver que las columnas de la tabla parecen estar mezcladas, lo que se debe a los merge\n#Por otro lado hay columnas que ya no vamos a usar\n#Resolvemos las dos cosas a la vez rearmando las columnas de la tabla\ndt_parsed_data &lt;- dt_parsed_data[, .(compuesto, concentracion, segundos_totales, signal)]\n\n#Escribo los datos en una nueva tabla\nwrite.table(dt_parsed_data, file = \"03_datos_filtermax_parseados_y_formateados.tsv\", col.names = T, row.names = F, sep = \"\\t\", quote = T)\n</code></pre> <p>Si todo sali\u00f3 bien, el archivo 03_datos_filtermax_parseados_y_formateados.tsv deber\u00eda ser una tabla del estilo:</p> compuesto concentracion segundos_totales signal \"Umbrella1\" 200 0 417246 \"Umbrella2\" 200 0 389328 \"Umbrella3\" 200 0 225039 \"Umbrella4\" 200 0 248039 ... ... ... ... <p>Warning - los programas que abren hojas de c\u00e1lculo pueden transformar visualmente los separadores decimales</p> <p>Si abren el archivo 03_datos_filtermax_parseados_y_formateados.tsv en una hoja de c\u00e1lculo podr\u00eda ocurrir que el separador decimal de los n\u00fameros siga siendo la coma. Sin embargo, si abren el archivo usando el Editor de Texto van a ver que en realidad el separador decimal es ahora el punto, por lo que para los pr\u00f3ximos ejercicios podemos usar <code>fread</code> sin poner el par\u00e1metro <code>dec</code>. El cambio de los puntos a comas depende de la configuraci\u00f3n que tenga la hoja de c\u00e1lculo y esto pasa mucho con Google Sheets.</p>","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#paso-4-calcular-velocidades-de-reaccion","title":"Paso 4 - Calcular velocidades de reacci\u00f3n","text":"<p>En f\u00edsica la velocidad es la variaci\u00f3n de posici\u00f3n por unidad de tiempo. La velocidad de reacci\u00f3n es similar, donde queremos averiguar la variaci\u00f3n de se\u00f1al por unidad de tiempo (en nuestro caso es un segundo).</p> <p>Para cada diluci\u00f3n de cada compuesto, nosotros tenemos la se\u00f1al a cuatro puntos en el tiempo (una vez cada 5 minutos, o 300 segundos). Vamos a asumir que la se\u00f1al var\u00eda linealmente con el tiempo, por lo que la forma m\u00e1s directa de conseguir la velocidad de reacci\u00f3n es calcular la pendiente de la recta que pasa por los cuatro puntos que conseguimos experimentalmente.</p> <p>Es de esperar que los cuatro puntos no se alineen perfectamente, pero hay formas en R de calcular y plotear la l\u00ednea que m\u00e1s se ajusta a ellos (hacer una regresi\u00f3n lineal). A continuaci\u00f3n mostramos el ejemplo de \"Umbrella1\" a concentraci\u00f3n 0, es decir, la velocidad de reacci\u00f3n base cuando no hay ning\u00fan compuesto.</p> <p></p> <p>En este plot vemos que la pendiente de la recta es aproximadamente 1718, lo que quiere decir que cada segundo la se\u00f1al aumenta en 1718. Nuestro objetivo en este paso del TP es calcular este n\u00famero para todas las concentraciones de todos los compuestos.</p> C\u00f3digo usado para hacer el plot anterior (para los curiosos) <pre><code>library(data.table)\nlibrary(ggplot2)\n\ndt_parsed_formatted_data &lt;- fread(\"03_datos_filtermax_parseados_y_formateados.tsv\", header = T, sep = \"\\t\", na.strings = NULL)\n\nlinear_regression_aux &lt;- lm(data = dt_parsed_formatted_data[compuesto == \"Umbrella1\" &amp; concentracion == 0], signal ~ segundos_totales)\n\n# La funcion *sprintf* se usa similar a *paste* ya que permite reemplazar los *%s* en el primer string por las variables que le paso\n# a continuacion\nformula_aux &lt;- sprintf(\"Y = %s * X + %s\",\n                       round(linear_regression_aux$coefficients[2], 2),\n                       round(linear_regression_aux$coefficients[1], 2))\n\nggplot(data = dt_parsed_formatted_data[compuesto == \"Umbrella1\" &amp; concentracion == 0], aes(x = segundos_totales, y = signal)) +\n    geom_point(size = 2) +\n    geom_smooth(method='lm') +\n    theme_bw() +\n    xlab(\"Tiempo (s)\") + \n    ylab(\"Signal\") + \n    ggtitle(\"Velocidad base (sin compuesto)\") +\n    theme(axis.title = element_text(size = 14, hjust = 0.5),\n          axis.text = element_text(size = 14, hjust = 0.5),\n          plot.title = element_text(size = 16, hjust = 0.5)) +\n    annotate(\"text\", x = 10, y = 2000000, label = formula_aux, hjust = 0, size = 5)\n</code></pre>","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#herramientas-necesarias_1","title":"Herramientas necesarias","text":"<p>En este ejercicio tambi\u00e9n vamos a necesitar varias herramientas, pero la buena noticia es que la mayor\u00eda ya las vieron en el TP anterior o en el paso anterior.</p>","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#fors-anidados","title":"Fors anidados","text":"<p>Es bastante com\u00fan cuando se trabaja con tablas querer recorrer todas las combinaciones de dos variables categ\u00f3ricas. Una forma de hacer esto es usar fors anidados, es decir, un for adentro de otro for. En este caso el for interno se va a ejecutar completo una vez por cada elemento del for externo. Dentro del for interno es donde vamos a poner el c\u00f3digo que queramos hacer con cada combinaci\u00f3n de nuestras variables.</p> <p>1) Corran el siguiente ejemplo y vean lo que devuelve. \u00bfCu\u00e1ntas veces se ejecut\u00f3 el <code>print</code>? \u00bfEn qu\u00e9 orden se recorrieron los diferentes prefijos y sufijos?</p> <pre><code>vector_prefijos &lt;- c(\"veinti\", \"cuarenti\", \"ciento\")\nvector_sufijos &lt;- c(\"cuatro\", \"dos\", \"ocho\")\n\nfor (prefijo_for in vector_prefijos) {\n    for (sufijo_for in vector_sufijos) {\n        numero_for &lt;- paste(prefijo_for, sufijo_for, sep = \"-\")\n\n        print(numero_for)\n    }\n}\n</code></pre>","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#regresion-lineal","title":"Regresi\u00f3n lineal","text":"<p>El ajuste de mis datos a una f\u00f3rmula matem\u00e1tica es un tema s\u00faper complejo; sin embargo, en este TP necesitamos la versi\u00f3n m\u00e1s simple de esto, que son las regresiones lineales. Existe una funci\u00f3n que viene con R llamada <code>lm</code> que nos va a permitir calcular una regresi\u00f3n lineal a partir de dos vectores num\u00e9ricos.</p> <pre><code>regresion_lineal &lt;- lm(data = iris, formula = Sepal.Length ~ Petal.Length)\n\nprint(regresion_lineal)\n</code></pre> <pre><code>Call:\nlm(formula = Sepal.Length ~ Petal.Length, data = iris)\n\nCoefficients:\n (Intercept)  Petal.Length  \n      4.3066        0.4089\n</code></pre> <ul> <li>El par\u00e1metro <code>data</code> nos permite poner un Data Frame o Data Table para luego poder mencionar las columnas directamente (de otra forma habr\u00eda que hacer <code>iris$Sepal.Length</code>)</li> <li>El par\u00e1metro <code>formula</code> es donde le decimos a <code>lm</code> a que f\u00f3rmula debe ajustar los datos. Para regresi\u00f3n lineal es <code>Y ~ X</code></li> <li>De imprimir <code>regresion_lineal</code> por pantalla vemos los coeficientes de la f\u00f3rmula<ul> <li><code>(Intercept)</code> es la ordenada al origen y la otra columna (en este caso llamada <code>Petal.Length</code>) es la pendiente</li> </ul> </li> </ul> <p>Podemos extraer cada uno de estos dos n\u00fameros haciendo:</p> <pre><code>ordenada_al_origen &lt;- regresion_lineal$coefficients[1]\npendiente &lt;- regresion_lineal$coefficients[2]\n</code></pre> <p>\u00bfSe ajustan mis datos a una recta?</p> <p>Si bien no lo vamos a usar en este TP, es normal al momento de hacer una regresi\u00f3n querer saber que tan bien se ajustan mis datos a la f\u00f3rmula que us\u00e9. Existen varios estad\u00edsticos para analizar esto, pero uno muy usado para regresiones lineales es el R cuadrado, que no tiene nada que ver con el lenguaje de programaci\u00f3n y es un estad\u00edstico que va entre 0 y 1 y cuanto m\u00e1s cerca de 1 es mejor es el ajuste lineal (simplificando infinitamente el tema).</p> <p>En el ejemplo anterior podemos conseguir el R cuadrado haciendo:</p> <pre><code>r_cuadrado &lt;- summary(regresion_lineal)$r.squared\n</code></pre>","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#paso-4-ejercicio","title":"Paso 4 - Ejercicio","text":"<p>2) Creen un nuevo script de R, copien el siguiente c\u00f3digo y guardenlo en su carpeta de trabajo. Vayan avanzando por el script y cambien las secciones que dicen <code>@@EDITAR@@</code> por lo que corresponda (esto puede ser un valor, una variable, una operaci\u00f3n matem\u00e1tica, una comparaci\u00f3n o una funci\u00f3n de R).</p> <pre><code>#Aca hay que poner el Path Absoluto que apunta a su carpeta de trabajo\n#Por ej: \"/home/ibioinfo/Documentos/data_TPPb\"\nsetwd(@@EDITAR@@)\n\nlibrary(data.table)\n\n#Leo los datos ya parseados y formateados\ndt_parsed_formatted_data &lt;- fread(@@EDITAR@@)\n\n#Para cada combinaci\u00f3n de compuesto y concentraci\u00f3n quiero saber la velocidad de la reacci\u00f3n, es decir, \n#la pendiente de la recta que sale de hacer una regresi\u00f3n lineal por los 4 tiempos ensayados\n\n#Creo la tabla vac\u00eda donde voy a guardar estos datos\ndt_velocidades_de_reaccion &lt;- data.table(compuesto = character(),\n                                         concentracion = numeric(),\n                                         velocidad = numeric())\n\n#Voy a tener que recorrer todas las combinaciones de compuestos y concentraciones\n#Consigo vectores con cada compuesto diferente y con cada concentraci\u00f3n diferente\nunique_compuestos &lt;- unique(dt_parsed_formatted_data$compuesto)\nunique_concentraciones &lt;- @@EDITAR@@\n\nfor (compuesto_for in unique_compuestos) {\n    # compuesto_for &lt;- unique_compuestos[1]\n\n    for (concentracion_for in unique_concentraciones) {\n        # concentracion_for &lt;- unique_concentraciones[1]\n\n        #Por cada combinacion de compuesto + concentraci\u00f3n quiero calcular la velocidad de reacci\u00f3n\n        #Para eso lo primero que necesito hacer es filtrar los datos de *dt_parsed_formatted_data*, para quedarme solo\n        #con aquellas signals que correspondan al compuesto y concentraci\u00f3n de la iteraci\u00f3n actual del *for*\n        sub_dt_parsed_formatted_data &lt;- dt_parsed_formatted_data[(compuesto == @@EDITAR@@) &amp; (@@EDITAR@@)]\n\n        #Calculo la regresi\u00f3n lineal usando los datos de *sub_dt_parsed_formatted_data* y considerando a\n        #*segundos_totales* como el X y a *signal* como el Y\n        regresion_lineal &lt;- lm(data = sub_dt_parsed_formatted_data, formula = signal ~ segundos_totales)        \n\n        #Extraigo la pendiente, que es el segundo elemento del elemento *coefficients*\n        velocidad_de_reaccion &lt;- regresion_lineal$coefficients[2]\n\n        #Creo una nueva fila para agregar a mi tabla de velocidades de reacci\u00f3n\n        #Esta fila corresponde al compuesto y a la concentraci\u00f3n de esta iteraci\u00f3n de los *fors*, asi como\n        #la velocidad que acabo de calcular\n        new_row_dt_velocidades_de_reaccion &lt;- data.table(compuesto = @@EDITAR@@,\n                                                         concentracion = @@EDITAR@@,\n                                                         velocidad = @@EDITAR@@)\n\n        #Agrego la nueva fila recien creada a mi tabla en donde guardo todas las velocidades\n        dt_velocidades_de_reaccion &lt;- @@EDITAR@@\n    }   \n}\n\n#Escribo los datos en una nueva tabla\nwrite.table(dt_velocidades_de_reaccion, file = \"04_velocidades_de_reaccion.tsv\", col.names = T, row.names = F, sep = \"\\t\", quote = T)\n</code></pre> <p>Si todo sali\u00f3 bien, el archivo 04_velocidades_de_reaccion.tsv deber\u00eda ser una tabla del estilo:</p> compuesto concentracion velocidad \"Umbrella1\" 200 633.30896128865 \"Umbrella1\" 133.3333333 672.561474192526 \"Umbrella1\" 88.88888889 710.350673411048 \"Umbrella1\" 59.25925926 630.08948130777 \"Umbrella1\" 39.50617284 720.288720371885 ... ... ... <p>(s\u00ed, los decimales son horribles, en un ratito los arreglamos)</p>","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#paso-5-calcular-y-plotear-ic-50","title":"Paso 5 - Calcular y plotear IC 50","text":"<p>Primero que nada tenemos que definir un par de conceptos:</p> <p>Vamos a llamar velocidad de reacci\u00f3n base a la velocidad de reacci\u00f3n de la enzima cuando no tiene ning\u00fan inhibidor, o lo que es lo mismo, cuando la concentraci\u00f3n del inhibidor es 0. En nuestro caso tenemos 22 wells donde la concentraci\u00f3n del inhibidor es 0, por lo que vamos a calcular a la velocidad de reacci\u00f3n base como el promedio de las velocidades en esos 22 wells.</p> <p>Vamos a llamar actividad a la relaci\u00f3n entre la velocidad de reacci\u00f3n observada al usar una concentraci\u00f3n dada de un compuesto, y la velocidad de reacci\u00f3n base. Es decir:</p> \\[ actividad = \\frac{velocidadReaccion}{velocidadReaccionBase} \\] <ul> <li>Si no hay inhibidor o si la concentraci\u00f3n del inhibidor es muy baja para que haga efecto  Actividad ~ 1</li> <li>Si no hay enzima o si estoy usando un inhibidor perfecto  Actividad ~ 0</li> </ul> <p>Ahora s\u00ed, queremos calcular una curva de dosis-respuesta para ver como es afectada nuestra enzima Z por diferentes concentraciones de cada uno de los 22 compuestos. En general es esperable que:</p> <ul> <li>A muy bajas concentraciones del compuesto no hay efecto sobre la enzima, por lo que estoy viendo la una actividad cercana a 1. Esto quiere decir que esperamos ver varias concentraciones bajas de un compuesto que muestren la misma actividad.</li> <li>A muy altas concentraciones del compuesto ya est\u00e1 saturado el efecto que \u00e9l pueda hacer sobre la enzima (por ejemplo todos los sitios de uni\u00f3n ya est\u00e1n ocupados), por lo que estoy viendo el m\u00e1ximo efecto que puede hacer dicho compuesto a la actividad de la enzima. Esto quiere decir que esperamos ver varias concentraciones altas que muestren la misma actividad.</li> <li>Las concentraciones intermedias son aquellas en donde una variaci\u00f3n en la concentraci\u00f3n del compuesto produce un cambio en la actividad de la enzima.</li> </ul> <p>Est\u00e1s tres propiedades hacen que la curva dosis-respuesta tenga una forma sigmoidea, es decir:</p> <p></p> <p>Donde en nuestro caso la respuesta va a ser la actividad y la dosis va a ser la concentraci\u00f3n de nuestro compuesto. Dependiendo de las concentraciones elegidas, es normal ver que el eje X de este plot est\u00e9 en escala logar\u00edtmica.</p> <p>En el plot est\u00e1 marcado el IC 50, el cual es la concentraci\u00f3n del compuesto a la cual la actividad de la enzima cae al 50% (es decir, cuando la velocidad de reacci\u00f3n es la mitad que la velocidad de reacci\u00f3n base). El IC 50 da informaci\u00f3n de donde est\u00e1 el rango de concentraciones de dicho compuesto que hacen variar la actividad enzim\u00e1tica, entre otras cosas.</p>","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#herramientas","title":"Herramientas","text":"","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#instalar-paquetes-de-r","title":"Instalar paquetes de R","text":"<p>Para calcular el IC 50 vamos a ajustar nuestros datos a una curva sigmoidea, para lo cual vamos a instalar un paquete de R llamado <code>nplr</code> que hace estos c\u00e1lculos por nosotros.</p> <p>1) Para instalar un paquete corran en R la l\u00ednea:</p> <pre><code>install.packages(\"nplr\")\n</code></pre> <p>Y recuerden que cuando lo quieran usar tienen que cargarlo usando <code>library(nplr)</code> o <code>library(\"nplr\")</code>. Como es bastante avanzado no vamos a hablar de <code>nplr</code> por ahora y les vamos a dar esa parte del c\u00f3digo ya hecha.</p>","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#crear-y-modificar-columnas","title":"Crear y modificar columnas","text":"<p>Una cosa m\u00e1s que tenemos que aprender con los Data Tables es como agregar una columna nueva, o como modificar una columna ya existente. Esto se hace simplemente asign\u00e1ndole el nuevo valor a la columna como si fuera una variable o vector, solo que es importante que el nuevo valor sea o un solo elemento o un vector con longitud igual al n\u00famero de filas de la tabla.</p> <p>2) Corran el siguiente ejemplo y vean lo que devuelve.</p> <pre><code>library(data.table)\n\ndt_iris &lt;- as.data.table(iris)\n\n#Creo nuevas columnas\n\n#Si le paso un valor solo toda esa columna va a tener ese valor\ndt_iris$nueva_columna &lt;- 1\n\n#De otra forma tengo que pasarle un vector con longitud igual al numero de filas\n#Este vector puede ser combinaci\u00f3n de otras de las columnas de la tabla\ndt_iris$otra_nueva_columna &lt;- dt_iris$Sepal.Length + dt_iris$Petal.Length - 1\n\n#Me arrepenti del valor que cree en la columna al principio\ndt_iris$nueva_columna &lt;- 5\n\nprint(dt_iris)\n</code></pre>","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#crear-plots-en-pdfs","title":"Crear plots en PDFs","text":"<p>Nosotros sabemos crear plots en RStudio, pero hay veces donde uno tiene que hacer decenas (o miles) de plots y quiere guardarlos todos en un solo proceso. R tiene varias funciones que nos permiten guardar los plots como .jpg, .png, .svg, etc. Ac\u00e1 nos vamos a enfocar en la funci\u00f3n que nos permite guardarlos como .pdf.</p> <p>3) Corran el siguiente ejemplo y vean lo que devuelve (va a crear un archivo en su Working Directory).</p> <pre><code>pdf(\"test.pdf\", width = 7, height = 7)\n\nplot(x = iris$Sepal.Length,\n     y = iris$Petal.Length)\n\nplot(x = iris$Sepal.Width,\n     y = iris$Petal.Width)\n\nplot(x = iris$Species,\n     y = iris$Petal.Length)\n\ndev.off()\n</code></pre> <p>Los par\u00e1metros <code>width</code> y <code>height</code> indican el tama\u00f1o en pulgadas de cada p\u00e1gina en el pdf. Noten que a partir que abren el pdf los plots ya no van a aparecer en la pesta\u00f1a Plots de RStudio hasta que cierren el pdf (se podr\u00eda pensar que redirige la salida del plot al archivo pdf).</p> <p>Tip - Resetear los gr\u00e1ficos</p> <p>A veces pasa que un pdf queda abierto m\u00e1s de lo que deber\u00eda y no se cierra bien, o que no se crea como deber\u00eda. En estos casos pueden usar la funci\u00f3n <code>graphics.off()</code> antes y despu\u00e9s del c\u00f3digo anterior (especialmente antes) para limpiar cualquier cosa abierta. Solo tengan en cuenta que esto va a vaciarles los plots que tengan guardados en el panel Plots de RStudio.</p>","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#la-verdad-de-la-funcion-plot","title":"La verdad de la funci\u00f3n <code>plot</code>","text":"<p>Nosotros acabamos de ver unos plots hechos con la funci\u00f3n <code>plot()</code>, que es la forma de plotear por defecto en R. Sin embargo <code>plot</code> no solo plotea cosas pas\u00e1ndole un X y un Y, sino que tambi\u00e9n es una funci\u00f3n que de pasarle ciertos tipos de variables (como puede ser una regresi\u00f3n log\u00edstica) usa un plot interno de dichas variables. </p> <p>El paquete <code>nplr</code> trae sus propios plots que se van a hacer mediante <code>plot(regresion_logistica)</code>. Esto no es \u00fanico de este paquete y existen otras librer\u00edas, por ejemplo de filogenia, que tienen este mismo funcionamiento, donde <code>plot</code> hace \u00e1rboles filogen\u00e9ticos.</p>","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#google-o-chatgpt-u-otra-ia-unico-caso-en-el-que-esta-permitido","title":"Google o ChatGPT u otra IA (UNICO CASO EN EL QUE EST\u00c1 PERMITIDO)","text":"<p>Es muy importante al momento de programar saber buscar funcionalidades que uno quiere usar en sus programas.</p> <p>4) Busquen en internet:</p> <ul> <li>C\u00f3mo se calcula el m\u00e1ximo de los elementos de un vector de n\u00fameros en R</li> <li>C\u00f3mo se calcula el m\u00ednimo de los elementos de un vector de n\u00fameros en R</li> <li>C\u00f3mo se calcula el promedio de los elementos de un vector de n\u00fameros en R</li> <li>C\u00f3mo se redondea los decimales de un n\u00famero en R</li> </ul>","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#paso-5-ejercicio","title":"Paso 5 - Ejercicio","text":"<p>5) Creen un nuevo script de R, copien el siguiente c\u00f3digo y gu\u00e1rdenlo en su carpeta de trabajo. Vayan avanzando por el script y cambien las secciones que dicen <code>@@EDITAR@@</code> por lo que corresponda (esto puede ser un valor, una variable, una operaci\u00f3n matem\u00e1tica, una comparaci\u00f3n o una funci\u00f3n de R).</p> <p>Warnings en el c\u00f3digo</p> <p>Al ejecutar el siguiente c\u00f3digo les va a aparecer por consola varios Warnings de <code>nplr</code> sobre el fiteo del modelo y la predicci\u00f3n del IC 50. Los Warnings son advertencias, las cuales informan eventos que pueden o no causar problemas. Si bien es importante prestarle atenci\u00f3n a estos Warnings cuando aparecen, en este caso ya est\u00e1n contemplados y pueden ignorarlos.</p> <pre><code>#Aca hay que poner el Path Absoluto que apunta a su carpeta de trabajo\n#Por ej: \"/home/ibioinfo/Documentos/data_TPPb\"\nsetwd(@@EDITAR@@)\n\nlibrary(data.table)\nlibrary(nplr)\n\n#Leo los datos de las velocidades de reacci\u00f3n\ndt_velocidades_de_reaccion &lt;- @@EDITAR@@\n\n#Quiero calcular la velocidad de reacci\u00f3n base, es decir, la velocidad de reacci\u00f3n sin compuestos\n#Esto es cuando la concentraci\u00f3n del compuesto es 0\n#Nosotros tenemos uno de esos casos para cada compuesto, o sea, tenemos 22 versiones del experimento sin compuesto\n#Vamos a calcular la velocidad de reacci\u00f3n base como el promedio de esas 22 velocidades\nvelocidades_reaccion_sin_compuesto &lt;- dt_velocidades_de_reaccion[@@EDITAR@@]$velocidad\nvelocidad_reaccion_base &lt;- mean(velocidades_reaccion_sin_compuesto)\n\n#Ahora que ya las use, voy a sacar las filas que no tengan concentraci\u00f3n de compuesto \n#ya que no tiene sentido analizarlas para el IC 50\ndt_velocidades_de_reaccion &lt;- dt_velocidades_de_reaccion[concentracion &gt; 0]\n\n#Quiero calcular la actividad para cada combinaci\u00f3n de compuesto y concentraci\u00f3n\n#La actividad es la relacion entre la velocidad de reacci\u00f3n y la velocidad de reacci\u00f3n base (es decir, la division)\ndt_velocidades_de_reaccion$actividad &lt;- @@EDITAR@@\n\n#El *for* de mas adelante va a tener 2 salidas, un pdf con los plots y un tsv con los datos\n#Tengo que inicializar ambos\n\n#Abro el pdf (toda imagen que se plotee hasta que se cierre el pdf va a ir a el)\npdf(\"05_IC50_plots.pdf\", width = 7, height = 7)\n\n#Creo la tabla vac\u00eda\ndt_IC50 &lt;- data.table(compuesto = character(),\n                      actividad_minima = numeric(),\n                      actividad_maxima = numeric(),\n                      IC50 = numeric())\n\n#Recorro todos los compuestos 1 a la vez y calculo el IC 50 para cada uno\nunique_compuestos &lt;- @@EDITAR@@\n\nfor (compuesto_for in unique_compuestos) {\n    # compuesto_for &lt;- unique_compuestos[1]\n\n    #Por cada compuesto quiero calcular el IC 50 y plotearlo\n    #Para eso lo primero que necesito hacer es filtrar los datos de *dt_velocidades_de_reaccion*, para quedarme solo\n    #con aquellas concentraciones y actividades que correspondan al compuesto de la iteraci\u00f3n actual del *for*\n    sub_dt_velocidades_de_reaccion &lt;- @@EDITAR@@\n\n    #Calculo la regresi\u00f3n sigmoidea usando los datos de *sub_dt_parsed_formatted_data* y considerando a\n    #*concentraci\u00f3n* como el X y a *actividad* como el Y\n    regresion_sigmoidea &lt;- nplr(x = sub_dt_velocidades_de_reaccion$concentracion, \n                                y = sub_dt_velocidades_de_reaccion$actividad)\n\n    #Esto es una funcion de nplr que calcula el X correspondiente a Y = 0.5, es decir, el IC 50\n    estimacion_IC50 &lt;- getEstimates(regresion_sigmoidea, targets = 0.5)\n\n    #Hay casos donde no puede calcularlo, pero en vez de devolver NA calcula el X para el Y mas cercano a 0.5\n    #Yo no quiero eso, quiero solo los X cuando Y es 0.5, y sino devolver NA\n    if (estimacion_IC50$y == 0.5) {\n        IC50 &lt;- estimacion_IC50$x\n    } else {\n        #Aca estoy asignando a mano el valor NA (sin comillas), o sea, el valor \"vacio\"\n        IC50 &lt;- NA\n    }\n\n    #Calculo la actividad minima y maxima para guardarla en el output\n    actividad_minima &lt;- min(sub_dt_velocidades_de_reaccion$actividad)\n    actividad_maxima &lt;- @@EDITAR@@\n\n    #Creo una nueva fila para agregar a mi tabla de IC 50\n    #Esta fila corresponde al compuesto de esta iteraci\u00f3n de los *fors*, asi como\n    #el IC 50 que acabo de calcular\n    new_row_dt_IC50 &lt;- data.table(@@EDITAR@@)\n\n    #Agrego la nueva fila recien creada a mi tabla en donde guardo todas las velocidades\n    dt_IC50 &lt;- @@EDITAR@@\n\n    #Ploteo la regresi\u00f3n (les recomiendo poner el numero de compuesto y el IC 50 en el titulo)\n    #Este grafico tambien tiene informacion de GOF (goodness of fit), que en este caso es el R2, y nos sirve para conocer que tan bien se ajusta el modelo a nuestros datos\n    titulo_plot &lt;- @@EDITAR@@\n    plot(regresion_sigmoidea,\n         main = titulo_plot,\n         xlab = \"Log10 Concentracion (micromolar)\",\n         ylab = \"Actividad\",\n         ylim = c(0, 1.5),\n         xaxt = \"n\")\n    #Reescribo el eje X para que se entienda que es logaritmico\n    axis(side = 1, at = c(0, 0.5, 1, 1.5, 2), labels = c(expression(10^0), expression(10^0.5), expression(10^1), expression(10^1.5), expression(10^2)))\n}\n\n#Cierro el pdf\ndev.off()\n\n#Redondeo los decimales extras de los numeros\ndt_IC50$IC50 &lt;- round(dt_IC50$IC50, 4)\ndt_IC50$actividad_minima &lt;- @@EDITAR@@\ndt_IC50$actividad_maxima &lt;- @@EDITAR@@\n\n#Escribo los datos en una nueva tabla\nwrite.table(dt_IC50, file = \"05_IC50_data.tsv\", col.names = T, row.names = F, sep = \"\\t\", quote = T)\n</code></pre> <p>Si todo sali\u00f3 bien, el archivo 05_IC50_data.tsv deber\u00eda ser una tabla del estilo:</p> compuesto actividad_minima actividad_maxima IC50 \"Umbrella1\" 0.1708 0.8627 5.2665 \"Umbrella2\" 0.3451 0.7292 2.3456 \"Umbrella3\" 0.125 0.1688 NA \"Umbrella4\" 0.1595 0.7243 2.8252 ... ... ... ... Detr\u00e1s de escenas del armado de este TP <p>Al momento de hacer este TP tuvimos que analizar nosotros los mismos datos que ahora est\u00e1n utilizando ustedes y no ten\u00edamos mucha experiencia con <code>nplr</code>.</p> <p>En las primeras versiones de este TP no estaba la condici\u00f3n <code>if (estimacion_IC50$y == 0.5)</code>, pero mirando los datos de la tabla vs los datos del plot nos dimos cuenta que algo no cerraba. Por ejemplo, el IC 50 en el \"Umbrella22\" daba 0.6851, pero miren el plot, no ten\u00eda sentido eso.</p> <p>Fuimos al for y reemplazamos la primera l\u00ednea comentada por <code># compuesto_for &lt;- unique_compuestos[22]</code>, seleccionamos solo la \u00faltima parte (sin el <code>#</code>) y la corrimos con Ctrl+Enter, lo que en este caso hizo que <code>compuesto_for</code> sea \"Umbrella22\". Ah\u00ed fuimos paso a paso por el for viendo que devolv\u00eda cada funci\u00f3n.</p> <p>Al ejecutar <code>estimacion_IC50 &lt;- getEstimates(regresion_sigmoidea, targets = 0.5)</code> el programa nos tir\u00f3 el siguiente Warning:</p> <pre><code>Warning: One (or more) of the values were greater or equal to the estimated top asymptote.\nThese values have been replaced by the maximal possible value the model can estimate.\n</code></pre> <p>Miramos entonces adentro de la variable <code>estimacion_IC50</code> y vimos que <code>estimacion_IC50$y</code> era 0.004, lo que significaba que en esta iteraci\u00f3n no est\u00e1bamos calculando el IC 50, sino el IC 0.4, que no es lo que quer\u00edamos.</p> <p>A partir de esto pusimos el <code>if</code> y le asignamos NA a IC 50 cuando el <code>y</code> no era 0.5.</p> <p>Lo comentamos m\u00e1s que nada para mostrar que el an\u00e1lisis de datos es bastante prueba y error y que es importante pensar si lo que est\u00e1n viendo tiene sentido.</p> <p>Bienvenidos a la Bioinform\u00e1tica </p>","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#paso-6-conclusiones","title":"Paso 6 - Conclusiones","text":"<p>Ahora que tenemos todos los datos que necesitamos es momento de analizarlos. Viendo el .pdf y la tabla generados en el paso anterior respondan:</p> <p>1) \u00bfPor qu\u00e9 hay casos donde el IC 50 di\u00f3 NA?</p> <p>2) En base a los plots obtenidos,</p> <ul> <li>\u00bfLes parecen suficientes nuestros datos para estar seguros de los IC 50 calculados?</li> <li>\u00bfCu\u00e1l es un compuesto donde est\u00e1n bastantes seguros de su IC 50?</li> <li>\u00bfCu\u00e1l es un compuesto donde desconf\u00edan del IC 50 calculado?</li> </ul> <p>3) \u00bfQu\u00e9 experimentos har\u00edan para tener la curva completa en \"Umbrella1\"? \u00bfY en \"Umbrella8\"?</p> <p>4) En base a lo observado, nombren dos o tres compuestos que recomendar\u00edan para inhibir a la enzima Z. \u00bfPor qu\u00e9 los eligieron?</p>","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#ejercicio-adicional-1-paso-2-limpiar-y-parsear-el-archivo","title":"Ejercicio Adicional 1 - Paso 2 - Limpiar y Parsear el Archivo","text":"<p>Leer el Paso 2 para entender el objetivo de este ejercicio.</p>","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#introduccion-y-herramientas","title":"Introducci\u00f3n y Herramientas","text":"","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#leer-y-escribir-texto-plano","title":"Leer y escribir texto plano","text":"<p>Por \"texto plano\" nos referimos a leer un archivo de texto que no tiene un formato definido (o sea no es un .csv o .tsv, por ejemplo). Esto puede ser algo como un libro, notas, o una tabla que por alguna raz\u00f3n no la queremos leer como tabla.</p> <p>La forma m\u00e1s directa de leer texto plano en R es la funci\u00f3n <code>readLines()</code>, a la cual hay que pasarle el path del archivo a leer. Esta funci\u00f3n va a devolver un vector en el cual cada elemento es una l\u00ednea del archivo le\u00eddo. Se usa:</p> <pre><code>nuevo_vector &lt;- readLines(con = \"ARCHIVO\") \n</code></pre> <p>Por otro lado tambi\u00e9n existe la funci\u00f3n inversa, que nos permite escribir un vector en un archivo de texto, donde cada elemento del vector va a ser una l\u00ednea de texto en el archivo. Esta funci\u00f3n es <code>writeLines()</code> y se usa:</p> <pre><code>writeLines(vector_con_texto, con = \"ARCHIVO_SALIDA\") \n</code></pre> <p>La funci\u00f3n <code>writeLines()</code> tambi\u00e9n se puede usar de una forma similar a <code>print</code> si no se le pasa el par\u00e1metro <code>con</code>.</p>","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#extraer-nombres-columnas","title":"Extraer nombres columnas","text":"<p>Hay varias razones por lo cual es \u00fatil extraer un vector con el nombre de las columnas de una tabla, pero hoy lo vamos a hacer para extraer informaci\u00f3n de dichos nombres.</p> <p>La funci\u00f3n <code>colnames()</code> nos devuelve un vector con el nombre de las columnas de una tabla en el orden en el que aparecen en dicha tabla. Por ej:</p> <pre><code>columnas_iris &lt;- colnames(iris)\n\nprint(columnas_iris)\n</code></pre>","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#extraer-substrings","title":"Extraer substrings","text":"<p>Muchas veces es \u00fatil extraer pedazos de strings y ya vimos una forma de hacer esto con <code>split</code>. Sin embargo, hay veces cuando no sabemos el caracter que delimita el texto que queremos extraer, pero s\u00ed sabemos su posici\u00f3n en la cadena completa. En estos casos podemos usar la funci\u00f3n <code>substring</code>:</p> <pre><code>variable_string &lt;- c(\"123456789\")\n\nsegundo_caracter &lt;- substring(variable_string, 2, 2)\n\ntercer_a_quinto_caracteres &lt;- substring(variable_string, 3, 5)\n\nseptimo_caracter_en_adelante &lt;- substring(variable_string, 7)\n</code></pre>","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#usar-una-variable-para-acceder-a-una-columna-de-un-data-table","title":"Usar una variable para acceder a una columna de un Data Table","text":"<p>A veces pasa que quiero acceder a una variable de una tabla, pero no se previamente a cual. Aca nos va a ser \u00fatil otra forma de acceder a las columnas de las tablas, por ejemplo:</p> <pre><code># Los 3 bloques siguientes devuelven lo mismo\n\niris$Species\n\niris[[\"Species\"]]\n\ncolumna &lt;- \"Species\"\niris[[columna]]\n</code></pre>","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#ahora-si-ejercicio-completar-el-script","title":"Ahora s\u00ed: Ejercicio. Completar el script!","text":"<pre><code>library(@@EDITAR@@)\n\n#### Paso 2a - LIMPIAR DATOS ####\n#Uso readLines para cargar el archivo de texto plano\nplain_text_data &lt;- readLines(con = \"00_datos_filtermax.txt\")\n\n#La fila 2 es el header\n#Las filas 3 a 6 son los datos\n#Las demas no me interesan\nplain_text_data &lt;- plain_text_data[c(2:6)]\n\n#Escribo los datos en un nuevo archivo\nwriteLines(plain_text_data, con = \"01_datos_filtermax_limpios.tsv\")\n\n#### Paso 2b - PARSEAR DATOS ####\n#Uso fread para cargar la tabla con los datos como salen de FilterMax (pero sin lineas extras)\n#Aca es importante recordar que ten\u00edamos NAs en nuestros datos y que estaban escritos como *nada*, es decir, \"\"\nclean_data &lt;- @@EDITAR@@\n\n#Viendo clean_data pueden ver una columna extra al final llamada V387 (debido a la cantidad de tabs al final del archivo)\n#Ese es el nombre que le da data.tables por defecto a las columnas sin nombre (esta es la columna 387)\n#Para que no moleste la sacamos\nclean_data &lt;- clean_data[, @@EDITAR@@]\n\n#Los numeros (columnas de la placa well) son los compuestos\n#Las letras (filas de la placa well) son las diferentes concentraciones\n#Queremos poner los mismos datos en una tabla donde nos sea mas facil filtrar un dato espec\u00edfico\n#Creo la tabla vac\u00eda donde voy a guardar estos datos\ndt_parsed_data &lt;- data.table(time = @@EDITAR@@,\n                             temperature = numeric()\n                             fila = @@EDITAR@@,\n                             columna = numeric(),\n                             signal = @@EDITAR@@)\n\n#Hay varias formas de hacer esto con paquetes extras o con codigos dificiles, pero por ahora vamos a \n#usar una forma un poco menos eficiente pero que se entiende un poco mas\n\n#Quiero crear una lista con todos los nombres de los wells\nwells_names &lt;- colnames(clean_data)\n\n#Ahora tengo lo que necesito, pero las primeras dos posiciones son Time y Temperature\n#Las saco del vector de los nombres\nwells_names &lt;- wells_names[-c(1:2)]\n\n#Voy a recorrer cada nombre de columna y extraer a que fila y a que columna del well corresponde\n#Luego voy a guardar las cuatro signals de esa columna de la tabla con la informacion que acabo de conseguir\nfor (well_name_for in wells_names) {\n    # well_name_for &lt;- wells_names[1]\n\n    #Uso substring para extraer la letra de la fila en el well\n    fila_for &lt;- substring(@@EDITAR@@)\n\n    #Uso substring para extraer el numero de la columna en el well\n    #Uso un patr\u00f3n que funcione para cualquiera de los wells por m\u00e1s que el n\u00famero tenga 1 o 2 decimales\n    columna_for &lt;- substring(@@EDITAR@@)\n\n    #Quiero guardar la columna como numero, asi que transformo la variable character en un numeric\n    #Es decir, paso de \"1\" a 1 (por ej)\n    columna_for &lt;- as.numeric(columna_for)\n\n    #Creo nuevas fila para agregar a mi tabla de datos parseados\n    #Aca fila y columna van a ser un valor \u00fanico\n    #Por otro lado, time, temperature y signal van a ser vectores de 4 valores (son las columnas de clean_data)\n    #La columna Temperature puede ser que se escriba un poco rara por problemas de caracteres\n    dt_new_rows_in_parsed_data &lt;- data.table(time = clean_data$Time,\n                                            temperature = clean_data$`Temperature(C)`,\n                                            fila = fila_for,\n                                            columna = columna_for,\n                                            signal = @@EDITAR@@)\n\n    #Agrego las nuevas filas recien creadas a mi tabla en donde guardo los datos parseados\n    dt_parsed_data &lt;- @@EDITAR@@\n}\n\n#Escribo los datos en una nueva tabla llamada \"02_datos_filtermax_parseados_NUEVO.tsv\"\nwrite.table(@@EDITAR@@)\n</code></pre> <p>Pueden comparar 02_datos_filtermax_parseados.tsv con 02_datos_filtermax_parseados_NUEVO.tsv y si todo sali\u00f3 bien deber\u00edan ser id\u00e9nticos.</p>","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#bibliografia","title":"Bibliograf\u00eda","text":"","tags":["practicos"]},{"location":"practicos/TPPb_Programando_en_Biologia/#consola-de-r","title":"Consola de R","text":"<ul> <li>Comando <code>help()</code></li> </ul>","tags":["practicos"]},{"location":"practicos/TPXX_Filogenia/","title":"Practico Catorce","text":"","tags":["practicos"]},{"location":"practicos/TPXX_Filogenia/#tp-6-filogenias-arboles-filogeneticos-y-filogenomica","title":"TP 6. Filogenias, \u00e1rboles filogen\u00e9ticos y filogen\u00f3mica","text":"<p> Materiales</p> <p></p>","tags":["practicos"]},{"location":"practicos/TPXX_Filogenia/#videos-de-la-clase-grabada","title":"Videos de la clase grabada","text":"<ul> <li> Introducci\u00f3n al TP</li> <li> Cierre TP</li> </ul>","tags":["practicos"]},{"location":"practicos/TPXX_Filogenia/#software-a-usar","title":"Software a usar","text":"<ul> <li> <p>Alineamientos: emma y clustalw (en EMBOSS suite)</p> </li> <li> <p>Visualizaci\u00f3n de alineamientos: Jalview www.jalview.org</p> </li> <li> <p>M\u00e9todos basados en distancias:</p> <ul> <li>fprotdist (en EMBOSS suite) </li> <li>fneighbor (en EMBOSS suite) </li> </ul> </li> <li> <p>M\u00e9todos de b\u00fasqueda de \u00e1rboles:</p> <ul> <li>fproml (en EMBOSS suite)</li> <li>fprotpars (en EMBOSS suite)</li> </ul> </li> <li> <p>Visualizaci\u00f3n de \u00e1rboles: FigTree  tree.bio.ed.ac.uk/software/figtree/</p> </li> <li>Remuestreo y \u00e1rbol consenso:<ul> <li>fseqboot (en EMBOSS suite)</li> <li>fconsense  (en EMBOSS suite)</li> </ul> </li> </ul>","tags":["practicos"]},{"location":"practicos/TPXX_Filogenia/#objetivos","title":"Objetivos","text":"<ul> <li>Familiarizarse con el uso de \u00e1rboles filogen\u00e9ticos</li> <li>Entender como leer \u00e1rboles simples</li> <li>Entender las distintas representaciones de \u00e1rboles filogen\u00e9ticos</li> <li>Entender las diferenicias entre los distintos algoritmos para la construcci\u00f3n de \u00e1rboles filogen\u00e9ticos</li> </ul>","tags":["practicos"]},{"location":"practicos/TPXX_Filogenia/#filogenia","title":"Filogenia","text":"<p>La filogen\u00e9tica es la ciencia que estudia las relaciones evolutivas entre entidades biol\u00f3gicas, frecuentemente especies, individuos, genes o prote\u00ednas. Es decir, que estima el pasado evolutivo basado en la comparaci\u00f3n de caracteres morfol\u00f3gicos o moleculares como secuencias de ADN o prote\u00edna.</p> <p>Una filogenia, es un \u00e1rbol (filogen\u00e9tico, claro) que describe la secuencia de eventos que llev\u00f3 a la distribuci\u00f3n de caracteres que observamos en la actualidad. Pero la secuencia de eventos y los eventos del pasado son desconocidos, es decir, se infieren.</p> <p>Por lo tanto, un \u00e1rbol filogen\u00e9tico es una hip\u00f3tesis evolutiva</p> <p>Los \u00e1rboles filogen\u00e9ticos est\u00e1n compuestos por: Ramas (o ejes) y Nodos. Ambos pueden ser internos o externos.</p> <ul> <li> <p>Los nodos externos (hojas del \u00e1rbol o terminales) son las secuencias o especies actuales (o eventos observados) a partir de las cuales se construy\u00f3 el \u00e1rbol.</p> </li> <li> <p>Los nodos internos son las secuencias o especies ancestrales inferidas. Corresponden al \u00faltimo ancestro com\u00fan hipot\u00e9tico de todo lo que est\u00e1 debajo de \u00e9l, es decir de los descendientes. Los nodos internos son los puntos en los cuales dos o m\u00e1s ramas divergen.</p> </li> <li> <p>Por \u00faltimo, las ramas conectan nodos ancestrales con sus descendientes.</p> </li> </ul> <p></p> <p>Los \u00e1rboles pueden representarse de diversas maneras. Seg\u00fan el significado de la longitud de la rama podemos distinguir entre:</p> <ul> <li> <p>el cladograma, donde cada rama representa \u00fanicamente la transici\u00f3n evolutiva entre un nodo ancestral y sus descendientes independientemente de la longitud. La longitud de la rama no corresponde con informaci\u00f3n alguna m\u00e1s all\u00e1 de los agrupamientos.</p> </li> <li> <p>el filograma , donde la longitud de cada rama es proporcional al n\u00famero de cambios que existe entre un ancestro y sus descendientes, calculada a partir de la similitud entre los nodos que conectan. Por lo tanto, mientras m\u00e1s largas son las ramas mayor es la divergencia entre eventos que une.</p> </li> </ul> <p></p> <p>Por \u00faltimo, los \u00e1rboles pueden poseer ra\u00edz (Rooted) o no poseer ra\u00edz (Unrooted). La ra\u00edz es el punto m\u00e1s antiguo del \u00e1rbol y marca el orden de ramificaci\u00f3n del mismo, es decir, qui\u00e9n comparte un ancestro m\u00e1s reciente con qui\u00e9n. La forma m\u00e1s frecuente de ubicar la ra\u00edz del \u00e1rbol es a trav\u00e9s de un outgroup: un punto externo de referencia.</p> <p>Un outgroup puede ser cualquier secuencia que no sea un miembro natural del grupo de inter\u00e9s. Cuando uno no cuenta con un elemento que pueda usarse como referencia, la ra\u00edz suele ubicarse en el medio del \u00e1rbol, o aun mejor, no se coloca en ning\u00fan lado.</p>","tags":["practicos"]},{"location":"practicos/TPXX_Filogenia/#ejercicios-paso-por-paso-hacia-un-arbol","title":"Ejercicios: Paso por paso hacia un \u00e1rbol","text":"","tags":["practicos"]},{"location":"practicos/TPXX_Filogenia/#paso-1-construccion-del-dataset-recoleccion-de-datos","title":"Paso 1. Construcci\u00f3n del dataset: Recolecci\u00f3n de datos","text":"<p>Un \u00e1rbol filogen\u00e9tico se construye a partir de un alineamiento m\u00faltiple que a su vez debe calcularse a partir de un conjunto de secuencias representativas. La topolog\u00eda de el o los \u00e1rboles resultantes va a depender mucho de la cantidad y calidad de los datos que utilicemos. </p> <p>Tener en cuenta:</p> <p>Generalmente la mayor cantidad de tiempo y esfuerzo se invierten en este paso ya que un set de datos ruidoso puede llevarnos a resultados err\u00f3neos y por lo tanto a conclusiones inv\u00e1lidas.</p> <ul> <li> <p>Recolecci\u00f3n de secuencias: En la pr\u00e1ctica, la obtenci\u00f3n de secuencias puede realizarse como ya se vi\u00f3 en este curso, utilizando herramientas como PSI-BLAST para identificar secuencias hom\u00f3logas distantes y evitar aquellas que comparten similitud de secuencia pero no estructura/funci\u00f3n.</p> </li> <li> <p>Curaci\u00f3n: Las secuencias recolectadas luego deben ser sometidas a una meticulosa curaci\u00f3n, donde se eliminan secuencias redundantes, incompletas o con errores detectables. Incluso pueden realizarse pasos de modelado de estructura para validar la pertinencia de las mol\u00e9culas al grupo de prote\u00ednas que se desea utilizar.</p> </li> </ul> <p>Atenci\u00f3n:</p> <p>En este trabajo pr\u00e1ctico, por cuestiones de tiempo, se les entrega un conjunto de secuencias seleccionadas y curadas. Pero... tengan presente a la hora de hacer sus propias filogenias que se debe prestar m\u00e1xima atenci\u00f3n al acondicionamiento de los datos.</p> <p>Se utilizar\u00e1n las secuencias contenidas en el archivo <code>Ribonucleasas.fasta</code> cuyos datos asociados pueden encontrarlos en el <code>Ribonucleasas_organismos.pdf</code>. </p> <p>En el archivo multiFASTA contiene 64 secuencias proteicas de ribonucleasas pancre\u00e1ticas de diversos animales. Si observan el archivo <code>Ribonucleasas_organismos.pdf</code> pueden ver que todas pertenecen a mam\u00edferos placentarios, excepto por nuestro viejo amigo el canguro, que como despist\u00f3 a m\u00e1s de uno en el trabajo pr\u00e1ctico de Alineamientos se gan\u00f3 su lugar.</p>","tags":["practicos"]},{"location":"practicos/TPXX_Filogenia/#paso-2-construccion-y-curacion-del-alineamiento-multiple","title":"Paso 2. Construcci\u00f3n y Curaci\u00f3n del Alineamiento m\u00faltiple","text":"<p>Para este paso se utilizar\u00e1 la herramienta de EMBOSS del trabajo pr\u00e1ctico anterior: <code>emma</code></p> <p>Por si no recuerdan,<code>emma</code> utiliza los siguientes argumentos:</p> <ul> <li> <p><code>-sequence</code>: Se indica la ENTRADA que es un archivo multiFASTA</p> </li> <li> <p><code>-outseq</code>: Se guarda una de las dos SALIDAS. En este caso, el nombre del archivo donde se guardar\u00e1n las secuencias con los gaps incluidos para su debido alineamiento.</p> </li> <li> <p><code>-dendoutfile</code>: Se guarda la segunda de las dos SALIDAS. En este caso, el nombre del archivo donde se guarda un dendograma que sirve de gu\u00eda para el alineamiento.</p> </li> </ul> <pre><code>emma -sequence Ribonucleasas.fasta -dendoutfile Ribonucleasas.dend -outseq Ribonucleasas.msa\n</code></pre> Recordatorio instalaci\u00f3n de ClustalW <p>Recuerden que <code>emma</code> utiliza <code>clustalw</code>. En el TP de alineamientos ya fue instalado pero si tuvieran que instalarlo, pueden hacerlo ingresando:</p> <p><code>sudo apt-get install clustalw</code></p> <p>Inspeccionen el archivo <code>Ribonucleasas.msa</code> y respondan:</p> <p>2.1. \u00bfQu\u00e9 diferencia principal se ve en este archivo comparado con el archivo <code>Ribonucleasas.fasta</code> ?</p> <p>2.2. Este archivo, \u00bfPermite visualizar r\u00e1pidamente si hay regiones conservadas o con muchos gaps a simple vista? \u00bfRecord\u00e1s el comando necesario para una mejor visualizaci\u00f3n?</p> Clicke\u00e1 para ver el comando <p>Para una mejor visualizaci\u00f3n se puede utilizar el comando <code>showalign</code> que ya hemos utilizado anteriormente con la opci\u00f3n -show A para que no reemplace las bases conservadas por puntos:</p> <pre><code>showalign -show A -sequence Ribonucleasas.msa -outfile Ribonucleasas.showalign  \nless Ribonucleasas.showalign\n</code></pre> <p>La premisa b\u00e1sica de los alineamientos m\u00faltiples es que, en cada columna del alineamiento, cada residuo de cada secuencia sea hom\u00f3logo; osea, ha evolucionado de la misma posici\u00f3n en un ancestro com\u00fan. Cuando esto se cumple, se puede obtener much\u00edsima informaci\u00f3n de un alineamiento m\u00faltiple sobre estructura, funci\u00f3n, modo de evoluci\u00f3n y, por supuesto, filogenia. Sin embargo, las conclusiones a las que lleguemos van a depender mucho de la calidad del alineamiento m\u00faltiple.</p> <p>Es muy importante revisar los alineamientos</p> <p>Un alineamiento m\u00faltiple de mala calidad en el mejor de los casos no nos va a dar informaci\u00f3n \u00fatil, pero... en el peor de los casos nos va a dar informaci\u00f3n err\u00f3nea muy convincente.</p> <p>Por esta raz\u00f3n es muy importante revisar los alineamientos m\u00faltiples (es decir, curarlos).</p> <p>Los algoritmos de alineamiento utilizan heur\u00edsticas y aproximaciones que pueden (y suelen) dar lugar a errores. Por ello muchas veces (o siempre) es necesario  curar manualmente los alineamientos, eliminando o agregando gaps. Tambi\u00e9n se puede recurrir a la eliminaci\u00f3n de columnas completas si contienen una gran mayor\u00eda de gaps o hay dudas sobre su veracidad. En muchos casos, es mejor eliminar estos eventos para deshacernos del ruido.</p> <p>Dado que el curado de un alineamiento para filogen\u00e9tica es un proceso cr\u00edtico y muy \"visual\", existen herramientas m\u00e1s apropiadas (y vistosas) para esta tarea que <code>showalign</code>. El visualizador de alineamientos a utilizar se llama Jalview. </p> <p>Jalview requiere la instalaci\u00f3n de la versi\u00f3n 8 de java. Para instalar ejecute en su terminal:</p> <pre><code>sudo apt install openjdk-8-jdk openjdk-8-jre\nsudo update-java-alternatives --set /usr/lib/jvm/java-1.8.0-openjdk-i386\n</code></pre> <p>Preferentemente desde una nueva terminal, pueden ejecutar Jalview:</p> <pre><code>cd ~/Tools/Jalview\nbash jalview.sh\n</code></pre> <p>Cuando abren el programa hay algunas ventanas abiertas. Cierren todo. Adem\u00e1s ignoren la \"barra de avance\" que se encuentra en la parte inferior de la ventana.</p> <p>Una vez abierto el programa, carguen el alineamiento generado por <code>emma</code> (<code>Ribonucleasas.msa</code>) haciendo click en:</p> <p><code>Archivo</code> &gt; <code>Alineamiento de entrada</code> &gt; <code>Desde fichero</code>.</p> <p>Esto abrir\u00e1 una ventana en la que se puede buscar el archivo yendo a la carpeta de trabajo.</p> <p>Atenci\u00f3n</p> <p>Por defecto, Jalview NO ve el archivo. Aseg\u00farense de seleccionar TODOS LOS ARCHIVOS en el men\u00fa desplegable de Archivos de Tipo</p> <p></p> <p>Para colorear el alineamiento vayan a:</p> <p><code>Color</code> &gt; <code>ClustalX</code></p> <p>2.3. Revisen su alineamiento con Jalview para ver si hay errores o posiciones dudosas y, en caso de encontrarlos, corr\u00edjanlos en <code>Ribonucleasas.msa</code> y guarden en <code>Ribonucleasas.curado.msa</code>!</p> <p>Eliminar columnas</p> <p>En la parte superior pueden seleccionar columnas del alineamiento y luego presionan delete para eliminarlas. </p>","tags":["practicos"]},{"location":"practicos/TPXX_Filogenia/#paso-3-construccion-del-arbol","title":"Paso 3. Construcci\u00f3n del \u00c1rbol","text":"<p>Los m\u00e9todos para llevar a cabo la filogenia se pueden separar en dos categor\u00edas generales:</p> <ul> <li> <p>M\u00e9todos basados en distancia, tambi\u00e9n conocidos como de clustering o algor\u00edtmicos: UPGMA, neighbour-joining, Fitch\u2013Margoliash.</p> </li> <li> <p>M\u00e9todos de b\u00fasqueda de \u00e1rboles o discretos: m\u00e1xima parsimonia, maximum likelihood (m\u00e1xima verosimilitud), m\u00e9todos bayesianos.</p> </li> </ul>","tags":["practicos"]},{"location":"practicos/TPXX_Filogenia/#parte-i-metodos-basados-en-distancias-neighbor-joining-y-upgma","title":"Parte I. M\u00e9todos basados en distancias: Neighbor Joining y UPGMA","text":"<p>El funcionamiento de estos es relativamente sencillo. Se cuenta con un solo par\u00e1metro: la distancia, que se calcula entre todos los elementos con los que vamos a construir el \u00e1rbol (OTUs por sus siglas en ingl\u00e9s: Operational Taxonomic Unit), el cual es utilizado para ensamblar el \u00e1rbol agrupando elementos cercanos.</p>","tags":["practicos"]},{"location":"practicos/TPXX_Filogenia/#metodo-neighbor-joining","title":"M\u00e9todo Neighbor-Joining.","text":"<p>Este m\u00e9todo se puede utilizar usando el comando <code>fneighbor</code>. Pero debemos instalarlo:</p> <pre><code>sudo apt install embassy-phylip\n</code></pre> <p>Este comando construye un \u00e1rbol a partir de una matriz de distancias, haciendo clustering de sus elementos, utilizando los valores de la matriz para calcular el largo de las ramas. El \u00e1rbol resultante es un \u00e1rbol sin ra\u00edz, lo que quiere decir es que las distancias son relativas entre los miembros y no hay informaci\u00f3n sobre qu\u00e9 evento se produjo primero (no hay un reloj evolutivo).</p> <p>Para poder calcular el \u00e1rbol primero es necesario obtener la matriz de distancias, mediante el comando <code>fprotdist</code>.</p> <p>Este comando utiliza uno de cinco m\u00e9todos para calcular las distancias:</p> <ul> <li>PAM: Utiliza una matriz PAM 001. La matriz PAM es una matriz de sustituci\u00f3n obtenida emp\u00edricamente. El n\u00famero 001 indica que las secuencias con las que se construy\u00f3 tienen una tasa de mutaci\u00f3n esperada del 1% (<code>-method d</code>).</li> <li>JTT: Nombrado por sus creadores, Jones, Taylor y Thornton, se basa en el mismo concepto que el m\u00e9todo PAM, solo que la matriz de sustituci\u00f3n fue creada con un set de datos mucho m\u00e1s grande (<code>-method j</code>).</li> <li>PBM: Las matrices de este modelo derivan de la base de datos Blocks que contiene secuencias de dominios conservados (<code>-method h</code>).</li> <li>Kimura Formula: Una aproximaci\u00f3n precalculada de la matriz PAM, lo que ofrece un c\u00e1lculo m\u00e1s veloz sacrificando specificidad (<code>-method k</code>).</li> <li>Similarity Table: Una proyecci\u00f3n de distancias en la que se asume que los amino\u00e1cidos var\u00edan seg\u00fan un caso particular de la f\u00f3rmula de Kimura (<code>-method s</code>). </li> </ul> <p>Los tres primeros (PAM, JTT y PBM) son los m\u00e1s ampliamente utilizados. </p> <p>Mirando el nombre del comando fprotdist y leyendo los m\u00e9todos que utiliza este comando conteste:</p> <p>\u00bfSe utiliza para construir la matriz a partir de un alineamiento de prote\u00ednas o secuencias de ADN?</p> Despu\u00e9s de contestar la pregunta anterior <p>\u00bfC\u00f3mo cree que se llama el comando para construir la matriz a partir de secuencias de ADN?</p> <p>\u00bfCree que utiliza los mismos m\u00e9todos que el comando utiliza para prote\u00ednas?</p> <p>Chequee su respuesta en EMBOSS !!!!</p> <p>3.I.1 Construya la matriz de distancia utilizando el m\u00e9todo JTT:</p> <pre><code>fprotdist -method j -sequence Ribonucleasas.curado.msa -outfile Ribonucleasas.dist\n</code></pre> <p>3.I.2 \u00bfQu\u00e9 son los siguientes par\u00e1metros del comando?</p> <ul> <li> <p><code>-sequence</code></p> </li> <li> <p><code>-outfile</code></p> </li> </ul> <p>Ahora si, con las distancias calculadas se puede comenzar a agrupar.</p> <pre><code>fneighbor -datafile Ribonucleasas.dist -outfile Ribonucleasas-NJ.tree -outtreefile Ribonucleasas-NJ.treefile\n</code></pre> <p>3.I.3 Investiguen los archivos <code>Ribonucleasas.tree</code> y <code>Ribonucleasas.treefile</code> y respondan:</p> <p>a. \u00bfQu\u00e9 informaci\u00f3n tiene <code>Ribonucleasas-NJ.tree</code>?  </p> <p>b. \u00bfQu\u00e9 les parece que contiene <code>Ribonucleasas-NJ.treefile</code>? \u00bfC\u00f3mo se conoce este formato? \u00bfPor qu\u00e9 cree que es conveniente la creaci\u00f3n de este archivo?</p> <p>Si bien uno puede ver \u00e1rboles dibujados en ascii en los archivos .tree hay formas m\u00e1s armoniosas para ver un \u00e1rbol. Por lo tanto, vamos a instalar el programa: figtree</p> <pre><code>sudo apt install figtree\n</code></pre> <p>Para utilizar el programa figtree, en la terminal, ub\u00edquese en la carpeta donde tiene el archivo <code>.treefile</code> e ingrese:</p> <p></p><pre><code>figtree Ribonucleasas-NJ.treefile\n</code></pre> Para guardar la imagen y poder verla en detalle tienen que ir a: <p><code>File</code> &gt; <code>Export PDF</code></p> <p>Explore las distintas opciones de representaci\u00f3n de \u00e1rboles y grafique los \u00e1rboles como le parezca m\u00e1s correcto</p> <p>En FigTree se puede seleccionar a nivel de nodos, clados y taxas (nombres de las hojas del \u00e1rbol) y colorear de distintas maneras. </p> <p>Todo lo realizado con FigTree se puede guardar en un archivo nuevo para seguir trabajando luego o modificar una representaci\u00f3n de \u00e1rbol yendo a:</p> <p><code>File</code> &gt; <code>Save as...</code> </p> <p>3.I.4 Observen la topolog\u00eda del \u00e1rbol a diferentes niveles e identifiquen diferentes \u00f3rdenes. \u00bfTiene sentido el agrupamiento que se realiz\u00f3?</p> <p>Regla mnemot\u00e9cnica para Taxonom\u00eda</p> <p>Si a\u00fan no vieron taxonom\u00eda o si no recuerdan lo que es un Orden...</p> <p>\"Lineo dijo que el Rey (Reino) era un tipo (phylo) con mucha Clase que puso Orden en su Familia comprando un G\u00e9nero de cada Especie\"</p> <p>3.I.5 Hay algunos OTUs que no parecen estar bien ubicados. \u00bfCu\u00e1les son? \u00bfQu\u00e9 puede estar pasando?</p>","tags":["practicos"]},{"location":"practicos/TPXX_Filogenia/#metodo-upgma","title":"M\u00e9todo UPGMA.","text":"<p>La manera de generar el \u00e1rbol por el m\u00e9todo UPGMA es esencialmente la misma que Neighbor-Joining, ir agrupando los pares de elementos con la menor distancia. </p> <p>La diferencia radica en c\u00f3mo se calculan las distancias una vez que se empiezan a generar grupos.</p> <ul> <li> <p>Neighbor-Joining utiliza una metodolog\u00eda un tanto compleja que pueden encontrar explicada ac\u00e1</p> </li> <li> <p>UPGMA usa un average linking pesado por la cantidad de secuencias que componen cada grupo.</p> </li> </ul> <p>Para construir un \u00e1rbol con UPGMA corremos el comando <code>fneighbor</code> pero con la opci\u00f3n <code>-treetype u</code>:</p> <pre><code>fneighbor -treetype u -datafile Ribonucleasas.dist -outfile Ribonucleasas-UPGMA.tree -outtreefile Ribonucleasas-UPGMA.treefile\n</code></pre> <p>3.I.6 Comparen el \u00e1rbol obtenido por Neighbor-Joining y por UPGMA.    a. \u00bfHay cambios en las agrupaciones?    b. Grafiquen los resultados de ambos m\u00e9todos. Se ven diferentes \u00bfno? Investigue las razones.</p>","tags":["practicos"]},{"location":"practicos/TPXX_Filogenia/#parte-ii-metodos-de-busqueda-de-arboles-maxima-verosimilitud-y-maxima-parsimonia","title":"Parte II. M\u00e9todos de b\u00fasqueda de \u00e1rboles: M\u00e1xima Verosimilitud y M\u00e1xima Parsimonia","text":"<p>Los m\u00e9todos de b\u00fasqueda de \u00e1rboles examinan cada columna del MSA de manera individual y buscan un \u00e1rbol que mejor represente esta informaci\u00f3n.</p> <p>Este procedimiento los vuelve mas lentos que los m\u00e9todos basados en distancia, pero examinar cada posici\u00f3n por separado da un \u00e1rbol m\u00e1s acertado y brinda la posibilidad de relacionar los eventos a cada una de las posiciones.</p> <p>En este caso NO va a ser necesario calcular una matriz de distancias, podemos ejecutar el m\u00e9todo directamente sobre el alineamiento. </p>","tags":["practicos"]},{"location":"practicos/TPXX_Filogenia/#metodo-de-maxima-verosimilitud","title":"M\u00e9todo de M\u00e1xima Verosimilitud","text":"<p>Para utilizar M\u00e1xima Verosimilitud (maximum likelihood) se usa el comando <code>fproml</code>. Los argumentos de este comando son:</p> <ul> <li> <p><code>-sequence</code>: Indica el MSA de entrada</p> </li> <li> <p><code>-oufile</code>: Indica donde guardar la salida</p> </li> <li> <p><code>-intrefile</code> (opcional),  \u00c1rbol para usar de gu\u00eda. No se utilizar\u00e1 en este caso, pero lo va a preguntar igual, en ese caso se aprieta Enter.</p> </li> </ul> <pre><code>fproml -seed 1 -sequence Ribonucleasas.curado.msa -outfile Ribonucleasas-ML.tree -outtreefile Ribonucleasas-ML.treefile\n</code></pre> \u00bfQu\u00e9 es Seed? <p>Adem\u00e1s de los argumentos m\u00ednimos, se utiliz\u00f3 el argumento <code>-seed</code>. Esto es una buena pr\u00e1ctica para que el experimento sea reproducible. En computaci\u00f3n, lo que se llama random (por azar) en realidad no lo es. Para obtener n\u00fameros cuya distribuci\u00f3n se acerque a la aleatoria se aplica una serie de f\u00f3rmulas que dan un resultado dependiendo del n\u00famero del cual se parte. Este valor es la semilla (seed). Por lo general se utiliza como semilla el tiempo, el cual cambia constantemente, pero nosotros podemos fijar esa semilla, para que otras personas, o nosotros mismos en alg\u00fan futuro, podamos correr nuestros comandos y obtener exactamente los mismos resultados.</p> <p>3.II.1 Observen e interpreten la salida obtenida. \u00bfHubo cambios radicales con respecto a los \u00e1rboles anteriores?.  </p> <p>3.II.2 \u00bfCon qu\u00e9 nueva informaci\u00f3n contamos?</p> <p>Mirando el nombre del comando fproml conteste:</p> <p>\u00bfSe utiliza con secuencias de prote\u00ednas o de ADN?</p> <p>La forma correcta de sacarnos nuestra duda es corriendo:</p> <pre><code>tfm fproml\n</code></pre> Despu\u00e9s de contestar la pregunta anterior <p>\u00bfC\u00f3mo cree que se llama el comando para utilizar el m\u00e9todo maximum likelihood con secuencias de ADN?</p> <p>\u00bfCree que utiliza los mismos m\u00e9todos que el comando utiliza para prote\u00ednas?</p> <p>Chequee su respuesta en EMBOSS !!!!</p>","tags":["practicos"]},{"location":"practicos/TPXX_Filogenia/#uso-de-outgroups","title":"Uso de Outgroups","text":"<p>Hasta ahora se generaron \u00e1rboles sin raiz, donde las distancias entre los OTUs son relativas. Para colocar una ra\u00edz se utiliza un OTU que se sabe a priori que divergi\u00f3 antes que el resto, as\u00ed se obtiene una referencia a partir de la cual construir el \u00e1rbol.</p> <p>\u00a1Aprovechemos que tenemos a un intruso!</p> <p>El set de secuencias est\u00e1 compuesto casi en su totalidad por mam\u00edferos placentarios, excepto por el canguro rojo. Su aparici\u00f3n no es casualidad ya que como miembro de otra infraclase sirve de referencia para proponer una ra\u00edz al \u00e1rbol. Para ello se utiliza el argumento <code>-outgrno</code>, que recibe el n\u00famero del organismo a utilizar como referencia. Este n\u00famero esta dado por la posici\u00f3n de la secuencia en el alineamiento m\u00faltiple. Para averiguar que n\u00famero es hay dos opciones:</p> <ul> <li> <p>Contar a mano</p> </li> <li> <p>Correr un comando</p> </li> </ul> <p>Contar a mano puede llevar a errores, y dado que esto es bioinform\u00e1tica, se utilizar\u00e1 el siguiente comando:</p> <pre><code>cat Ribonucleasas.curado.msa | grep \"&gt;\" | grep -n \"Macropus\"\n</code></pre> <p>La salida se ver\u00e1 similar a esta: <code>45:&gt;Macropus_rufus</code>. La secuencia en el alineamiento en este caso est\u00e1 en la posici\u00f3n 45 pero este n\u00famero puede cambiar seg\u00fan el usuario.</p> <p>Una vez obtenido este valor se vuelve a correr <code>fproml</code></p> <pre><code>fproml -outgrno 45 -seed 1 -sequence Ribonucleasas.curado.msa -outfile Ribonucleasas-ML-OUTGR.tree -outtreefile Ribonucleasas-ML-OUTGR.treefile\n</code></pre> <p>Ventaja del M\u00e9todo de Maximum Likelihood</p> <p>ML utiliza un modelo de Markov para estimar las tasas de cambio de las diferentes posiciones y as\u00ed poder hacer c\u00e1lculos m\u00e1s precisos. Esto se debe a que no todas las posiciones var\u00edan con la misma frecuencia.</p> <p>Posiciones importantes para la estructura/funci\u00f3n de la prote\u00edna, por ejemplo el sitio activo de una enzima, tienden a variar mucho menos que el resto y esto debe ser tenido en cuenta a la hora de construir la filogenia.</p>","tags":["practicos"]},{"location":"practicos/TPXX_Filogenia/#metodo-de-maxima-parsimonia","title":"M\u00e9todo de M\u00e1xima Parsimonia","text":"<p>Genere el \u00e1rbol utilizando m\u00e1xima parsimonia con el comando <code>fprotpars</code>, utilice <code>-help</code> para ver qu\u00e9 argumentos recibe. Responda:</p> <p>3.II.3 \u00bfQu\u00e9 informaci\u00f3n nos da este m\u00e9todo?  </p> <p>3.II.4 \u00bfCu\u00e1ntos \u00e1rboles nos devuelve? \u00bfPor qu\u00e9?  </p>","tags":["practicos"]},{"location":"practicos/TPXX_Filogenia/#paso-4-tests-seleccionar-arboles-en-el-bosque","title":"Paso 4. Tests \u2013 Seleccionar \u00e1rboles en el bosque","text":"<p>Entonces, \u00bfqu\u00e9 tan bueno es nuestro \u00e1rbol?</p> <p>Uno de los test m\u00e1s simples para medir la veracidad del \u00e1rbol es el bootstrap. Hoy en d\u00eda ser\u00eda muy raro encontrar un \u00e1rbol filogen\u00e9tico que no lo haya utilizado.</p> <p>El bootstrap esencialmente prueba si todo el set de datos est\u00e1 de acuerdo con el \u00e1rbol resultante, o si dicho \u00e1rbol es un outlier entre varias otras posibilidades. Esto se hace tomando muestras aleatorias de nuestro set de datos, armando varios \u00e1rboles y calculando la frecuencia de ocurrencia de cada fragmento del \u00e1rbol. Si un agrupamiento determinado es encontrado en todos los \u00e1rboles, entonces tienen un score de 100%; si solo ocurre en \u2154 de los \u00e1rboles generados el score ser\u00e1 de 67% y as\u00ed.</p> <p>Es importante aclarar que el muestreo se hace a nivel columna del MSA, y no a nivel de secuencia. Nuestro \u00e1rbol va a establecer la relaci\u00f3n entre diferentes secuencias dada la conservaci\u00f3n/mutaci\u00f3n de posiciones hom\u00f3logas y esto es lo que se intenta probar con bootstrap: que cualquier tipo de composici\u00f3n que mantenga esos patrones de conservaci\u00f3n/mutaci\u00f3n va a dar el mismo \u00e1rbol. Por ello, vamos a tener la misma cantidad de secuencias, y del mismo largo, ya que no solo vamos a reordenar las posiciones al azar sino que tambi\u00e9n vamos a quitar y repetir columnas. En la siguiente imagen pueden ver un ejemplo de los resultados de un Bootstrapping</p> <p></p> <p>Al final de este proceso se obtiene un conjunto de alineamientos. A partir de cada alineamiento se construye un \u00e1rbol.</p> <p>Este test parece sencillo, y estudios en filogenias conocidas (poblaciones virales cultivadas en laboratorio) muestran que es una medida adecuada de la certeza del \u00e1rbol resultante; y que un valor de 70% o m\u00e1s suele indicar un agrupamiento adecuado.</p> <p>Para generar el conjunto de alineamientos se utiliza el comando <code>fseqboot</code> los argumentos son <code>-sequence</code> (datos de ENTRADA), <code>-outfile</code> (datos de SALIDA) y <code>-reps</code>:</p> <pre><code>fseqboot -reps 10 -sequence Ribonucleasas.curado.msa -outfile Ribonucleasas.boot\n</code></pre> En este comando falta algo muy importante! \u00bfLo ven? <p>Falta el seed !!!</p> <pre><code>fseqboot -reps 10 -seed 1 -sequence Ribonucleasas.curado.msa -outfile Ribonucleasas.boot\n</code></pre> <p><code>-reps</code> indica el n\u00famero de remuestreos a realizar. Calcular varios \u00e1rboles puede llevar bastante tiempo por lo que solo se har\u00e1n 10 repeticiones. En un t\u00edpico ensayo se realizan muchas m\u00e1s repeticiones.</p> <p>Exploren el archivo <code>Ribonucleasas.boot</code>. Hay varios MSA correspondientes al resmuestreo, con posiciones faltantes, repetidas y en distinto orden que el MSA original. Este archivo se utilizar\u00e1 para llevar a cabo numerosos \u00e1rboles filogen\u00e9ticos:</p> <pre><code>fproml -seed 1 -sequence Ribonucleasas.boot -outfile Ribonucleasas-ML-BOOT.tree -outtreefile Ribonucleasas-ML-BOOT.treefile\n</code></pre> <p>Esto puede tardar un rato, podr\u00eda ser un buen momento para preparar un mate...</p> <p>El archivo de salida <code>Ribonucleasas-ML-BOOT.tree</code> contiene todos los \u00e1rboles resultantes de todos nuestros muestreos. Al ser tantos, uno puede ver las diferentes topolog\u00edas creadas, sin embargo es muy dif\u00edcil sacar conclusiones.</p> <p>Para poder utilizar toda la informaci\u00f3n de estas numerosas r\u00e9plicas vamos a unirlas con el comando <code>fconsense</code>. Este toma como entrada el archivo <code>.treefile</code> que contiene todos los \u00e1rboles en formato Phyllip y los va a condensar en uno solo, anotando a cada rama la cantidad de veces que esta fue hallada en nuestros muestreo.</p> <p></p><pre><code>fconsense -intreefile Ribonucleasas-ML-BOOT.treefile -outfile Ribonucleasas-CONS.tree -outtreefile Ribonucleasas-CONS.treefile\n</code></pre> 3.II.5 Un buen ejercicio antes de copiar y pegar un comando es ENTENDER que es cada argumento del comando. \u00bfQue hace cada argumento? <ul> <li> <p><code>-intreefile</code></p> </li> <li> <p><code>-outfile</code></p> </li> <li> <p><code>-outtreefile</code></p> </li> </ul> <p>Observando el \u00e1rbol consenso. Responda:  </p> <p>3.II.6 \u00bfResulta ser un buen \u00e1rbol? \u00bfEn qu\u00e9 se basan para afirmarlo?   </p> <p>3.II.7 \u00bfC\u00f3mo podr\u00edan lidiar con nodos de baja calidad?   </p>","tags":["practicos"]},{"location":"practicos/TPXX_Filogenia/#paso-5-presentacion-de-resultados","title":"Paso 5. Presentaci\u00f3n de resultados","text":"<p>Finalmente algunos conceptos en cuanto a la presentaci\u00f3n de los datos. Por lo general no hay reglas duras de c\u00f3mo debe hacerse pero s\u00ed convenciones que est\u00e1n bastante aceptadas.</p> <ul> <li> <p>En \u00e1rboles de filogenia molecular, los largos de las ramas suelen dibujarse a escala; esto es, proporcional a la cantidad de evoluci\u00f3n que se estima ocurri\u00f3 entre los nodos que conecta. A pesar de que la relaci\u00f3n entre el largo de la rama y el tiempo real no es directa y muy probablemente no es confiable, los largos dan una idea general de las tasa de cambio relativas del \u00e1rbol.</p> </li> <li> <p>Los valores de Bootstrap deben ser presentados en forma de porcentajes, no de valores crudos, para que sea m\u00e1s sencillo de leer y comparar con otros \u00e1rboles. Por convenci\u00f3n, s\u00f3lo valores de Bootstrap del 50% o mayores son reportados; valores menores significan que la calidad del nodo encontrado es muy baja. </p> </li> <li> <p>Por \u00faltimo, tengan en cuenta la legibilidad del \u00e1rbol en general. Utilizar nombres para las ramas con c\u00f3digos de acceso a bases de datos o acr\u00f3nimos de pocas letras puede resultar muy confuso. Hoy en d\u00eda existen numerosos softwares para la visualizaci\u00f3n de \u00e1rboles (ej. Hypertree) que nos permiten, mediante agrupamientos, colores, fuentes, etc. llamar la atenci\u00f3n del lector sobre uno u otro aspecto importante del mismo y lograr que transmita la informaci\u00f3n que nos interesa mostrar.</p> </li> </ul>","tags":["practicos"]},{"location":"practicos/TPXX_Genomica_Comparativa/","title":"Practico Quince","text":"","tags":["practicos"]},{"location":"practicos/TPXX_Genomica_Comparativa/#tp-13-genomica-comparativa-act","title":"TP 13. Gen\u00f3mica comparativa: ACT","text":"<p> Materiales</p>","tags":["practicos"]},{"location":"practicos/TPXX_Genomica_Comparativa/#slides-mostrados-en-la-clase","title":"Slides mostrados en la clase","text":"<ul> <li> Slides TP</li> </ul>","tags":["practicos"]},{"location":"practicos/TPXX_Genomica_Comparativa/#videos-de-la-clase-grabada","title":"Videos de la clase grabada","text":"<ul> <li> Cierre</li> </ul>","tags":["practicos"]},{"location":"practicos/TPXX_Genomica_Comparativa/#objetivos","title":"Objetivos","text":"<ul> <li>Familiarizarse con las funciones b\u00e1sicas de ACT a trav\u00e9s de varios casos de uso.</li> <li>Entender conceptos b\u00e1sicos de gen\u00f3mica comparativa.</li> </ul>","tags":["practicos"]},{"location":"practicos/TPXX_Genomica_Comparativa/#introduccion","title":"Introducci\u00f3n","text":"<p>ACT (Artemis Comparision Tool), tambi\u00e9n creada - entre otros - por Kim Rutherford, fue dise\u00f1ada para extraer informaci\u00f3n adicional que solo puede ser obtenida a trav\u00e9s de la comparaci\u00f3n entre dos secuencias (Carver et al. 2005). </p> <p>Para trabajar con ACT es necesario proveerle al programa de tres archivos: dos de secuencias (las que voy a comparar entre s\u00ed), y uno de comparaci\u00f3n. El archivo de comparaci\u00f3n no es otra cosa que un blastn (o un tblastx) entre ambas secuencias. ACT puede leer varios formatos de archivo de comparaci\u00f3n, pero por practicidad, nosotros usaremos BLAST para generarlo. En cuanto a los archivos de secuencia, ACT puede leer el mismo tipo de archivos de secuencia de Artemis (ej. multi-fasta, genbank, embl, etc.). </p> tblastx <p>Se realiza una traducci\u00f3n de las secuencias nucleot\u00eddicas en los seis marcos abiertos de lectura (ORFs) y se compara la secuencia aminoac\u00eddica.</p>","tags":["practicos"]},{"location":"practicos/TPXX_Genomica_Comparativa/#primera-parte-preparacion-de-los-archivos-de-entrada","title":"Primera Parte: preparaci\u00f3n de los archivos de entrada","text":"<p>En esta primera parte, vamos a trabajar con dos genomas bacterianos (E. coli y S. tiphy).</p> <p>ACT necesita, adem\u00e1s de las secuencias, un archivo que contenga una comparaci\u00f3n entre ellas. Pero dado que vamos a estar intentando comparar secuencias grandes, este archivo no puede ser simplemente un alineamiento continuo de las dos secuencias. La idea es poder visualizar rearreglos (inversiones, deleciones/inserciones, transposiciones) y para ello es necesario contar con una serie de alineamientos locales delimitados, con scores definidos (por ejemplo tal como los que produce BLAST).</p> <p>Para hacer la comparaci\u00f3n, pueden usar bl2seq (BLAST 2 Sequences) en la linea de comando</p> <pre><code>bl2seq -m T -i EcK12.dna -j S_typhi.dna -p blastn -D 1 &gt; EcK12vsStiphy.blastn\n</code></pre> <p>donde <code>-m T</code> (Mega BLAST = True) indica a BLAST que debe usar el algoritmo \u200bMega BLAST para hacer el alineamiento y <code>-D 1</code> le indica que el formato de output sea tabular, que es el formato que requiere ACT.</p> Si no funciona <p>En su directorio de trabajo, tienen el archivo pre-calculado con el nombre <code>EcK12vsStiphy.blastn.pre</code>.</p>","tags":["practicos"]},{"location":"practicos/TPXX_Genomica_Comparativa/#iniciar-act","title":"Iniciar ACT","text":"<p>Para abrir el programa podemos usar la terminal: </p> <pre><code>cd ~/Tools/artemis/\n./act\n</code></pre> <p>Nota: Aunque lo parece, no es el mismo programa que el TP12!</p> <p>Vayan a:</p> <p>File \u2192 Open</p> <p>Cuando se abre un proyecto, el programa pide como entrada los tres archivos con los que estaban trabajando:</p> <ul> <li>Sequence File 1: <code>EcK12.dna</code></li> <li>Comparison File: <code>EcK12vsStiphy.blastn</code></li> <li>Sequence File 2: <code>S_tiphy.dna</code></li> </ul>","tags":["practicos"]},{"location":"practicos/TPXX_Genomica_Comparativa/#navengando-en-act","title":"Navengando en ACT","text":"<p>ACT est\u00e1 basado en Artemis, por lo que ya estar\u00e1n familiarizados con muchas de sus funciones generales; y est\u00e1 compuesto esencialmente de tres capas o ventanas.</p> <ul> <li> <p>La ventana superior e inferior son mini-ventanas de Artemis (con sus funcionalidades heredadas), mostrando la representaci\u00f3n lineal de la secuencia de ADN con sus \"features\" asociados.</p> </li> <li> <p>La ventana del medio, muestra bloques rojos y azules, que se extienden y conectan regiones conservadas entre las dos secuencias.</p> <ul> <li>Los bloques rojos son en el sentido directo</li> <li>Los bloques azules son en el sentido inverso</li> </ul> </li> </ul> <p>Por lo tanto, </p> <ul> <li> <p>Si estuvi\u00e9ramos comparando dos secuencias id\u00e9nticas en la misma orientaci\u00f3n ver\u00edamos, en la capa central, un bloque rojo que se extiende a lo largo de la longitud de las dos secuencias. Como se muestra en la figura siguiente en la parte superior.</p> </li> <li> <p>Si una de las secuencias estuviera invertida se observar\u00eda un bloque azul entre las dos secuencias. Como se muestra en la figura siguiente en la parte inferior para la regi\u00f3n central de los genomas.</p> </li> <li> <p>Regiones \u00fanicas en cualquiera de las secuencias, como deleciones o inserciones, se visualizar\u00e1n como espacios blancos entre los bloques rojos o azules.</p> </li> </ul> <p></p> <p>Veamos c\u00f3mo se organizan estas ventanas y c\u00f3mo podemos hacer para navegar a trav\u00e9s de ellas:</p> <p></p> <ol> <li>Men\u00faes desplegables. Son similares a los que vimos para Artemis, pero ac\u00e1 estamos trabajando con dos secuencias y no una, por lo tanto, salvo el men\u00fa <code>File</code>, lo primero es seleccionar una de las dos secuencias en la comparaci\u00f3n en el men\u00fa.</li> <li>Panel de la secuencia 1. La primera que ingresaron al comenzar la sesi\u00f3n de ACT. Es una mini-ventana de Artemis.</li> <li>Panel de comparaci\u00f3n. Muestra las regiones de similitud (rojo), diferencia (blanco) e inversiones (azul) entre las dos secuencias.</li> <li>Panel de la secuencia 2. La segunda secuencia que ingresaron al comenzar la sesi\u00f3n.</li> <li>Men\u00fa desplegable que se abre al hacer click derecho sobre el panel de comparaci\u00f3n. </li> </ol> <p>Arriba y abajo de las secuencias 1 y 2, respectivamente, ver\u00e1n una barra de desplazamiento horizontal; y a los dos lados de ambas, una barra de desplazamiento vertical. Las primeras se usan para desplazarnos rio arriba o rio abajo en el genoma, mientras que las segundas se usan para acercar o alejar el foco.</p> <ul> <li>Prueben alejar el foco de ambas secuencias hasta que puedan ver ambos cromosomas completos en pantalla.</li> </ul> <p>Deber\u00edan ver algo as\u00ed (o similar):</p> <p></p> <p>Cuando nos desplazamos horizontalmente en una secuencia, la otra se desplaza acompa\u00f1ando el movimiento.</p> <p>Este es el comportamiento por defecto y ocurre porque las secuencias est\u00e1n \"bloqueadas\" o <code>LOCKED</code>. Se se fijan en la imagen anterior, ver\u00e1n que a la izquierda aparece \"LOCKED\" indicando que esa opci\u00f3n est\u00e1 activada.</p> <p>Generalmente es el comportamiento m\u00e1s conveniente, pero si quisi\u00e9ramos desactivarlo podemos hacerlo con click derecho sobre el panel de comparaci\u00f3n y desmarcando la opci\u00f3n <code>Lock Sequences</code>.</p> <p>Se pueden cambiar los umbrales (cutoff) que usa ACT para decidir si dibuja una l\u00ednea o no conectando a los cromosomas. Esto podr\u00eda ser \u00fatil para visualizar patrones o arreglos gen\u00f3micos.</p> <p></p> <p>Hallar\u00e1n estos cuttoffs haciendo click derecho en el panel de comparaci\u00f3n:</p> <p></p> <ul> <li>\u00bfQu\u00e9 patrones o arreglos ven en la comparaci\u00f3n de estos cromosomas? </li> </ul> <p>Agreguen ahora, a S. tiphy las anotaciones con el nombre <code>SPIs.tab</code>. Este archivo contiene todas las islas de patogenicidad de esta Salmonella (incluyendo la SPI-7, con la que trabajamos anteriormente)</p> <p>Para incluir las anotaciones que se encuentran en el archivo <code>.tab</code> vayan a:</p> <p><code>File</code> \u2192 <code>Secuencia</code> \u2192 <code>Read an entry</code> </p> <p></p> <ul> <li>Las islas de patogenicidad \u00bfEst\u00e1n presentes en E. coli K12? Para verlo m\u00e1s f\u00e1cilmente haga zoom en la secuencia y rec\u00f3rrala de principio a fin.</li> </ul>","tags":["practicos"]},{"location":"practicos/TPXX_Genomica_Comparativa/#algunas-cositas-mas-para-probar","title":"Algunas cositas m\u00e1s para probar","text":"<ol> <li>Pueden hacer doble click en las l\u00edneas rojas o azules para centrarlas en pantalla</li> <li>Inviertan alguna de las secuencias (<code>click derecho</code> &gt; <code>Flip subject/query sequence</code>)</li> <li>Para refinar la visualizaci\u00f3n la barra de desplazamiento vertical del panel de comparaci\u00f3n, movi\u00e9ndola hacia arriba o hacia abajo, permite filtrar la aparici\u00f3n de l\u00edneas de comparaci\u00f3n en funci\u00f3n de la longitud del match (m\u00e1s largas o m\u00e1s cortas, respectivamente).</li> </ol> <p>Cuando ya se hayan aburrido, cierren todo para arrancar una nueva sesi\u00f3n con el pr\u00f3ximo ejercicio.</p>","tags":["practicos"]},{"location":"practicos/TPXX_Genomica_Comparativa/#segunda-parte","title":"Segunda Parte:","text":"<p>Esta segunda parte la haremos con dos genomas de pat\u00f3genos eucariotas, emparentados taxon\u00f3micamente: P. falciparum y P. knowlesi. Ambos son agentes etiol\u00f3gicos de la malaria o paludismo.</p> <p>P. falciparum ya ha sido secuenciado parcial y completamente y es el de mayor prevalencia como causante de la enfermedad en humanos.</p> <p>P. knowlesi est\u00e1 menos estudiado ya que est\u00e1 m\u00e1s asociado a paludismo en primates no-humanos</p> <p>Bas\u00e1ndonos en la abundancia de informaci\u00f3n del primero y la cercan\u00eda evolutiva entre ambos, utilizaremos gen\u00f3mica comparativa para extraer informaci\u00f3n sobre P. knowlesi. </p> <p>El objetivo de esta segunda parte es comparar un fragmento gen\u00f3mico (contig) del cromosoma 13 de P. knowlesi con el cromosoma 13 completo de P. falciparum.</p> <p>Esta comparaci\u00f3n nos permitir\u00e1:</p> <ul> <li>Estudiar el grado de conservaci\u00f3n del orden g\u00e9nico (sintenia)</li> <li>Identificar/anotar genes de P. knowlesi. </li> <li>Identificar regiones \u00fanicas en las dos secuencias</li> <li>Verificar una serie de anotaciones autom\u00e1ticas realizadas para P. knowlesi.</li> </ul> <p>Vamos a necesitar los siguientes archivos</p> <ul> <li><code>Pfal_chr13.embl</code> - Archivo combinado con secuencia y anotaciones de P. falciparum </li> <li><code>Pknowlesi_contig.seq</code> - Archivo de secuencia P. knowlesi (sin anotaciones)</li> <li><code>Pknowlesi_contig.embl</code> - Archivo de anotaciones autom\u00e1ticas P. knowlesi </li> <li><code>Plasmodium_comp.crunch</code> - Comparaci\u00f3n entre ambos cromosomas</li> </ul>","tags":["practicos"]},{"location":"practicos/TPXX_Genomica_Comparativa/#sintenia-o-conservacion-del-orden-de-los-genes","title":"Sintenia o conservaci\u00f3n del orden de los genes","text":"<p>Comencemos por cargar nuestros archivos en el ACT.</p> <ul> <li>Sequence File 1: <code>Pfal_chr13.embl</code></li> <li>Comparison File: <code>Plasmodium_comp.crunch</code></li> <li>Sequence File 2: <code>Pknowlesi_contig.seq</code></li> </ul> <p>Deber\u00edan ver algo as\u00ed:</p> <p></p> <p>NOTA</p> <p>P. falciparum tienen un archivo combinado que incluye secuencia y anotaciones (<code>*.embl</code>).</p> <p>P. knowlesi tienen un archivo de secuencia (<code>*.seq</code>) y un archivo de anotaciones (<code>*.embl</code>) que luego deberan cargar.</p> <ul> <li> <p>Incluyan las anotaciones de P. knowlesi (<code>Pknowlesi_contig.embl</code>)</p> </li> <li> <p>Utilicen las barras de desplazamiento horizontal para ubicar el contig de P. knowlesi en el cromosoma 13 de P. falciparum.</p> </li> </ul> <p>Sugerencia: apaguen los codones de stop para ver mejor las regiones codificantes. Haga click derecho sobre la secuencia y desclicke\u00e9 codones stop.</p> <ul> <li>\u00bfQu\u00e9 ven? </li> <li>\u00bfQu\u00e9 hay de diferente entre los arreglos gen\u00e9ticos que vimos para bacterias y los que vemos para estos par\u00e1sitos?</li> <li>\u00bfHay regiones conservadas entre ambos par\u00e1sitos?</li> <li>\u00bfQu\u00e9 pasa con el orden de los genes?</li> <li>\u00bfPueden ver alguna regi\u00f3n en la que similitud est\u00e9 \"rota\"?</li> <li>Hagan zoom a alguno de los genes anotados en P. falciparum. \u00bfQu\u00e9 pasa con los genes predichos en P. knowlesi?</li> <li>\u00bfPueden identificar genes conservados anotados en P. falciparum que no hayan sido debidamente anotados/predichos en P. knowlesi?</li> </ul> <p>Ahora concentr\u00e9monos en una regi\u00f3n particular. Dir\u00edjanse a la regi\u00f3n delimitada por las coordenadas 815823..829969 en el cromosoma de P. falciparum. Hay una regi\u00f3n codificante.</p> <ul> <li>\u00bfDe qu\u00e9 gen se trata? (<code>Click derecho</code> \u2192 <code>View</code> \u2192 <code>Selected Features</code>)</li> <li>\u00bfEst\u00e1 presente en P. knowlesi?</li> <li>\u00bfQu\u00e9 opini\u00f3n les merece, en t\u00e9rminos de relevancia biol\u00f3gica, esta observaci\u00f3n?</li> </ul>","tags":["practicos"]},{"location":"practicos/TPXX_Genomica_Comparativa/#prediccion-de-modelos-de-genes","title":"Predicci\u00f3n de modelos de genes","text":"<p>Por \u00faltimo, evaluaremos la capacidad de anotaci\u00f3n autom\u00e1tica utilizada para crear las anotaciones de P. knowlesi.</p> <p>El archivo de anotaciones de P. knowlesi se construy\u00f3 con un anotador autom\u00e1tico: PHAT (**P**retty **H**andy **A**nnotation **T**ool, Mol. Biochem. Parasitol. 2001 Dec;118(2):167-74). Existen otros algoritmos con la misma funci\u00f3n pero ninguno es perfecto al 100% y en general es necesario curar o refinar las predicciones.</p> <p>Dir\u00edjanse, en el genoma de P. falciparum, al gen anotado como PFM1010w (o MAL13P1.103) usando el Navigator.</p> <ul> <li>\u00bfPueden encontrar este gen en ambos par\u00e1sitos? \u00bfQu\u00e9 exon/es est\u00e1/n conservado/s? Pueden usar el deslizador vertical del panel de comparaci\u00f3n para incluir hits m\u00e1s cortos.</li> <li>\u00bfPueden encontrar a todos los exones en el contig de P. knowlesi (ignoren por ahora el Phat4_alternative en rojo)?</li> </ul> <p>Eval\u00faen las siguientes regiones en el cromosoma 13 de P. falciparum en Artemis. </p> <ul> <li>789034..793351, </li> <li>657638..660023, </li> <li>672361..673753</li> </ul> <p>Pueden abrir una sesi\u00f3n de Artemis directamente desde ACT:</p> <p></p> <ul> <li>Revisen las regiones intrones (regiones entre exones). Observen las dos bases del inicio del intr\u00f3n y las dos bases nucleot\u00eddicas del final del intr\u00f3n \u00bfPueden hallar alg\u00fan patr\u00f3n? (Revisen la hebra correcta del ADN)</li> <li>\u00bfCon qu\u00e9 proceso piensan que este patr\u00f3n puede estar relacionado?</li> <li>A simple vista, \u00bfobservan enriquecimiento en alg\u00fan par de nucle\u00f3tidos en los intrones?</li> </ul>","tags":["practicos"]},{"location":"practicos/TPXX_Genomica_Comparativa/#sintenias-camufladas","title":"Sintenias camufladas","text":"<p>Por \u00faltimo, vamos a buscar regiones sint\u00e9nicas entre dos nuevos par\u00e1sitos, Trypanosoma brucei y Leishmania major. Ambos son organismos eucariotas taxon\u00f3micamente emparentados por familia (Trypanosomatidae). </p> <p>Trypanosoma brucei es el causante de la enfermedad del sue\u00f1o, y Leishmania major de la leishmaniasis. En este ejercicio evaluaremos la arquitectura de ambos genomas y la existencia de regiones de sintenia entre \u00e9stos.</p> <p>Los archivos que usaremos son:</p> <ul> <li><code>Tbrucei.dna</code> - secuencia T. brucei</li> <li><code>Tbrucei.embl</code> - anotaciones T. brucei </li> <li><code>Leish_vs_Tbrucei.tblastx</code> - archivo de comparaci\u00f3n</li> <li><code>Leish.dna</code> - secuencia L. major </li> <li><code>Leish.embl</code> - anotaciones L. major </li> </ul> <p>Comiencen cargando las secuencias, apagando codones de stop y agregando las anotaciones.</p> <ul> <li>\u00bfQu\u00e9 pasa con la conservaci\u00f3n de la arquitectura gen\u00f3mica entre estos dos cromosomas? \u00bfDir\u00edan que hay o que no hay sintenia?</li> </ul>","tags":["practicos"]},{"location":"teoricas/inicio/","title":"Inicio","text":"<p>Esta es la p\u00e1gina de inicio de la parte Te\u00f3rica del curso. </p>","tags":["teoricas"]},{"location":"teoricas/inicio/#consultas-y-canales-de-comunicacion","title":"Consultas y canales de comunicaci\u00f3n","text":"<ul> <li> Por email a la direcci\u00f3n del profesor titular o profesores invitados.</li> <li> mensajes en Discord con consultas en distintos canales    </li> </ul>","tags":["teoricas"]},{"location":"teoricas/resumen/","title":"Resumen","text":"<p>Aca tiene que ir algo</p>","tags":["teoricas"]},{"location":"teoricas/1-Teorica-Uno/","title":"Teorica Uno","text":"","tags":["teoricas"]},{"location":"teoricas/1-Teorica-Uno/#presentacion-de-la-materia","title":"Presentaci\u00f3n de la materia","text":"<p>Docentes, modo de cursada, cronograma, evaluaciones, etc.</p> <ul> <li> Slides </li> </ul>","tags":["teoricas"]},{"location":"teoricas/1-Teorica-Uno/#conceptos-elementales-de-computacion-y-algoritmos","title":"Conceptos elementales de computaci\u00f3n y algoritmos","text":"<ul> <li> Slides </li> <li> Clase Grabada en 2022</li> </ul>","tags":["teoricas"]},{"location":"teoricas/1-Teorica-Uno/#bases-de-datos","title":"Bases de datos","text":"<ul> <li> Slides </li> <li> Clase Grabada en 2023</li> <li> Clase Grabada en 2022</li> </ul>","tags":["teoricas"]},{"location":"teoricas/1-Teorica-Uno/#material-de-lectura-y-consulta","title":"Material de lectura y consulta","text":"<ul> <li> Introduction to Algorithms (2009). Cormen, Leiserson, Rivest, Stein. 3<sup>rd</sup> Edition, MIT Press.</li> <li> Introduction to Bioinformatics (2019), 4<sup>th</sup> Edition. Oxford University Press. Arthur M Lesk (hay dos copias en el lab). </li> <li> SQLBolt Learn SQL with simple, interactive exercises.  </li> <li> XKCD Query</li> <li> Ten Simple Rules for Developing Public Biological Databases. Helmy M, Crits-Christoph A, Bader GD (2016). PLoS Comput Biol 12(11): e1005128. </li> <li> Primary and secondary databases - Bioinformatics for the terrified. An introduction to the science of bioinformatics (EMBL-EBI Training, Online Course).</li> </ul>","tags":["teoricas"]},{"location":"teoricas/10-Teorica-Diez/","title":"Teorica Diez","text":"","tags":["teoricas"]},{"location":"teoricas/10-Teorica-Diez/#bioinformatica-estructural-desorden","title":"Bioinform\u00e1tica Estructural: Desorden","text":"<ul> <li> <p> Slides </p> </li> <li> <p> Video</p> </li> </ul>","tags":["teoricas"]},{"location":"teoricas/11-Teorica-Once/","title":"Teorica  Once","text":"","tags":["teoricas"]},{"location":"teoricas/11-Teorica-Once/#bioinformatica-estructural-motivos-lineales","title":"Bioinform\u00e1tica Estructural: Motivos lineales","text":"<ul> <li> <p> Slides </p> </li> <li> <p> Video</p> </li> </ul>","tags":["teoricas"]},{"location":"teoricas/12-Teorica-Doce/","title":"Teorica Doce","text":"","tags":["teoricas"]},{"location":"teoricas/12-Teorica-Doce/#bioinformatica-estructural-dominios","title":"Bioinform\u00e1tica Estructural: Dominios","text":"<ul> <li> <p> Slides </p> </li> <li> <p> Video</p> </li> </ul>","tags":["teoricas"]},{"location":"teoricas/2-Teorica-Dos/","title":"Teorica Dos","text":"","tags":["teoricas"]},{"location":"teoricas/2-Teorica-Dos/#alineamientos-de-secuencias-y-sistemas-de-puntaje","title":"Alineamientos de secuencias y Sistemas de puntaje","text":"<p>Clase te\u00f3rica de alineamientos de secuencias (de a pares), Algoritmos, Matrices.</p> <ul> <li> Slides </li> <li> Clase grabada en 2023</li> </ul>","tags":["teoricas"]},{"location":"teoricas/2-Teorica-Dos/#busquedas-de-secuencias-por-similitud","title":"B\u00fasquedas de Secuencias por Similitud","text":"<p>Clase te\u00f3rica de b\u00fasquedas de secuencias por similitud: fuerza bruta (sin heur\u00edsticas), y heur\u00edsticas para reducir espacios de b\u00fasqueda: FASTA, BLAST. </p> <ul> <li> Slides </li> <li> Clase grabada en 2023</li> </ul>","tags":["teoricas"]},{"location":"teoricas/2-Teorica-Dos/#material-de-lectura-y-consulta","title":"Material de lectura y consulta","text":"<ul> <li> Needleman SB, Wunsch CD. (1970) A general method applicable to the search for similarities in the amino acid sequence of two proteins. J Mol Biol.48: 443-53 (PDF de estudio).</li> <li> Smith TF, Waterman MS. (1981) Identification of common molecular subsequences. J Mol Biol. 147:195-7 (PDF de estudio).</li> <li> Selecting the Right Similarity-Scoring Matrix. Pearson, W. R. (2013) Curr. Prot. Bioinformatics Chapter 3: Unit 3.5</li> <li> Sequence alignment</li> </ul>","tags":["teoricas"]},{"location":"teoricas/3-Teorica-Tres/","title":"Teorica Tres","text":"","tags":["teoricas"]},{"location":"teoricas/3-Teorica-Tres/#busquedas-de-secuencias-en-bases-de-datos-estadistica","title":"B\u00fasquedas de secuencias en bases de datos: estad\u00edstica","text":"<p>Continuaci\u00f3n de la clase te\u00f3rica de algoritmos heur\u00edsticos de b\u00fasqueda de secuencias similares en bases de datos. </p> <ul> <li> Slides </li> <li> Clase grabada en 2023</li> <li> Clase dictada virtual por paro docente   Sesion Zoom grabada</li> </ul>","tags":["teoricas"]},{"location":"teoricas/3-Teorica-Tres/#material-de-lectura-y-consulta","title":"Material de lectura y consulta","text":"<ul> <li> Needleman SB, Wunsch CD. (1970) A general method applicable to the search for similarities in the amino acid sequence of two proteins. J Mol Biol.48: 443-53.</li> <li> Selecting the Right Similarity-Scoring Matrix. Pearson, W. R. (2013) Curr. Prot. Bioinformatics Chapter 3: Unit 3.5</li> <li> Sequence alignment</li> <li> Having a BLAST with bioinformatics (and avoiding BLASTphemy). Pertsemlidis, A., Fondon, J.W. (2001) Genome Biol 2, reviews2002.1</li> <li> Selecting the Right Similarity-Scoring Matrix. Pearson, W. R. (2013) Curr. Prot. Bioinformatics Chapter 3: Unit 3.5</li> <li> An Introduction to Similarity (\"Homology\") Searching. Pearson, W. R. (2013) Curr. Prot. Bioinformatics Chapter 3: Unit 3.1</li> </ul>","tags":["teoricas"]},{"location":"teoricas/4-Teorica-Cuatro/","title":"Teorica Cuatro","text":"","tags":["teoricas"]},{"location":"teoricas/4-Teorica-Cuatro/#busquedas-de-secuencias-por-similitud-alineamientos-multiples","title":"B\u00fasquedas de Secuencias por Similitud + Alineamientos m\u00faltiples","text":"<p>Clase te\u00f3rica de b\u00fasquedas de secuencias por similitud: fuerza bruta, FASTA, BLAST.   Alineamientos m\u00faltiples.</p> <ul> <li> Slides B\u00fasquedas</li> <li> Slides Alineamientos </li> </ul>","tags":["teoricas"]},{"location":"teoricas/4-Teorica-Cuatro/#videos-de-clases-grabadas-de-otros-anos","title":"Videos de clases grabadas de otros a\u00f1os","text":"<p>Videos de Clases dictadas en 2022/2023:</p> <ul> <li> Primera parte: alineamientos multiples, 2022</li> <li> Segunda parte: PSSMs, Sequence Logos, weight matrices, 2023</li> </ul>","tags":["teoricas"]},{"location":"teoricas/4-Teorica-Cuatro/#material-de-lectura-y-consulta","title":"Material de lectura y consulta","text":"<ul> <li> Sequence homology.</li> <li> Orthologs, paralogs, and evolutionary genomics. Koonin EV (2005). Annu Rev Genet 39:309-38.</li> <li> Computational methods for Gene Orthology inference. Kristensen DM, Wolf YI, Mushegian AR, Koonin EV (2011) Briefings in Bioinformatics 12: 379\u2013391.</li> <li> Simple chained guide trees give high-quality protein multiple sequence alignments. Boyce K, Sievers F, and Higgins DG (2014). PNAS 111, 10556-10561.</li> <li> Chapter 10 PSI-BLAST Tutorial (Comparative Genomics: Volumes 1 and 2) (2007). NCBI Bookshelf</li> <li> Having a BLAST with bioinformatics (and avoiding BLASTphemy). Pertsemlidis, A., Fondon, J.W. (2001) Genome Biol 2, reviews2002.1</li> <li> Selecting the Right Similarity-Scoring Matrix. Pearson, W. R. (2013) Curr. Prot. Bioinformatics Chapter 3: Unit 3.5</li> <li> An Introduction to Similarity (\"Homology\") Searching. Pearson, W. R. (2013) Curr. Prot. Bioinformatics Chapter 3: Unit 3.1</li> <li> Multiple Sequence Alignment</li> <li> A Novel algorithm for identifying low-complexity regions in a protein sequence. Xuehui Li, Tamer Kahveci (2006) Bioinformatics 22: 2980--2987</li> <li> Software to detect low complexity regions</li> </ul>","tags":["teoricas"]},{"location":"teoricas/5-Teorica-Cinco/","title":"Teorica Cinco","text":"","tags":["teoricas"]},{"location":"teoricas/5-Teorica-Cinco/#informacion-contenida-en-alineamientos-multiples","title":"Informaci\u00f3n contenida en alineamientos m\u00faltiples","text":"<p>Clase te\u00f3rica informaci\u00f3n contenida en alineamientos m\u00faltiples</p> <p>Esta clase incluye ejercicios para resolver (handout).</p>","tags":["teoricas"]},{"location":"teoricas/5-Teorica-Cinco/#weight-matrices-sequence-motifs-information-content-and-sequence-logos","title":"Weight matrices, Sequence motifs, Information content, and Sequence logos","text":"<ul> <li> <p> Slides</p> </li> <li> <p> Ejercicios - Logo</p> <ul> <li> Answers - Logo</li> </ul> </li> <li> <p> Ejercicios - Pseudocounts</p> <ul> <li> Answers - Pseudocounts</li> </ul> </li> </ul>","tags":["teoricas"]},{"location":"teoricas/5-Teorica-Cinco/#sequence-profiles","title":"Sequence profiles","text":"<ul> <li> <p> Slides</p> </li> <li> <p> Ejercicios</p> </li> </ul>","tags":["teoricas"]},{"location":"teoricas/5-Teorica-Cinco/#videos-de-la-clase-grabada","title":"Videos de la clase grabada","text":"<ul> <li> Clase</li> </ul>","tags":["teoricas"]},{"location":"teoricas/6-Teorica-Seis/","title":"Teorica Seis","text":"","tags":["teoricas"]},{"location":"teoricas/6-Teorica-Seis/#metodos-de-prediccion-de-machine-learning-basados-en-datos-hmm-y-ann","title":"M\u00e9todos de predicci\u00f3n de Machine Learning basados en datos (HMM y ANN)","text":"<p>Clase te\u00f3rica de hidden markov models y neural networks.</p>","tags":["teoricas"]},{"location":"teoricas/6-Teorica-Seis/#hidden-markov-models-hmm","title":"Hidden Markov Models (HMM)","text":"<ul> <li> <p> Slides</p> </li> <li> <p> HMM Video de la Clase</p> </li> </ul>","tags":["teoricas"]},{"location":"teoricas/6-Teorica-Seis/#material-de-lectura-y-consulta","title":"Material de lectura y consulta","text":"<ul> <li> Immunological Bioinformatics. Ole Lund, Morten Nielsen, Claus Lundegaard, Can Kesmir, S\u00f8ren Brunak. DOI: https://doi.org/10.7551/mitpress/3679.001.0001. The MIT Press (2005). Chapters 3 and 4</li> </ul>","tags":["teoricas"]},{"location":"teoricas/7-Teorica-Siete/","title":"Teorica Siete","text":"","tags":["teoricas"]},{"location":"teoricas/7-Teorica-Siete/#quimioinformatica","title":"Quimioinform\u00e1tica","text":"<p>Clase te\u00f3rica de introducci\u00f3n al uso y an\u00e1lisis de mol\u00e9culas qu\u00edmicas peque\u00f1as en la computadora. Representacion digital y electr\u00f3nica de mol\u00e9culas, formatos, algoritmos de b\u00fasqueda de similitud quimica. </p> <ul> <li> Slides </li> <li> Video de clase pasada (el contenido puede no coincidir totalmente con la clase de este a\u00f1o!!)</li> </ul>","tags":["teoricas"]},{"location":"teoricas/7-Teorica-Siete/#material-de-lectura-y-consulta","title":"Material de lectura y consulta","text":"","tags":["teoricas"]},{"location":"teoricas/7-Teorica-Siete/#cheminformatics-kits-frameworks","title":"Cheminformatics kits, frameworks","text":"<ul> <li> RDKit: Open Source Cheminformatics Software (Python, Java, C++, JavaScript)</li> <li> The Chemistry Development Kit (CDK) (Java)</li> <li> Open Babel: the chemistry toolbox (ejecutable: Windows, Linux, MacOSX)</li> <li> ChemFP -- very fast cheminformatics fingerprinting. (Python)</li> </ul>","tags":["teoricas"]},{"location":"teoricas/7-Teorica-Siete/#books-papers","title":"Books, Papers","text":"<ul> <li> The RDKit Book (2023)</li> <li> Willighagen EL, et al. The Chemistry Development Kit (CDK), v2.0: atom typing, depiction, molecular formulas and substructure searching.J Cheminform. 2017 Jun 6;9(1):33. </li> <li> Noel M. O\u2019Boyle, Michael Banck, Craig A. James, Chris Morley, Tim Vandermeersch, Geoffrey R. Hutchison. Open Babel: An open chemical toolbox. J. Cheminf. 2011, 3, 33.</li> <li> The ChemFP Project (2019).</li> <li> Essentials of Computational Chemistry (2004), 2<sup>nd</sup> Ed, CJ Cramer. Wiley.</li> <li> Chemogenomics in Drug Discovery: A Medicinal Chemistry Perspective (2006).  Edited by Hugo Kubinyi &amp; Gerhard M\u00fcller, Wiley-VCH.</li> <li> Artificial Intelligence in Drug Discovery (2020). Edited by Nathan Brown. Royal Society of Chemistry.</li> <li> An Introduction to Chemoinformatics (2007). Andrew Leach and Valerie Gillet. Springer.</li> </ul>","tags":["teoricas"]},{"location":"teoricas/8-Teorica-Ocho/","title":"Teorica Ocho","text":"","tags":["teoricas"]},{"location":"teoricas/8-Teorica-Ocho/#analisis-de-datos","title":"An\u00e1lisis de Datos","text":"<p>Clase te\u00f3rica de an\u00e1lisis de datos y agrupamiento de datos (clustering). Algoritmos, m\u00e9tricas, reducci\u00f3n de dimensionalidad.</p> <ul> <li> Slides </li> <li> Video grabado en 2023</li> </ul>","tags":["teoricas"]},{"location":"teoricas/8-Teorica-Ocho/#material-de-lectura-y-consulta","title":"Material de lectura y consulta","text":"<ul> <li> Jain AK, Murty MN, Flynn PJ (1999) Data clustering: a review.</li> <li> Cluster Analysis</li> <li> K-means Clustering</li> <li> Metric Spaces</li> <li> A commentary on Heatmap Plots and Distance metrics and Divergences by Lior Pachter</li> <li> scikit learn: clustering (Python)</li> <li> Exploratory Data Analysis with R (R)</li> <li> Witten IH, Frank E, Hall MA (2011) Data Mining: Practical Machine Learning Tools and Techniques, 3<sup>rd</sup> Edition.</li> </ul>","tags":["teoricas"]},{"location":"teoricas/9-Teorica-Nueve/","title":"Teorica Nueve","text":"","tags":["teoricas"]},{"location":"teoricas/9-Teorica-Nueve/#secuenciacion-y-ensamblado-de-genomas","title":"Secuenciaci\u00f3n y ensamblado de genomas","text":"<p>Clase te\u00f3rica sobre m\u00e9todos de secuenciaci\u00f3n, ensamblado de genomas, mapeo de lecturas contra referencia, etc. Valores de calidad de base, c\u00e1lculo de coberturas, algoritmos.</p> <ul> <li> Slides </li> <li> Video grabado en 2023. </li> </ul>","tags":["teoricas"]},{"location":"teoricas/9-Teorica-Nueve/#material-de-lectura-y-consulta","title":"Material de lectura y consulta","text":"<ul> <li> Compeau PEC, Pevzner PA, Tesler G. How to apply de Bruijn graphs to genome assembly. Nature Biotechnol 29: 987, 2011. PDF de estudio.</li> <li> Nagarajan, N., &amp; Pop, M. (2013). Sequence assembly demystified. Nature Reviews Genetics, 14(3), 157\u2013167. doi:10.1038/nrg3367. PDF de estudio.</li> <li> Rice, E. S., &amp; Green, R. E. (2018). New Approaches for Genome Assembly and Scaffolding. Annual Review of Animal Biosciences, 7(1). doi:10.1146/annurev-animal-020518-115344. PDF de estudio.</li> <li> Ribeiro FJ, Przybylski D, Yin S, et al. Finished bacterial genomes from shotgun sequence data. Genome Res. 2012 Nov;22(11):2270-7. doi:10.1101/gr.141515.112. PMID: 22829535; PMCID: PMC3483556.</li> <li> Phred Quality Score</li> <li> K-mers </li> <li> N50, L50 and related statistics</li> </ul>","tags":["teoricas"]},{"location":"teoricas/9-Teorica-Nueve/#software","title":"Software","text":"<ul> <li> FASTQC</li> <li> MultiQC</li> <li> KAT: K-mer Analysis Toolkit</li> </ul>","tags":["teoricas"]},{"location":"teoricas/xx-Teorica-Seis-Filogenia-Old/","title":"Teorica Seis","text":"","tags":["teoricas"]},{"location":"teoricas/xx-Teorica-Seis-Filogenia-Old/#reconstruccion-filogenetica","title":"Reconstruccion filogenetica","text":"<p>Clase te\u00f3rica de reconstrucci\u00f3n filogen\u00e9tica. Algoritmos, Alineamientos y Arboles.</p> <ul> <li> Slides </li> </ul> <p></p>","tags":["teoricas"]},{"location":"teoricas/xx-Teorica-Seis-Filogenia-Old/#material-de-lectura-y-consulta","title":"Material de lectura y consulta","text":"<ul> <li> Phylogenetic tree building in the genomic age. Kapli P, Yang Z, Telford MJ (2020) Nature Reviews Genetics 21:428-444.  Sci Hub</li> <li> UPGMA (unweighted pair group method with arithmetic mean) Wikipedia</li> <li> Neighbor joining Wikipedia</li> </ul>","tags":["teoricas"]},{"location":"teoricas/xx-Teorica-Seis-old/","title":"Teorica xx","text":"","tags":["teoricas"]},{"location":"teoricas/xx-Teorica-Seis-old/#bioinformatica-estructural-desorden","title":"Bioinform\u00e1tica Estructural: Desorden","text":"<p>Clase te\u00f3rica de biolog\u00eda estructural. Caracter\u00edsticas de las prote\u00ednas desordenadas. Predicci\u00f3n de desorden y bases de datos de prote\u00ednas desordenadas.</p> <ul> <li> <p> Slides</p> </li> <li> <p> Predicci\u00f3n de Desorden</p> </li> </ul>","tags":["teoricas"]}]}